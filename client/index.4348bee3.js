import{S as e,i as t,s as n,e as r,t as a,c as i,a as s,b as o,d as c,f as l,g as m,h as u,n as p,j as f,k as d,l as h,m as y,o as v,p as g,r as b,q as $,u as O,v as I,w as x,x as w,y as S,z as E,A as j,B as P,C as A,D as k,E as T,F as C,G as N,H as R,I as q,J as M,K as D,L as V}from"./client.ec17dac1.js";var L=function(e,t){return function n(){null==t&&(t=e.length);var r=[].slice.call(arguments);return r.length>=t?e.apply(this,r):function(){return n.apply(this,r.concat([].slice.call(arguments)))}}};var _="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function J(e,t,n){return e(n={path:t,exports:{},require:function(e,t){return function(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}(null==t&&n.path)}},n.exports),n.exports}var F=J((function(e,t){var n;n={},("object"==typeof window&&window||_).PubSub=n,function(e){var t={},n=-1,r="*";function a(e){var t;for(t in e)if(e.hasOwnProperty(t))return!0;return!1}function i(e){return function(){throw e}}function s(e,t,n){try{e(t,n)}catch(e){setTimeout(i(e),0)}}function o(e,t,n){e(t,n)}function c(e,n,r,a){var i,c=t[n],l=a?o:s;if(t.hasOwnProperty(n))for(i in c)c.hasOwnProperty(i)&&l(c[i],e,r)}function l(e,t,n){return function(){var a=String(e),i=a.lastIndexOf(".");for(c(e,e,t,n);-1!==i;)i=(a=a.substr(0,i)).lastIndexOf("."),c(e,a,t,n);c(e,r,t,n)}}function m(e){var n=String(e);return Boolean(t.hasOwnProperty(n)&&a(t[n]))}function u(e){for(var t=String(e),n=m(t)||m(r),a=t.lastIndexOf(".");!n&&-1!==a;)a=(t=t.substr(0,a)).lastIndexOf("."),n=m(t);return n}function p(e,t,n,r){var a=l(e="symbol"==typeof e?e.toString():e,t,r);return!!u(e)&&(!0===n?a():setTimeout(a,0),!0)}e.publish=function(t,n){return p(t,n,!1,e.immediateExceptions)},e.publishSync=function(t,n){return p(t,n,!0,e.immediateExceptions)},e.subscribe=function(e,r){if("function"!=typeof r)return!1;e="symbol"==typeof e?e.toString():e,t.hasOwnProperty(e)||(t[e]={});var a="uid_"+String(++n);return t[e][a]=r,a},e.subscribeAll=function(t){return e.subscribe(r,t)},e.subscribeOnce=function(t,n){var r=e.subscribe(t,(function(){e.unsubscribe(r),n.apply(this,arguments)}));return e},e.clearAllSubscriptions=function(){t={}},e.clearSubscriptions=function(e){var n;for(n in t)t.hasOwnProperty(n)&&0===n.indexOf(e)&&delete t[n]},e.countSubscriptions=function(e){var n,r=0;for(n in t)t.hasOwnProperty(n)&&0===n.indexOf(e)&&r++;return r},e.getSubscriptions=function(e){var n,r=[];for(n in t)t.hasOwnProperty(n)&&0===n.indexOf(e)&&r.push(n);return r},e.unsubscribe=function(n){var r,a,i,s=function(e){var n;for(n in t)if(t.hasOwnProperty(n)&&0===n.indexOf(e))return!0;return!1},o="string"==typeof n&&(t.hasOwnProperty(n)||s(n)),c=!o&&"string"==typeof n,l="function"==typeof n,m=!1;if(!o){for(r in t)if(t.hasOwnProperty(r)){if(a=t[r],c&&a[n]){delete a[n],m=n;break}if(l)for(i in a)a.hasOwnProperty(i)&&a[i]===n&&(delete a[i],m=!0)}return m}e.clearSubscriptions(n)}}(n),void 0!==e&&e.exports&&(t=e.exports=n),t.PubSub=n,e.exports=t=n}));F.PubSub;const z=e=>{if(e.length>0&&"/"!==e[0])throw Error("Invalid JSON Pointer");return e.split("/").slice(1).map(W)},U=(e,t,n,r)=>{if(0===e.length)return n;if(e.length>1){const a=e.shift();return{...t,[a]:U(e,Q(t,a,r),n,X(a,r))}}if(Array.isArray(t)){const r=[...t];return r[Z(t,e[0])]=n,r}return"object"==typeof t&&null!==t?{...t,[e[0]]:n}:Q(t,e[0],r)},B=(e,t,n,r)=>{if(0!==e.length)if(1!==e.length||Y(t)){const a=e.shift();B(e,Q(t,a,r),n,X(a,r))}else{t[Z(t,e[0])]=n}},K=(e,t,n)=>{if(0!=e.length){if(e.length>1){const r=e.shift(),a=Q(t,r,n);return{...t,[r]:K(e,a,X(r,n))}}if(Array.isArray(t))return t.filter(((t,n)=>n!=e[0]));if("object"==typeof t&&null!==t){const{[e[0]]:n,...r}=t;return r}return Q(t,e[0],n)}},G=(e,t,n)=>{if(0!==e.length)if(e.length>1){const r=e.shift(),a=Q(t,r,n);G(e,a,X(r,n))}else Array.isArray(t)?t.splice(e[0],1):"object"==typeof t&&null!==t?delete t[e[0]]:Q(t,e[0],n)},X=L(((e,t)=>t+"/"+H(e))),H=e=>e.toString().replace(/~/g,"~0").replace(/\//g,"~1"),W=e=>e.toString().replace(/~1/g,"/").replace(/~0/g,"~"),Z=(e,t)=>Array.isArray(e)&&"-"===t?e.length:t,Q=(e,t,n="")=>{if(void 0===e)throw TypeError(`Value at '${n}' is undefined and does not have property '${t}'`);if(null===e)throw TypeError(`Value at '${n}' is null and does not have property '${t}'`);if(Y(e))throw TypeError(`Value at '${n}' is a ${typeof e} and does not have property '${t}'`);return e[Z(e,t)]},Y=e=>null===e||"object"!=typeof e;var ee={nil:"",append:X,get:(e,t)=>{const n=z(e),r=e=>n.reduce((([e,t],n)=>[Q(e,n,t),X(n,t)]),[e,""])[0];return void 0===t?r:r(t)},set:(e,t,n)=>{const r=z(e),a=L(((e,t)=>U(r,e,t,"")));return void 0===t?a:a(t,n)},assign:(e,t,n)=>{const r=z(e),a=L(((e,t)=>B(r,e,t,"")));return void 0===t?a:a(t,n)},unset:(e,t)=>{const n=z(e),r=e=>K(n,e,"");return void 0===t?r:r(t)},delete:(e,t)=>{const n=z(e),r=e=>G(n,e,"");return void 0===t?r:r(t)}};const te={null:e=>null===e,boolean:e=>"boolean"==typeof e,object:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,array:e=>Array.isArray(e),number:e=>"number"==typeof e,integer:e=>Number.isInteger(e),string:e=>"string"==typeof e};var ne={jsonTypeOf:(e,t)=>te[t](e),splitUrl:e=>{const t=e.indexOf("#"),n=-1===t?e.length:t,r=e.slice(0,n),a=e.slice(n+1);return[decodeURI(r),decodeURI(a)]}};const re=Symbol("$__value"),ae=Symbol("$__href"),ie=Symbol("$__isDynamic");var se=(e,t,n=!1)=>Object.freeze({[ae]:e,[re]:t,[ie]:n}),oe=e=>e&&void 0!==e[ae],ce=e=>e[ae],le=e=>e[re],me=e=>e[ie];const{jsonTypeOf:ue}=ne,pe=Object.freeze({id:"",pointer:"",instance:void 0,value:void 0}),fe=e=>oe(e.value)?le(e.value):e.value,de=L(((e,t)=>ue(fe(e),t))),he=(e,t)=>Object.freeze({...t,pointer:ee.append(e,t.pointer),value:fe(t)[e]}),ye=L(((e,t)=>fe(t).map(((n,r,a,i)=>e(he(r,t),r,a,i))))),ve=L(((e,t)=>fe(t).map(((e,n,r,a)=>he(n,t))).filter(((t,n,r,a)=>e(t,n,r,a))))),ge=L(((e,t,n)=>fe(n).reduce(((t,r,a)=>e(t,he(a,n),a)),t))),be=L(((e,t)=>fe(t).every(((n,r,a,i)=>e(he(r,t),r,a,i))))),$e=L(((e,t)=>fe(t).some(((n,r,a,i)=>e(he(r,t),r,a,i)))));var Oe={cons:(e,t="")=>Object.freeze({...pe,id:t,instance:e,value:e}),uri:e=>`${e.id}#${encodeURI(e.pointer)}`,value:fe,typeOf:de,step:he,entries:e=>Object.keys(fe(e)).map((t=>[t,he(t,e)])),keys:e=>Object.keys(fe(e)),map:ye,filter:ve,reduce:ge,every:be,some:$e,length:e=>fe(e).length},Ie=/; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g,xe=/^[\u000b\u0020-\u007e\u0080-\u00ff]+$/,we=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/,Se=/\\([\u000b\u0020-\u00ff])/g,Ee=/([\\"])/g,je=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */function Pe(e){var t=String(e);if(we.test(t))return t;if(t.length>0&&!xe.test(t))throw new TypeError("invalid parameter value");return'"'+t.replace(Ee,"\\$1")+'"'}function Ae(e){this.parameters=Object.create(null),this.type=e}var ke={format:function(e){if(!e||"object"!=typeof e)throw new TypeError("argument obj is required");var t=e.parameters,n=e.type;if(!n||!je.test(n))throw new TypeError("invalid type");var r=n;if(t&&"object"==typeof t)for(var a,i=Object.keys(t).sort(),s=0;s<i.length;s++){if(a=i[s],!we.test(a))throw new TypeError("invalid parameter name");r+="; "+a+"="+Pe(t[a])}return r},parse:function(e){if(!e)throw new TypeError("argument string is required");var t="object"==typeof e?function(e){var t;"function"==typeof e.getHeader?t=e.getHeader("content-type"):"object"==typeof e.headers&&(t=e.headers&&e.headers["content-type"]);if("string"!=typeof t)throw new TypeError("content-type header is missing from object");return t}(e):e;if("string"!=typeof t)throw new TypeError("argument string is required to be a string");var n=t.indexOf(";"),r=-1!==n?t.substr(0,n).trim():t.trim();if(!je.test(r))throw new TypeError("invalid media type");var a=new Ae(r.toLowerCase());if(-1!==n){var i,s,o;for(Ie.lastIndex=n;s=Ie.exec(t);){if(s.index!==n)throw new TypeError("invalid parameter format");n+=s[0].length,i=s[1].toLowerCase(),'"'===(o=s[2])[0]&&(o=o.substr(1,o.length-2).replace(Se,"$1")),a.parameters[i]=o}if(n!==t.length)throw new TypeError("invalid parameter format")}return a}},Te=async e=>Object.entries(await e),Ce=L((async(e,t)=>(await t).map(e))),Ne=L((async(e,t,n)=>(await n).reduce((async(t,n)=>e(await t,n)),t))),Re=L((async(e,t,n={})=>Ne((async(t,n)=>await e(n)?t.concat([n]):t),[],t,n))),qe=L((async(e,t)=>{const n=await Ce(e,t);return(await Promise.all(n)).some((e=>e))})),Me=L((async(e,t)=>{const n=await Ce(e,t);return(await Promise.all(n)).every((e=>e))})),De=L(((e,t)=>e.reduce((async(e,t)=>t(await e)),t))),Ve={entries:Te,map:Ce,filter:Re,reduce:Ne,some:qe,every:Me,pipeline:De,all:e=>Promise.all(e),allValues:e=>De([Te,Ne((async(e,[t,n])=>(e[t]=await n,e)),{})],e)},Le=function(e,t){if(e=e.trim(),(t=t.trim()).startsWith("about:"))return t;const n=function(e){const t={host:"",path:"",query:"",protocol:""};let n=e,r=e.indexOf("//");t.protocol=n.substring(0,r),r+=2;const a=e.indexOf("/",r),i=e.indexOf("?"),s=e.indexOf("#");-1!==s&&(n=n.substring(0,s));if(-1!==i){const e=n.substring(i);t.query=e,n=n.substring(0,i)}if(-1!==a){const e=n.substring(0,a);t.host=e,n=n.substring(a),t.path=n}else t.host=n;return t}(e),r=function(e){const t={href:e,hash:"",query:"",netPath:!1,absolutePath:!1,relativePath:!1};if(Fe.test(e))return t.netPath=!0,t;"/"===e[0]?t.absolutePath=!0:""!==e&&(t.relativePath=!0);let n=e;const r=e.indexOf("?"),a=e.indexOf("#");if(-1!==a){const e=n.substring(a);t.hash=e,n=n.substring(0,a)}if(-1!==r){const e=n.substring(r);t.query=e,n=n.substring(0,r)}return t.path=n,t}(t);if(!n.protocol&&!r.netPath)throw new Error("Error, protocol is not specified");if(r.netPath)return r.href.startsWith("//")&&(r.href=n.protocol+r.href),function(e){const t=e.indexOf("//")+2,n=!e.includes("/",t),r=!e.includes("?",t),a=!e.includes("#",t);return n&&r&&a}(r.href)?_e(r.href):r.href;if(r.absolutePath){const{path:e,query:t,hash:a}=r;return n.host+Je(e)+t+a}if(r.relativePath){const{path:e,query:t,hash:a}=r;let i,s=n.path,o=n.host;return 0===e.length?i=s:(s=s.substring(0,s.lastIndexOf("/")),i=Je(s+"/"+e)),o+=""!==i||t||a?i+t+a:"/",o}{const{host:e,path:t,query:a}=n;return t||a?e+t+a+r.hash:_e(e)}};function _e(e){return e+("/"===e[e.length-1]?"":"/")}function Je(e){let t=e.split("/");""===t[0]&&(t=t.slice(1));let n=[];return t.forEach(((e,r)=>{"."!==e&&(".."===e?n.pop():""===e&&r!==t.length-1||n.push(e))})),"/"+n.join("/")}const Fe=new RegExp("^([a-z][a-z0-9+.-]*:)?//","i");var ze=fetch;const{jsonTypeOf:Ue,splitUrl:Be}=ne,Ke={},Ge={},Xe=(e,t)=>{const n=e in Ge?Ge[e]:e;if(n in Ke)return Ke[n][t]},He={},We={},Ze=(e,t="",n="")=>{e=JSON.parse(JSON.stringify(e));const r=Be(e.$schema||n)[0];if(!r)throw Error("Couldn't determine schema version");delete e.$schema;const a=Xe(r,"baseToken"),i=Xe(r,"anchorToken"),s=Be(t)[0];if(!s&&!Be(e[a]||"")[0])throw Error("Couldn't determine an identifier for the schema");const o=rt(s,e[a]||""),[c,l]=Be(o);delete e[a],l&&a===i&&(e[i]=i!==a?encodeURI(l):"#"+encodeURI(l)),s&&(We[s]=c);const m={},u=Xe(r,"recursiveAnchorToken");let p;!0===e[u]&&(m["#"]=c,e[i]="",delete e[u]);const f=Xe(r,"vocabularyToken");Ue(e[f],"object")?(Ge[c]=r,p=e[f],delete e[f]):(Ge[c]=r,p={[r]:!0});const d={};He[c]={id:c,schemaVersion:r,schema:Qe(e,c,r,ee.nil,d,m),anchors:d,dynamicAnchors:m,vocabulary:p,validated:!1}},Qe=(e,t,n,r,a,i)=>{if(Ue(e,"object")){const s="string"==typeof e.$schema?Be(e.$schema)[0]:n,o=Xe(s,"embeddedToken"),c=Xe(s,"anchorToken");if("string"==typeof e[o]&&(o!==c||"#"!==e[o][0])){const r=rt(t,e[o]);return e[o]=r,Ze(e,r,n),se(e[o],e)}const l=Xe(n,"anchorToken"),m=Xe(n,"dynamicAnchorToken");"string"==typeof e[m]&&(i["#"+e[m]]=t,e[l]=e[m],delete e[m]);const u=Xe(n,"embeddedToken");if("string"==typeof e[l]){const t=l!==u?e[l]:e[l].slice(1);a[t]=r,delete e[l]}const p=Xe(n,"jrefToken");if("string"==typeof e[p])return se(e[p],e);for(let s in e)e[s]=Qe(e[s],t,n,ee.append(s,r),a,i);const f=Xe(n,"jsrefToken");"string"==typeof e[f]&&(e[f]=se(e[f],e[f]));const d=Xe(n,"dynamicJsrefToken");return"string"==typeof e[d]&&(e[d]=se(e[d],e[d],!0)),e}return Array.isArray(e)?e.map(((e,s)=>Qe(e,t,n,ee.append(s,r),a,i))):e},Ye=e=>He[We[e]]||He[e],et=Object.freeze({id:"",schemaVersion:void 0,pointer:"",schema:void 0,dynamicAnchors:{}}),tt=async(e,t=et,n=!1)=>{const r=n&&t.dynamicAnchors[e]?t.dynamicAnchors[e]:st(t),a=rt(r,e),[i,s]=Be(a);if(!(e=>e in He||e in We)(i)){const e=await ze(i,{headers:{Accept:"application/schema+json"}});if(e.status>=400)throw await e.text(),Error("Failed to retrieve schema with id: "+i);if(e.headers.has("content-type")){const t=ke.parse(e.headers.get("content-type")).type;if("application/schema+json"!==t)throw Error(`${i} is not a schema. Found a document with media type: ${t}`)}Ze(await e.json(),i)}const o=Ye(i),c=s&&"/"!==s[0]?it(o,s):s,l=Object.freeze({id:o.id,schemaVersion:o.schemaVersion,vocabulary:o.vocabulary,pointer:c,schema:o.schema,value:ee.get(c,o.schema),dynamicAnchors:{...o.dynamicAnchors,...t.dynamicAnchors},validated:o.validated});return nt(l)},nt=e=>oe(e.value)?tt(ce(e.value),e,me(e.value)):e,rt=(e,t)=>{const n=Le(e,t),r=Be(e)[0];if(r&&"file"===at(n)&&"file"!==at(r))throw Error(`Can't access file '${n}' resource from network context '${e}'`);return n},at=e=>{const t=e.match(/^(.+):\/\//);return t?t[1]:""},it=(e,t)=>{if(!(t in e.anchors))throw Error(`No such anchor '${encodeURI(e.id)}#${encodeURI(t)}'`);return e.anchors[t]},st=e=>`${e.id}#${encodeURI(e.pointer)}`,ot=e=>oe(e.value)?le(e.value):e.value,ct=(e,t)=>{const n=Ye(t.id),r=Object.freeze({id:t.id,schemaVersion:t.schemaVersion,vocabulary:t.vocabulary,pointer:ee.append(e,t.pointer),schema:n.schema,value:ot(t)[e],dynamicAnchors:t.dynamicAnchors,validated:n.validated});return nt(r)},lt=L(((e,t)=>Ve.pipeline([ot,Ve.map((async(n,r)=>e(await ct(r,t),r))),Ve.all],t)));var mt={setConfig:(e,t,n)=>{Ke[e]||(Ke[e]={}),Ke[e][t]=n},getConfig:Xe,add:Ze,get:tt,markValidated:e=>{He[e].validated=!0},uri:st,value:ot,typeOf:(e,t)=>Ue(ot(e),t),has:(e,t)=>e in ot(t),step:ct,keys:e=>Object.keys(ot(e)),entries:e=>Ve.pipeline([ot,Object.keys,Ve.map((async t=>[t,await ct(t,e)])),Ve.all],e),map:lt,length:e=>ot(e).length};class ut extends Error{constructor(e){super("Invalid Schema"),this.name=this.constructor.name,this.output=e}}var pt=ut;const ft="FLAG",dt="BASIC",ht="DETAILED",yt="VERBOSE";let vt=ht,gt=!0;const bt=async e=>{const t={};return{ast:t,schemaUri:await jt(e,t)}},$t=L((({ast:e,schemaUri:t},n,r=ft)=>{if(![ft,dt,ht,yt].includes(r))throw Error(`The '${r}' error format is not supported`);let a=[];const i=F.subscribe("result",Ot(r,a));return Pt(t,n,e),F.unsubscribe(i),a[0]})),Ot=(e,t)=>{const n=[];return(r,a)=>{if("result"===r){const{keyword:e,absoluteKeywordLocation:t,instanceLocation:r,valid:i}=a,s={keyword:e,absoluteKeywordLocation:t,instanceLocation:r,valid:i,errors:[]};n.push(s)}else if("result.start"===r)n.push(r);else if("result.end"===r){const r=n.pop();for(;"result.start"!==n[n.length-1];){const t=n.pop(),a=[t];e===dt&&(a.push(...t.errors),delete t.errors),(e===yt||e!==ft&&!t.valid)&&r.errors.unshift(...a)}n[n.length-1]=r,t[0]=r}}},It={},xt=e=>It[e],wt=e=>e in It,St={},Et={},jt=async(e,t)=>{if(!wt(e.schemaVersion+"#validate")){const t=await mt.get(e.schemaVersion);(mt.getConfig(t.id,"mandatoryVocabularies")||[]).forEach((e=>{if(!t.vocabulary[e])throw Error(`Vocabulary '${e}' must be explicitly declared and required`)})),Object.entries(t.vocabulary).forEach((([e,n])=>{if(e in St)Object.entries(St[e]).forEach((([e,n])=>{((e,t)=>{It[e]={collectEvaluatedItems:(e,n,r)=>t.interpret(e,n,r)&&0,collectEvaluatedProperties:(e,n,r)=>t.interpret(e,n,r)&&[],...t}})(`${t.id}#${e}`,n)}));else if(n)throw Error("Missing required vocabulary: "+e)}))}if(gt&&!e.validated){if(mt.markValidated(e.id),!(e.schemaVersion in Et)){const t=await mt.get(e.schemaVersion),n={},r=await jt(t,n);Et[t.id]=$t({ast:n,schemaUri:r})}const t=Oe.cons(e.schema,e.id),n=Et[e.schemaVersion](t,vt);if(!n.valid)throw new pt(n)}return await xt(e.schemaVersion+"#validate").compile(e,t),mt.uri(e)},Pt=(e,t,n)=>{const[r]=n[e];return xt(r).interpret(e,t,n)};var At={validate:async(e,t,n)=>{const r=await bt(e),a=(e,t=ft)=>$t(r,Oe.cons(e),t);return void 0===t?a:a(t,n)},compile:bt,interpret:$t,setMetaOutputFormat:e=>{vt=e},setShouldMetaValidate:e=>{gt=e},FLAG:ft,BASIC:dt,DETAILED:ht,VERBOSE:yt,getKeyword:xt,hasKeyword:wt,defineVocabulary:(e,t)=>{St[e]=t},compileSchema:jt,interpretSchema:Pt,collectEvaluatedProperties:(e,t,n,r)=>{const[a]=n[e];return xt(a).collectEvaluatedProperties(e,t,n,r)},collectEvaluatedItems:(e,t,n,r)=>{const[a]=n[e];return xt(a).collectEvaluatedItems(e,t,n,r)}};var kt={compile:e=>mt.value(e),interpret:()=>!0};var Tt={compile:async(e,t)=>{const n=mt.uri(e);if(!(n in t)){t[n]=!1;const r=mt.value(e);t[n]=[e.schemaVersion+"#validate",mt.uri(e),"boolean"==typeof r?r:await Ve.pipeline([mt.entries,Ve.map((([t,n])=>[`${e.schemaVersion}#${t}`,n])),Ve.filter((([t])=>At.hasKeyword(t)&&t!==e.schemaVersion+"#validate")),Ve.map((async([n,r])=>{const a=await At.getKeyword(n).compile(r,t,e);return[n,mt.uri(r),a]})),Ve.all],e)]}return n},interpret:(e,t,n)=>{const[r,a,i]=n[e];F.publishSync("result.start");const s="boolean"==typeof i?i:i.every((([e,r,a])=>{F.publishSync("result.start");const i=At.getKeyword(e).interpret(a,t,n);return F.publishSync("result",{keyword:e,absoluteKeywordLocation:r,instanceLocation:Oe.uri(t),valid:i,ast:a}),F.publishSync("result.end"),i}));return F.publishSync("result",{keyword:r,absoluteKeywordLocation:a,instanceLocation:Oe.uri(t),valid:s,ast:e}),F.publishSync("result.end"),s},collectEvaluatedProperties:(e,t,n,r=!1)=>{const a=n[e][2];return"boolean"==typeof a?!!a&&[]:a.filter((([e])=>!r||!e.endsWith("#unevaluatedProperties"))).reduce(((e,[r,,a])=>{const i=e&&At.getKeyword(r).collectEvaluatedProperties(a,t,n);return i&&e.concat(i)}),[])},collectEvaluatedItems:(e,t,n,r=!1)=>{const a=n[e][2];return"boolean"==typeof a?!!a&&[]:a.filter((([e])=>!r||!e.endsWith("#unevaluatedItems"))).reduce(((e,[r,,a])=>{const i=!1!==e&&At.getKeyword(r).collectEvaluatedItems(a,t,n);return!1!==i&&Math.max(e,i)}),0)}},Ct={Core:At,Schema:mt,Instance:Oe,Keywords:{metaData:kt,validate:Tt}};const{Core:Nt,Schema:Rt,Instance:qt}=Ct;var Mt={compile:async(e,t,n)=>{const r=await Rt.step("items",n),a=Rt.typeOf(r,"array")?Rt.length(r):Number.MAX_SAFE_INTEGER;return Rt.typeOf(e,"boolean")?[a,Rt.value(e)]:[a,await Nt.compileSchema(e,t)]},interpret:([e,t],n,r)=>!qt.typeOf(n,"array")||("string"==typeof t?qt.every(((n,a)=>a<e||Nt.interpretSchema(t,n,r)),n):qt.every(((n,r)=>r<e||t),n))};const{Core:Dt,Schema:Vt,Instance:Lt}=Ct,_t=([e,t],n,r)=>!Lt.typeOf(n,"array")||Lt.every(((n,a)=>a<e||Dt.interpretSchema(t,n,r)),n);var Jt={compile:async(e,t,n)=>{const r=await Vt.step("items",n);return[Vt.typeOf(r,"array")?Vt.length(r):Number.MAX_SAFE_INTEGER,await Dt.compileSchema(e,t)]},interpret:_t,collectEvaluatedItems:(e,t,n)=>_t(e,t,n)&&Number.MAX_SAFE_INTEGER};const{Core:Ft,Schema:zt,Instance:Ut}=Ct;var Bt={compile:async(e,t,n)=>{const r=await zt.step("properties",n),a=zt.typeOf(r,"object")?zt.keys(r):[],i=await zt.step("patternProperties",n),s=zt.typeOf(i,"object")?zt.keys(i).map((e=>new RegExp(e))):[];return zt.typeOf(e,"boolean")?[a,s,zt.value(e)]:[a,s,await Ft.compileSchema(e,t)]},interpret:([e,t,n],r,a)=>{if(!Ut.typeOf(r,"object"))return!0;const i=Ut.entries(r).filter((([n])=>!e.includes(n)&&!t.some((e=>e.test(n)))));return"string"==typeof n?i.every((([,e])=>Ft.interpretSchema(n,e,a))):0===i.length||n}};const{Core:Kt,Schema:Gt,Instance:Xt}=Ct,Ht=([e,t,n],r,a)=>!Xt.typeOf(r,"object")||Xt.entries(r).filter((([n])=>!e.includes(n)&&!t.some((e=>e.test(n))))).every((([,e])=>Kt.interpretSchema(n,e,a)));var Wt={compile:async(e,t,n)=>{const r=await Gt.step("properties",n),a=Gt.typeOf(r,"object")?Gt.keys(r):[],i=await Gt.step("patternProperties",n);return[a,Gt.typeOf(i,"object")?Gt.keys(i).map((e=>new RegExp(e))):[],await Kt.compileSchema(e,t)]},interpret:Ht,collectEvaluatedProperties:(e,t,n)=>Ht(e,t,n)&&[new RegExp("")]};const{Core:Zt,Schema:Qt}=Ct;var Yt={compile:(e,t)=>Ve.pipeline([Qt.map((async e=>Zt.compileSchema(await e,t))),Ve.all],e),interpret:(e,t,n)=>e.every((e=>Zt.interpretSchema(e,t,n))),collectEvaluatedProperties:(e,t,n)=>e.reduce(((e,r)=>{const a=e&&Zt.collectEvaluatedProperties(r,t,n);return a&&e.concat(a)}),[]),collectEvaluatedItems:(e,t,n)=>e.reduce(((e,r)=>{const a=!1!==e&&Zt.collectEvaluatedItems(r,t,n);return!1!==a&&Math.max(e,a)}),0)};const{Core:en,Schema:tn}=Ct;var nn={compile:(e,t)=>Ve.pipeline([tn.map((async e=>en.compileSchema(await e,t))),Ve.all],e),interpret:(e,t,n)=>e.filter((e=>en.interpretSchema(e,t,n))).length>0,collectEvaluatedProperties:(e,t,n)=>e.reduce(((e,r)=>{const a=en.collectEvaluatedProperties(r,t,n);return a?(e||[]).concat(a):e}),!1),collectEvaluatedItems:(e,t,n)=>e.reduce(((e,r)=>{const a=en.collectEvaluatedItems(r,t,n);return!1!==a?Math.max(e,a):e}),!1)},rn=Object.keys,an=JSON.stringify;function sn(e,t){var n,r,a,i,s,o,c;if("string"===(c=typeof e))return an(e);if(!0===e)return"true";if(!1===e)return"false";if(null===e)return"null";if(e instanceof Array){for(a="[",r=e.length-1,n=0;n<r;n++)a+=sn(e[n],!1)+",";return r>-1&&(a+=sn(e[n],!1)),a+"]"}if(e instanceof Object){if("function"==typeof e.toJSON)return sn(e.toJSON(),t);for(r=(i=rn(e).sort()).length,a="",n=0;n<r;)void 0!==(o=sn(e[s=i[n]],!0))&&(n&&""!==a&&(a+=","),a+=an(s)+":"+o),n++;return"{"+a+"}"}switch(c){case"function":case"undefined":return t?void 0:null;default:return isFinite(e)?e:null}}var on=function(e){return""+sn(e,!1)};const{Schema:cn,Instance:ln}=Ct;var mn={compile:e=>on(cn.value(e)),interpret:(e,t)=>on(ln.value(t))===e};const{Core:un,Instance:pn}=Ct;var fn={compile:(e,t)=>un.compileSchema(e,t),interpret:(e,t,n)=>!pn.typeOf(t,"array")||pn.some((t=>un.interpretSchema(e,t,n)),t)};const{Core:dn,Schema:hn,Instance:yn}=Ct;var vn={compile:async(e,t,n)=>{const r=await dn.compileSchema(e,t),a=await hn.step("minContains",n),i=hn.typeOf(a,"number")?hn.value(a):1,s=await hn.step("maxContains",n);return{contains:r,minContains:i,maxContains:hn.typeOf(s,"number")?hn.value(s):Number.MAX_SAFE_INTEGER}},interpret:({contains:e,minContains:t,maxContains:n},r,a)=>{if(!yn.typeOf(r,"array"))return!0;const i=yn.reduce(((t,n)=>dn.interpretSchema(e,n,a)?t+1:t),0,r);return i>=t&&i<=n}};const{Core:gn,Schema:bn}=Ct;var $n={compile:async(e,t)=>{await Ve.pipeline([bn.entries,Ve.map((([,e])=>gn.compileSchema(e,t))),Ve.all],e)},interpret:()=>!0};const{Core:On,Schema:In,Instance:xn}=Ct;var wn={compile:(e,t)=>Ve.pipeline([In.entries,Ve.map((async([e,n])=>[e,In.typeOf(n,"array")?In.value(n):await On.compileSchema(n,t)])),Ve.all],e),interpret:(e,t,n)=>{const r=xn.value(t);return!xn.typeOf(t,"object")||e.every((([e,a])=>!(e in r)||(Array.isArray(a)?a.every((e=>e in r)):On.interpretSchema(a,t,n))))}};const{Schema:Sn,Instance:En}=Ct;var jn={compile:e=>Ve.pipeline([Sn.entries,Ve.map((([e,t])=>[e,Sn.value(t)])),Ve.all],e),interpret:(e,t)=>{const n=En.value(t);return!En.typeOf(t,"object")||e.every((([e,t])=>!(e in n)||t.every((e=>e in n))))}};const{Core:Pn,Schema:An,Instance:kn}=Ct;var Tn={compile:(e,t)=>Ve.pipeline([An.entries,Ve.map((async([e,n])=>[e,await Pn.compileSchema(n,t)])),Ve.all],e),interpret:(e,t,n)=>{const r=kn.value(t);return!kn.typeOf(t,"object")||e.every((([e,a])=>!(e in r)||Pn.interpretSchema(a,t,n)))},collectEvaluatedProperties:(e,t,n)=>{const r=kn.value(t);return e.reduce(((e,[a,i])=>{if(!e||!(a in r))return e;const s=Pn.collectEvaluatedProperties(i,t,n);return s&&e.concat(s)}),[])}};const{Schema:Cn,Instance:Nn}=Ct;var Rn={compile:e=>Cn.value(e).map(on),interpret:(e,t)=>e.some((e=>on(Nn.value(t))===e))};const{Schema:qn,Instance:Mn}=Ct;var Dn={compile:async e=>qn.value(e),interpret:(e,t)=>!Mn.typeOf(t,"number")||Mn.value(t)<e};const{Schema:Vn,Instance:Ln}=Ct;var _n={compile:async e=>Vn.value(e),interpret:(e,t)=>!Ln.typeOf(t,"number")||Ln.value(t)>e};const{Core:Jn}=Ct;var Fn={compile:(e,t)=>Jn.compileSchema(e,t),interpret:(e,t,n)=>(Jn.interpretSchema(e,t,n),!0)};const{Core:zn,Schema:Un}=Ct,Bn=(e,t,n)=>{const r=n[e][2];return"boolean"==typeof r?r:r.every((([e,,r])=>zn.getKeyword(e).interpret(r,t,n)))};var Kn={compile:async(e,t,n)=>{if(Un.has("if",n)){const r=await Un.step("if",n);return[await zn.compileSchema(r,t),await zn.compileSchema(e,t)]}return[]},interpret:([e,t],n,r)=>void 0===e||!Bn(e,n,r)||zn.interpretSchema(t,n,r),collectEvaluatedProperties:([e,t],n,r)=>{if(void 0===e)return[];const a=zn.collectEvaluatedProperties(e,n,r);if(!1===a)return[];const i=zn.collectEvaluatedProperties(t,n,r);return!1!==i&&a.concat(i)},collectEvaluatedItems:([e,t],n,r)=>void 0!==e&&zn.interpretSchema(e,n,r)?Math.max(zn.collectEvaluatedItems(e,n,r),zn.collectEvaluatedItems(t,n,r)):0};const{Core:Gn,Schema:Xn}=Ct,Hn=(e,t,n)=>{const r=n[e][2];return"boolean"==typeof r?r:r.every((([e,,r])=>Gn.getKeyword(e).interpret(r,t,n)))};var Wn={compile:async(e,t,n)=>{if(Xn.has("if",n)){const r=await Xn.step("if",n);return[await Gn.compileSchema(r,t),await Gn.compileSchema(e,t)]}return[]},interpret:([e,t],n,r)=>void 0===e||Hn(e,n,r)||Gn.interpretSchema(t,n,r),collectEvaluatedProperties:([e,t],n,r)=>void 0===e||!1!==Gn.collectEvaluatedProperties(e,n,r)?[]:Gn.collectEvaluatedProperties(t,n,r),collectEvaluatedItems:([e,t],n,r)=>void 0===e||Gn.interpretSchema(e,n,r)?0:Gn.collectEvaluatedItems(t,n,r)};const{Core:Zn,Schema:Qn,Instance:Yn}=Ct,er=(e,t,n)=>!Yn.typeOf(t,"array")||("string"==typeof e?Yn.every((t=>Zn.interpretSchema(e,t,n)),t):Yn.every(((t,r)=>!(r in e)||Zn.interpretSchema(e[r],t,n)),t));var tr={compile:(e,t)=>Qn.typeOf(e,"array")?Ve.pipeline([Qn.map((e=>Zn.compileSchema(e,t))),Ve.all],e):Zn.compileSchema(e,t),interpret:er,collectEvaluatedItems:(e,t,n)=>er(e,t,n)&&("string"==typeof e?Number.MAX_SAFE_INTEGER:e.length)};const{Core:nr,Schema:rr,Instance:ar}=Ct,ir=([e,t],n,r)=>!ar.typeOf(n,"array")||ar.every(((n,a)=>a<e||nr.interpretSchema(t,n,r)),n);var sr={compile:async(e,t,n)=>{const r=await rr.step("prefixItems",n);return[rr.typeOf(r,"array")?rr.length(r):0,await nr.compileSchema(e,t)]},interpret:ir,collectEvaluatedItems:(e,t,n)=>ir(e,t,n)&&Number.MAX_SAFE_INTEGER};const{Schema:or,Instance:cr}=Ct;var lr={compile:e=>or.value(e),interpret:(e,t)=>!cr.typeOf(t,"array")||cr.length(t)<=e};const{Schema:mr,Instance:ur}=Ct;var pr={compile:e=>mr.value(e),interpret:(e,t)=>!ur.typeOf(t,"string")||ur.length(t)<=e};const{Schema:fr,Instance:dr}=Ct;var hr={compile:e=>fr.value(e),interpret:(e,t)=>!dr.typeOf(t,"string")||[...dr.value(t)].length<=e};const{Schema:yr,Instance:vr}=Ct;var gr={compile:e=>yr.value(e),interpret:(e,t)=>!vr.typeOf(t,"object")||vr.keys(t).length<=e};const{Schema:br,Instance:$r}=Ct;var Or={compile:async(e,t,n)=>{const r=await br.step("exclusiveMaximum",n),a=br.value(r);return[br.value(e),a]},interpret:([e,t],n)=>{if(!$r.typeOf(n,"number"))return!0;const r=$r.value(n);return t?r<e:r<=e}};const{Schema:Ir,Instance:xr}=Ct;var wr={compile:async e=>Ir.value(e),interpret:(e,t)=>!xr.typeOf(t,"number")||xr.value(t)<=e};const{Schema:Sr,Instance:Er}=Ct;var jr={compile:e=>Sr.value(e),interpret:(e,t)=>!Er.typeOf(t,"array")||Er.length(t)>=e};const{Schema:Pr,Instance:Ar}=Ct;var kr={compile:e=>Pr.value(e),interpret:(e,t)=>!Ar.typeOf(t,"string")||Ar.value(t).length>=e};const{Schema:Tr,Instance:Cr}=Ct;var Nr={compile:e=>Tr.value(e),interpret:(e,t)=>!Cr.typeOf(t,"string")||[...Cr.value(t)].length>=e};const{Schema:Rr,Instance:qr}=Ct;var Mr={compile:e=>Rr.value(e),interpret:(e,t)=>{const n=qr.value(t);return!qr.typeOf(t,"object")||Object.keys(n).length>=e}};const{Schema:Dr,Instance:Vr}=Ct;var Lr={compile:async(e,t,n)=>{const r=await Dr.step("exclusiveMinimum",n),a=Dr.value(r);return[Dr.value(e),a]},interpret:([e,t],n)=>{if(!Vr.typeOf(n,"number"))return!0;const r=Vr.value(n);return t?r>e:r>=e}};const{Schema:_r,Instance:Jr}=Ct;var Fr={compile:async e=>_r.value(e),interpret:(e,t)=>!Jr.typeOf(t,"number")||Jr.value(t)>=e};const{Schema:zr,Instance:Ur}=Ct,Br=(e,t)=>Math.abs(e-t)<1.1920929e-7;var Kr={compile:e=>zr.value(e),interpret:(e,t)=>{if(!Ur.typeOf(t,"number"))return!0;const n=Ur.value(t)%e;return Br(0,n)||Br(e,n)}};const{Core:Gr}=Ct;var Xr={compile:Gr.compileSchema,interpret:(e,t,n)=>!Gr.interpretSchema(e,t,n)};const{Core:Hr,Schema:Wr}=Ct;var Zr={compile:(e,t)=>Ve.pipeline([Wr.map((async e=>Hr.compileSchema(await e,t))),Ve.all],e),interpret:(e,t,n)=>{let r=0;for(const a of e)if(Hr.interpretSchema(a,t,n)&&r++,r>1)break;return 1===r},collectEvaluatedProperties:(e,t,n)=>{let r=0;return e.reduce(((e,a)=>{if(r>1)return!1;const i=Hr.collectEvaluatedProperties(a,t,n);return i?0==r++&&i:e}),!1)},collectEvaluatedItems:(e,t,n)=>{let r=0;return e.reduce(((e,a)=>{if(r>1)return!1;const i=Hr.collectEvaluatedItems(a,t,n);return"number"==typeof i?0==r++&&i:e}),!1)}};const{Schema:Qr,Instance:Yr}=Ct;var ea={compile:e=>new RegExp(Qr.value(e),"u"),interpret:(e,t)=>!Yr.typeOf(t,"string")||e.test(Yr.value(t))};const{Core:ta,Schema:na,Instance:ra}=Ct,aa=(e,t,n)=>!ra.typeOf(t,"object")||e.every((([e,r])=>ra.entries(t).filter((([t])=>e.test(t))).every((([,e])=>ta.interpretSchema(r,e,n)))));var ia={compile:(e,t)=>Ve.pipeline([na.entries,Ve.map((async([e,n])=>[new RegExp(e,"u"),await ta.compileSchema(n,t)])),Ve.all],e),interpret:aa,collectEvaluatedProperties:(e,t,n)=>aa(e,t,n)&&e.map((([e])=>e))};var sa={isObject:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,escapeRegExp:e=>e.replace(/[.*+\-?^${}()|[\]\\]/g,"\\$&")};const{Core:oa,Schema:ca,Instance:la}=Ct,{escapeRegExp:ma}=sa,ua=(e,t,n)=>!la.typeOf(t,"object")||la.entries(t).filter((([t])=>t in e)).every((([t,r])=>oa.interpretSchema(e[t],r,n)));var pa={compile:(e,t)=>Ve.pipeline([ca.entries,Ve.reduce((async(e,[n,r])=>(e[n]=await oa.compileSchema(r,t),e)),Object.create(null))],e),interpret:ua,collectEvaluatedProperties:(e,t,n)=>ua(e,t,n)&&Object.keys(e).map((e=>new RegExp(`^${ma(e)}$`)))};const{Core:fa,Instance:da}=Ct;var ha={compile:(e,t)=>fa.compileSchema(e,t),interpret:(e,t,n)=>!da.typeOf(t,"object")||da.keys(t).every((t=>fa.interpretSchema(e,da.cons(t),n)))};const{Core:ya}=Ct;var va={compile:ya.compileSchema,interpret:ya.interpretSchema,collectEvaluatedProperties:ya.collectEvaluatedProperties,collectEvaluatedItems:ya.collectEvaluatedItems};const{Core:ga}=Ct;var ba={compile:ga.compileSchema,interpret:ga.interpretSchema,collectEvaluatedProperties:ga.collectEvaluatedProperties,collectEvaluatedItems:ga.collectEvaluatedItems};const{Schema:$a,Instance:Oa}=Ct;var Ia={compile:e=>$a.value(e),interpret:(e,t)=>!Oa.typeOf(t,"object")||e.every((e=>Oa.value(t).hasOwnProperty(e)))};const{Core:xa,Schema:wa,Instance:Sa}=Ct,Ea=(e,t,n)=>!Sa.typeOf(t,"array")||Sa.every(((t,r)=>!(r in e)||xa.interpretSchema(e[r],t,n)),t);var ja={compile:(e,t)=>Ve.pipeline([wa.map((e=>xa.compileSchema(e,t))),Ve.all],e),interpret:Ea,collectEvaluatedItems:(e,t,n)=>Ea(e,t,n)&&e.length};const{Schema:Pa,Instance:Aa}=Ct;var ka={compile:e=>Pa.value(e),interpret:(e,t)=>"string"==typeof e?Aa.typeOf(t,e):e.some(Aa.typeOf(t))};const{Core:Ta,Schema:Ca,Instance:Na}=Ct,Ra=([e,t],n,r)=>{if(!Na.typeOf(n,"array"))return!0;const a=Ta.collectEvaluatedItems(e,n,r,!0);return!1===a||Na.filter(((e,t)=>t>=a),n).every((e=>Ta.interpretSchema(t,e,r)))};var qa={compile:async(e,t,n)=>[Ca.uri(n),await Ta.compileSchema(e,t)],interpret:Ra,collectEvaluatedItems:(e,t,n)=>Ra(e,t,n)&&Number.MAX_SAFE_INTEGER};const{Core:Ma,Schema:Da,Instance:Va}=Ct,La=([e,t],n,r)=>{if(!Va.typeOf(n,"object"))return!0;const a=Ma.collectEvaluatedProperties(e,n,r,!0);return!a||Va.entries(n).filter((([e])=>!a.some((t=>e.match(t))))).every((([,e])=>Ma.interpretSchema(t,e,r)))};var _a={compile:async(e,t,n)=>[Da.uri(n),await Ma.compileSchema(e,t)],interpret:La,collectEvaluatedProperties:(e,t,n)=>La(e,t,n)&&[new RegExp("")]};const{Schema:Ja,Instance:Fa}=Ct;var za={compile:e=>Ja.value(e),interpret:(e,t)=>{if(!Fa.typeOf(t,"array")||!1===e)return!0;const n=Fa.map((e=>on(Fa.value(e))),t);return new Set(n).size===n.length}};const{Keywords:Ua}=Ct;var Ba={additionalItems:Mt,additionalItems6:Jt,additionalProperties:Bt,additionalProperties6:Wt,allOf:Yt,anyOf:nn,const:mn,contains:fn,containsMinContainsMaxContains:vn,definitions:$n,dependencies:wn,dependentRequired:jn,dependentSchemas:Tn,enum:Rn,exclusiveMaximum:Dn,exclusiveMinimum:_n,if:Fn,then:Kn,else:Wn,items:tr,itemsFUTURE:sr,maxItems:lr,maxLength:pr,maxLength6:hr,maxProperties:gr,maximumExclusiveMaximum:Or,maximum:wr,metaData:Ua.metaData,minItems:jr,minLength:kr,minLength6:Nr,minProperties:Mr,minimumExclusiveMinimum:Lr,minimum:Fr,multipleOf:Kr,not:Xr,oneOf:Zr,pattern:ea,patternProperties:ia,properties:pa,propertyNames:ha,dynamicRef:va,ref:ba,required:Ia,tupleItems:ja,type:ka,unevaluatedItems:qa,unevaluatedProperties:_a,uniqueItems:za,validate:Ua.validate};const{Core:Ka,Schema:Ga}=Ct,Xa="http://json-schema.org/draft-04/schema";Ga.setConfig(Xa,"baseToken","id"),Ga.setConfig(Xa,"embeddedToken","id"),Ga.setConfig(Xa,"anchorToken","id"),Ga.setConfig(Xa,"jrefToken","$ref"),Ga.add(JSON.parse('{\n    "id": "http://json-schema.org/draft-04/schema#",\n    "$schema": "http://json-schema.org/draft-04/schema#",\n    "description": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "positiveInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "positiveIntegerDefault0": {\n            "allOf": [ { "$ref": "#/definitions/positiveInteger" }, { "default": 0 } ]\n        },\n        "simpleTypes": {\n            "enum": [ "array", "boolean", "integer", "null", "number", "object", "string" ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "minItems": 1,\n            "uniqueItems": true\n        }\n    },\n    "type": "object",\n    "properties": {\n        "id": {\n            "type": "string"\n        },\n        "$schema": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "multipleOf": {\n            "type": "number",\n            "minimum": 0,\n            "exclusiveMinimum": true\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "boolean",\n            "default": false\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxLength": { "$ref": "#/definitions/positiveInteger" },\n        "minLength": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/positiveInteger" },\n        "minItems": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxProperties": { "$ref": "#/definitions/positiveInteger" },\n        "minProperties": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "dependencies": {\n        "exclusiveMaximum": [ "maximum" ],\n        "exclusiveMinimum": [ "minimum" ]\n    },\n    "default": {}\n}')),Ka.defineVocabulary(Xa,{validate:Ba.validate,additionalItems:Ba.additionalItems,additionalProperties:Ba.additionalProperties,allOf:Ba.allOf,anyOf:Ba.anyOf,default:Ba.metaData,definitions:Ba.definitions,dependencies:Ba.dependencies,description:Ba.metaData,enum:Ba.enum,format:Ba.metaData,items:Ba.items,maxItems:Ba.maxItems,maxLength:Ba.maxLength,maxProperties:Ba.maxProperties,maximum:Ba.maximumExclusiveMaximum,minItems:Ba.minItems,minLength:Ba.minLength,minProperties:Ba.minProperties,minimum:Ba.minimumExclusiveMinimum,multipleOf:Ba.multipleOf,not:Ba.not,oneOf:Ba.oneOf,pattern:Ba.pattern,patternProperties:Ba.patternProperties,properties:Ba.properties,required:Ba.required,title:Ba.metaData,type:Ba.type,uniqueItems:Ba.uniqueItems});const Ha="http://json-schema.org/draft-04/hyper-schema";Ga.setConfig(Ha,"baseToken","id"),Ga.setConfig(Ha,"embeddedToken","id"),Ga.setConfig(Ha,"anchorToken","id"),Ga.setConfig(Ha,"jrefToken","$ref"),Ga.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-04/hyper-schema#",\n    "id": "http://json-schema.org/draft-04/hyper-schema#",\n    "title": "JSON Hyper-Schema",\n    "allOf": [\n        {"$ref": "http://json-schema.org/draft-04/schema#"}\n    ],\n    "properties": {\n        "additionalItems": {\n            "anyOf": [\n                {"type": "boolean"},\n                {"$ref": "#"}\n            ]\n        },\n        "additionalProperties": {\n            "anyOf": [\n                {"type": "boolean"},\n                {"$ref": "#"}\n            ]\n        },\n        "dependencies": {\n            "additionalProperties": {\n                "anyOf": [\n                    {"$ref": "#"},\n                    {"type": "array"}\n                ]\n            }\n        },\n        "items": {\n            "anyOf": [\n                {"$ref": "#"},\n                {"$ref": "#/definitions/schemaArray"}\n            ]\n        },\n        "definitions": {\n            "additionalProperties": {"$ref": "#"}\n        },\n        "patternProperties": {\n            "additionalProperties": {"$ref": "#"}\n        },\n        "properties": {\n            "additionalProperties": {"$ref": "#"}\n        },\n        "allOf": {"$ref": "#/definitions/schemaArray"},\n        "anyOf": {"$ref": "#/definitions/schemaArray"},\n        "oneOf": {"$ref": "#/definitions/schemaArray"},\n        "not": { "$ref": "#" },\n\n        "links": {\n            "type": "array",\n            "items": {"$ref": "#/definitions/linkDescription"}\n        },\n        "fragmentResolution": {\n            "type": "string"\n        },\n        "media": {\n            "type": "object",\n            "properties": {\n                "type": {\n                    "description": "A media type, as described in RFC 2046",\n                    "type": "string"\n                },\n                "binaryEncoding": {\n                    "description": "A content encoding scheme, as described in RFC 2045",\n                    "type": "string"\n                }\n            }\n        },\n        "pathStart": {\n            "description": "Instances\' URIs must start with this value for this schema to apply to them",\n            "type": "string",\n            "format": "uri"\n        }\n    },\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "items": {"$ref": "#"}\n        },\n        "linkDescription": {\n            "title": "Link Description Object",\n            "type": "object",\n            "required": ["href", "rel"],\n            "properties": {\n                "href": {\n                    "description": "a URI template, as defined by RFC 6570, with the addition of the $, ( and ) characters for pre-processing",\n                    "type": "string"\n                },\n                "rel": {\n                    "description": "relation to the target resource of the link",\n                    "type": "string"\n                },\n                "title": {\n                    "description": "a title for the link",\n                    "type": "string"\n                },\n                "targetSchema": {\n                    "description": "JSON Schema describing the link target",\n                    "$ref": "#"\n                },\n                "mediaType": {\n                    "description": "media type (as defined by RFC 2046) describing the link target",\n                    "type": "string"\n                },\n                "method": {\n                    "description": "method for requesting the target of the link (e.g. for HTTP this might be \\"GET\\" or \\"DELETE\\")",\n                    "type": "string"\n                },\n                "encType": {\n                    "description": "The media type in which to submit data along with the request",\n                    "type": "string",\n                    "default": "application/json"\n                },\n                "schema": {\n                    "description": "Schema describing the data to submit along with the request",\n                    "$ref": "#"\n                }\n            }\n        },\n        "readOnly": {\n            "description": "If true, indicates that the value of this property is controlled by the server.",\n            "type": "boolean",\n            "default": false\n        }\n    },\n    "links": [\n        {\n            "rel": "self",\n            "href": "{+id}"\n        },\n        {\n            "rel": "full",\n            "href": "{+($ref)}"\n        }\n    ]\n}')),Ka.defineVocabulary(Ha,{validate:Ba.validate,additionalItems:Ba.additionalItems,additionalProperties:Ba.additionalProperties,allOf:Ba.allOf,anyOf:Ba.anyOf,default:Ba.metaData,definitions:Ba.definitions,dependencies:Ba.dependencies,description:Ba.metaData,enum:Ba.enum,format:Ba.metaData,fragmentResolution:Ba.metaData,items:Ba.items,maxItems:Ba.maxItems,minProperties:Ba.minProperties,maxProperties:Ba.maxProperties,maximum:Ba.maximumExclusiveMaximum,media:Ba.metaData,minItems:Ba.minItems,minLength:Ba.minLength,maxLength:Ba.maxLength,minimum:Ba.minimumExclusiveMinimum,multipleOf:Ba.multipleOf,links:Ba.metaData,not:Ba.not,oneOf:Ba.oneOf,pathStart:Ba.metaData,pattern:Ba.pattern,patternProperties:Ba.patternProperties,properties:Ba.properties,readOnly:Ba.metaData,required:Ba.required,title:Ba.metaData,type:Ba.type,uniqueItems:Ba.uniqueItems});const{Core:Wa,Schema:Za}=Ct,Qa="http://json-schema.org/draft-06/schema";Za.setConfig(Qa,"baseToken","$id"),Za.setConfig(Qa,"embeddedToken","$id"),Za.setConfig(Qa,"anchorToken","$id"),Za.setConfig(Qa,"jrefToken","$ref"),Za.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-06/schema#",\n    "$id": "http://json-schema.org/draft-06/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "examples": {\n            "type": "array",\n            "items": {}\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": {},\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": {}\n}')),Wa.defineVocabulary(Qa,{validate:Ba.validate,additionalItems:Ba.additionalItems6,additionalProperties:Ba.additionalProperties6,allOf:Ba.allOf,anyOf:Ba.anyOf,const:Ba.const,contains:Ba.contains,default:Ba.metaData,definitions:Ba.definitions,dependencies:Ba.dependencies,description:Ba.metaData,enum:Ba.enum,examples:Ba.metaData,exclusiveMaximum:Ba.exclusiveMaximum,exclusiveMinimum:Ba.exclusiveMinimum,format:Ba.metaData,items:Ba.items,maxItems:Ba.maxItems,maxLength:Ba.maxLength6,maxProperties:Ba.maxProperties,maximum:Ba.maximum,minItems:Ba.minItems,minLength:Ba.minLength6,minProperties:Ba.minProperties,minimum:Ba.minimum,multipleOf:Ba.multipleOf,not:Ba.not,oneOf:Ba.oneOf,pattern:Ba.pattern,patternProperties:Ba.patternProperties,properties:Ba.properties,propertyNames:Ba.propertyNames,required:Ba.required,title:Ba.metaData,type:Ba.type,uniqueItems:Ba.uniqueItems});const{Core:Ya,Schema:ei}=Ct,ti="http://json-schema.org/draft-07/schema";ei.setConfig(ti,"baseToken","$id"),ei.setConfig(ti,"embeddedToken","$id"),ei.setConfig(ti,"anchorToken","$id"),ei.setConfig(ti,"jrefToken","$ref"),ei.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-07/schema#",\n    "$id": "http://json-schema.org/draft-07/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": true\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true,\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "if": { "$ref": "#" },\n        "then": { "$ref": "#" },\n        "else": { "$ref": "#" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": true\n}')),Ya.defineVocabulary(ti,{validate:Ba.validate,additionalItems:Ba.additionalItems6,additionalProperties:Ba.additionalProperties6,allOf:Ba.allOf,anyOf:Ba.anyOf,const:Ba.const,contains:Ba.contains,default:Ba.metaData,definitions:Ba.definitions,dependencies:Ba.dependencies,description:Ba.metaData,enum:Ba.enum,exclusiveMaximum:Ba.exclusiveMaximum,exclusiveMinimum:Ba.exclusiveMinimum,format:Ba.metaData,if:Ba.if,then:Ba.then,else:Ba.else,items:Ba.items,maxItems:Ba.maxItems,maxLength:Ba.maxLength6,maxProperties:Ba.maxProperties,maximum:Ba.maximum,minItems:Ba.minItems,minLength:Ba.minLength6,minProperties:Ba.minProperties,minimum:Ba.minimum,multipleOf:Ba.multipleOf,not:Ba.not,oneOf:Ba.oneOf,pattern:Ba.pattern,patternProperties:Ba.patternProperties,properties:Ba.properties,propertyNames:Ba.propertyNames,readOnly:Ba.metaData,required:Ba.required,title:Ba.metaData,type:Ba.type,uniqueItems:Ba.uniqueItems,writeOnly:Ba.metaData});const{Core:ni,Schema:ri}=Ct,ai="https://json-schema.org/draft/2019-09/schema";ri.setConfig(ai,"baseToken","$id"),ri.setConfig(ai,"embeddedToken","$id"),ri.setConfig(ai,"anchorToken","$anchor"),ri.setConfig(ai,"jsrefToken","$ref"),ri.setConfig(ai,"dynamicJsrefToken","$recursiveRef"),ri.setConfig(ai,"recursiveAnchorToken","$recursiveAnchor"),ri.setConfig(ai,"commentToken","$comment"),ri.setConfig(ai,"vocabularyToken","$vocabulary"),ri.setConfig(ai,"mandatoryVocabularies",["https://json-schema.org/draft/2019-09/vocab/core"]),ri.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$id": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/core": true,\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true,\n        "https://json-schema.org/draft/2019-09/vocab/validation": true,\n        "https://json-schema.org/draft/2019-09/vocab/meta-data": true,\n        "https://json-schema.org/draft/2019-09/vocab/format": false,\n        "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$recursiveRef": "#" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),ri.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/core",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/core": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z][-A-Za-z0-9.:_]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveAnchor": {\n            "type": "boolean",\n            "default": false\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        }\n    }\n}')),ni.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/core",{validate:Ba.validate,$defs:Ba.definitions,$recursiveRef:Ba.dynamicRef,$ref:Ba.ref}),ri.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/applicator",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/applicator": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Applicator vocabulary meta-schema",\n    "properties": {\n        "additionalItems": { "$recursiveRef": "#" },\n        "unevaluatedItems": { "$recursiveRef": "#" },\n        "items": {\n            "anyOf": [\n                { "$recursiveRef": "#" },\n                { "$ref": "#/$defs/schemaArray" }\n            ]\n        },\n        "contains": { "$recursiveRef": "#" },\n        "additionalProperties": { "$recursiveRef": "#" },\n        "unevaluatedProperties": { "$recursiveRef": "#" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$recursiveRef": "#"\n            }\n        },\n        "propertyNames": { "$recursiveRef": "#" },\n        "if": { "$recursiveRef": "#" },\n        "then": { "$recursiveRef": "#" },\n        "else": { "$recursiveRef": "#" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$recursiveRef": "#" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$recursiveRef": "#" }\n        }\n    }\n}')),ni.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/applicator",{additionalItems:Ba.additionalItems6,additionalProperties:Ba.additionalProperties6,allOf:Ba.allOf,anyOf:Ba.anyOf,contains:Ba.containsMinContainsMaxContains,dependentSchemas:Ba.dependentSchemas,if:Ba.if,then:Ba.then,else:Ba.else,items:Ba.items,not:Ba.not,oneOf:Ba.oneOf,patternProperties:Ba.patternProperties,properties:Ba.properties,propertyNames:Ba.propertyNames,unevaluatedItems:Ba.unevaluatedItems,unevaluatedProperties:Ba.unevaluatedProperties}),ri.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/validation",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/validation": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": ["number", "boolean"]\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": ["number", "boolean"]\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "allOf": [\n        {\n            "if": {\n                "properties": {\n                    "exclusiveMinimum": { "type": "boolean" }\n                },\n                "required": ["exclusiveMinimum"]\n            },\n            "then": {\n                "required": ["minimum"]\n            }\n        },\n        {\n            "if": {\n                "properties": {\n                    "exclusiveMaximum": { "type": "boolean" }\n                },\n                "required": ["exclusiveMaximum"]\n            },\n            "then": {\n                "required": ["maximum"]\n            }\n        }\n    ],\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),ni.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/validation",{const:Ba.const,dependentRequired:Ba.dependentRequired,enum:Ba.enum,exclusiveMaximum:Ba.exclusiveMaximum,exclusiveMinimum:Ba.exclusiveMinimum,maxItems:Ba.maxItems,maxLength:Ba.maxLength6,maxProperties:Ba.maxProperties,maximum:Ba.maximum,minItems:Ba.minItems,minLength:Ba.minLength6,minProperties:Ba.minProperties,minimum:Ba.minimum,multipleOf:Ba.multipleOf,pattern:Ba.pattern,required:Ba.required,type:Ba.type,uniqueItems:Ba.uniqueItems}),ri.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/meta-data": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),ni.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/meta-data",{default:Ba.metaData,deprecated:Ba.metaData,description:Ba.metaData,examples:Ba.metaData,readOnly:Ba.metaData,title:Ba.metaData,writeOnly:Ba.metaData}),ri.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/format",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/format": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Format vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),ri.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/content",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$recursiveRef": "#" }\n    }\n}')),ni.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/content",{contentEncoding:Ba.metaData,contentMediaType:Ba.metaData,contentSchema:Ba.metaData});const{Core:ii,Schema:si}=Ct,oi="https://json-schema.org/draft/future/schema";si.setConfig(oi,"baseToken","$id"),si.setConfig(oi,"embeddedToken","$id"),si.setConfig(oi,"anchorToken","$anchor"),si.setConfig(oi,"jsrefToken","$ref"),si.setConfig(oi,"dynamicJsrefToken","$dynamicRef"),si.setConfig(oi,"dynamicAnchorToken","$dynamicAnchor"),si.setConfig(oi,"commentToken","$comment"),si.setConfig(oi,"vocabularyToken","$vocabulary"),si.setConfig(oi,"mandatoryVocabularies",["https://json-schema.org/draft/future/vocab/core"]),si.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$id": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/future/vocab/core": true,\n        "https://json-schema.org/draft/future/vocab/applicator": true,\n        "https://json-schema.org/draft/future/vocab/validation": true,\n        "https://json-schema.org/draft/future/vocab/meta-data": true,\n        "https://json-schema.org/draft/future/vocab/format": false,\n        "https://json-schema.org/draft/future/vocab/content": true\n    },\n    "$dynamicAnchor": "schema",\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$dynamicRef": "#" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),si.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/core",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/future/vocab/core": true\n    },\n    "$dynamicAnchor": "schema",\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z][-A-Za-z0-9.:_]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$dynamicRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recusriveAnchor": {\n            "type": "boolean",\n            "const": true,\n            "default": false\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$dynmaicRef": "#schema" },\n            "default": {}\n        }\n    }\n}')),ii.defineVocabulary("https://json-schema.org/draft/future/vocab/core",{validate:Ba.validate,$defs:Ba.definitions,$dynamicRef:Ba.dynamicRef,$ref:Ba.ref}),si.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/applicator",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/future/vocab/applicator": true\n    },\n    "$dynamicAnchor": "schema",\n\n    "title": "Applicator vocabulary meta-schema",\n    "properties": {\n        "items": { "$dynamicRef": "#schema" },\n        "unevaluatedItems": { "$dynamicRef": "#schema" },\n        "prefixItems": { "$ref": "#/$defs/schemaArray" },\n        "contains": { "$dynamicRef": "#schema" },\n        "additionalProperties": { "$dynamicRef": "#schema" },\n        "unevaluatedProperties": { "$dynamicRef": "#schema" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#schema" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#schema" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$dynamicRef": "#schema"\n            }\n        },\n        "propertyNames": { "$dynamicRef": "#schema" },\n        "if": { "$dynamicRef": "#schema" },\n        "then": { "$dynamicRef": "#schema" },\n        "else": { "$dynamicRef": "#schema" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$dynamicRef": "#schema" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$dynamicRef": "#schema" }\n        }\n    }\n}')),ii.defineVocabulary("https://json-schema.org/draft/future/vocab/applicator",{additionalProperties:Ba.additionalProperties6,allOf:Ba.allOf,anyOf:Ba.anyOf,contains:Ba.containsMinContainsMaxContains,dependentSchemas:Ba.dependentSchemas,if:Ba.if,then:Ba.then,else:Ba.else,items:Ba.itemsFUTURE,not:Ba.not,oneOf:Ba.oneOf,patternProperties:Ba.patternProperties,prefixItems:Ba.tupleItems,properties:Ba.properties,propertyNames:Ba.propertyNames,unevaluatedItems:Ba.unevaluatedItems,unevaluatedProperties:Ba.unevaluatedProperties}),si.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/validation",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/future/vocab/validation": true\n    },\n    "$dynamicAnchor": "schema",\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": ["number", "boolean"]\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": ["number", "boolean"]\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "allOf": [\n        {\n            "if": {\n                "properties": {\n                    "exclusiveMinimum": { "type": "boolean" }\n                },\n                "required": ["exclusiveMinimum"]\n            },\n            "then": {\n                "required": ["minimum"]\n            }\n        },\n        {\n            "if": {\n                "properties": {\n                    "exclusiveMaximum": { "type": "boolean" }\n                },\n                "required": ["exclusiveMaximum"]\n            },\n            "then": {\n                "required": ["maximum"]\n            }\n        }\n    ],\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),ii.defineVocabulary("https://json-schema.org/draft/future/vocab/validation",{const:Ba.const,dependentRequired:Ba.dependentRequired,enum:Ba.enum,exclusiveMaximum:Ba.exclusiveMaximum,exclusiveMinimum:Ba.exclusiveMinimum,maxItems:Ba.maxItems,maxLength:Ba.maxLength6,maxProperties:Ba.maxProperties,maximum:Ba.maximum,minItems:Ba.minItems,minLength:Ba.minLength6,minProperties:Ba.minProperties,minimum:Ba.minimum,multipleOf:Ba.multipleOf,pattern:Ba.pattern,required:Ba.required,type:Ba.type,uniqueItems:Ba.uniqueItems}),si.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/future/vocab/meta-data": true\n    },\n    "$dynamicAnchor": "schema",\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),ii.defineVocabulary("https://json-schema.org/draft/future/vocab/meta-data",{default:Ba.metaData,deprecated:Ba.metaData,description:Ba.metaData,examples:Ba.metaData,readOnly:Ba.metaData,title:Ba.metaData,writeOnly:Ba.metaData}),si.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/format",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/future/vocab/format": true\n    },\n    "$dynamicAnchor": "schema",\n\n    "title": "Format vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),si.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/content",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/future/vocab/content": true\n    },\n    "$dynamicAnchor": "schema",\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$dynamicRef": "#schema" }\n    }\n}')),ii.defineVocabulary("https://json-schema.org/draft/future/vocab/content",{contentEncoding:Ba.metaData,contentMediaType:Ba.metaData,contentSchema:Ba.metaData});const{Core:ci,Schema:li}=Ct;var mi={add:li.add,get:li.get,validate:ci.validate,compile:ci.compile,interpret:ci.interpret,setMetaOutputFormat:ci.setMetaOutputFormat,setShouldMetaValidate:ci.setShouldMetaValidate,FLAG:ci.FLAG,BASIC:ci.BASIC,DETAILED:ci.DETAILED,VERBOSE:ci.VERBOSE,Keywords:Ba};const ui='(?:\\\\["\\/\\\\brfnt]|\\\\u[0-9a-fA-F]{4}|[^"\\\\])',pi=`"${ui}*"`,fi=`"${ui}*"(?=\\s*:)`;var di=J((function(e){var t,n;t=_,n=function(){var e=Object.prototype.hasOwnProperty,t=Object.prototype.toString,n="boolean"==typeof(new RegExp).sticky;function r(e){return e&&"[object RegExp]"===t.call(e)}function a(e){return e&&"object"==typeof e&&!r(e)&&!Array.isArray(e)}function i(e){return"("+e+")"}function s(e){return e.length?"(?:"+e.map((function(e){return"(?:"+e+")"})).join("|")+")":"(?!)"}function o(e){if("string"==typeof e)return"(?:"+e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")+")";if(r(e)){if(e.ignoreCase)throw new Error("RegExp /i flag not allowed");if(e.global)throw new Error("RegExp /g flag is implied");if(e.sticky)throw new Error("RegExp /y flag is implied");if(e.multiline)throw new Error("RegExp /m flag is implied");return e.source}throw new Error("Not a pattern: "+e)}function c(t,n){if(a(n)||(n={match:n}),n.include)throw new Error("Matching rules cannot also include states");var i={defaultType:t,lineBreaks:!!n.error||!!n.fallback,pop:!1,next:null,push:null,error:!1,fallback:!1,value:null,type:null,shouldThrow:!1};for(var s in n)e.call(n,s)&&(i[s]=n[s]);if("string"==typeof i.type&&t!==i.type)throw new Error("Type transform cannot be a string (type '"+i.type+"' for token '"+t+"')");var o=i.match;return i.match=Array.isArray(o)?o:o?[o]:[],i.match.sort((function(e,t){return r(e)&&r(t)?0:r(t)?-1:r(e)?1:t.length-e.length})),i}function l(e){return Array.isArray(e)?function(e){for(var t=[],n=0;n<e.length;n++){var r=e[n];if(r.include)for(var a=[].concat(r.include),i=0;i<a.length;i++)t.push({include:a[i]});else{if(!r.type)throw new Error("Rule has no type: "+JSON.stringify(r));t.push(c(r.type,r))}}return t}(e):function(e){for(var t=Object.getOwnPropertyNames(e),n=[],r=0;r<t.length;r++){var i=t[r],s=e[i],o=[].concat(s);if("include"!==i){var l=[];o.forEach((function(e){a(e)?(l.length&&n.push(c(i,l)),n.push(c(i,e)),l=[]):l.push(e)})),l.length&&n.push(c(i,l))}else for(var m=0;m<o.length;m++)n.push({include:o[m]})}return n}(e)}var m=c("error",{lineBreaks:!0,shouldThrow:!0});function u(e,t){for(var a=null,c=Object.create(null),l=!0,u=null,p=[],f=[],d=0;d<e.length;d++)e[d].fallback&&(l=!1);for(d=0;d<e.length;d++){var h=e[d];if(h.include)throw new Error("Inheritance is not allowed in stateless lexers");if(h.error||h.fallback){if(a)throw!h.fallback==!a.fallback?new Error("Multiple "+(h.fallback?"fallback":"error")+" rules not allowed (for token '"+h.defaultType+"')"):new Error("fallback and error are mutually exclusive (for token '"+h.defaultType+"')");a=h}var y=h.match.slice();if(l)for(;y.length&&"string"==typeof y[0]&&1===y[0].length;)c[y.shift().charCodeAt(0)]=h;if(h.pop||h.push||h.next){if(!t)throw new Error("State-switching options are not allowed in stateless lexers (for token '"+h.defaultType+"')");if(h.fallback)throw new Error("State-switching options are not allowed on fallback tokens (for token '"+h.defaultType+"')")}if(0!==y.length){l=!1,p.push(h);for(var v=0;v<y.length;v++){var g=y[v];if(r(g))if(null===u)u=g.unicode;else if(u!==g.unicode&&!1===h.fallback)throw new Error("If one rule is /u then all must be")}var b=s(y.map(o)),$=new RegExp(b);if($.test(""))throw new Error("RegExp matches empty string: "+$);if(new RegExp("|"+b).exec("").length-1>0)throw new Error("RegExp has capture groups: "+$+"\nUse (?:  ) instead");if(!h.lineBreaks&&$.test("\n"))throw new Error("Rule should declare lineBreaks: "+$);f.push(i(b))}}var O=a&&a.fallback,I=n&&!O?"ym":"gm",x=n||O?"":"|";return!0===u&&(I+="u"),{regexp:new RegExp(s(f)+x,I),groups:p,fast:c,error:a||m}}function p(e,t,n){var r=e&&(e.push||e.next);if(r&&!n[r])throw new Error("Missing state '"+r+"' (in token '"+e.defaultType+"' of state '"+t+"')");if(e&&e.pop&&1!=+e.pop)throw new Error("pop must be 1 (in token '"+e.defaultType+"' of state '"+t+"')")}var f=function(e,t){this.startState=t,this.states=e,this.buffer="",this.stack=[],this.reset()};f.prototype.reset=function(e,t){return this.buffer=e||"",this.index=0,this.line=t?t.line:1,this.col=t?t.col:1,this.queuedToken=t?t.queuedToken:null,this.queuedThrow=t?t.queuedThrow:null,this.setState(t?t.state:this.startState),this.stack=t&&t.stack?t.stack.slice():[],this},f.prototype.save=function(){return{line:this.line,col:this.col,state:this.state,stack:this.stack.slice(),queuedToken:this.queuedToken,queuedThrow:this.queuedThrow}},f.prototype.setState=function(e){if(e&&this.state!==e){this.state=e;var t=this.states[e];this.groups=t.groups,this.error=t.error,this.re=t.regexp,this.fast=t.fast}},f.prototype.popState=function(){this.setState(this.stack.pop())},f.prototype.pushState=function(e){this.stack.push(this.state),this.setState(e)};var d=n?function(e,t){return e.exec(t)}:function(e,t){var n=e.exec(t);return 0===n[0].length?null:n};function h(){return this.value}if(f.prototype._getGroup=function(e){for(var t=this.groups.length,n=0;n<t;n++)if(void 0!==e[n+1])return this.groups[n];throw new Error("Cannot find token type for matched text")},f.prototype.next=function(){var e=this.index;if(this.queuedGroup){var t=this._token(this.queuedGroup,this.queuedText,e);return this.queuedGroup=null,this.queuedText="",t}var n=this.buffer;if(e!==n.length){if(s=this.fast[n.charCodeAt(e)])return this._token(s,n.charAt(e),e);var r=this.re;r.lastIndex=e;var a=d(r,n),i=this.error;if(null==a)return this._token(i,n.slice(e,n.length),e);var s=this._getGroup(a),o=a[0];return i.fallback&&a.index!==e?(this.queuedGroup=s,this.queuedText=o,this._token(i,n.slice(e,a.index),e)):this._token(s,o,e)}},f.prototype._token=function(e,t,n){var r=0;if(e.lineBreaks){var a=/\n/g,i=1;if("\n"===t)r=1;else for(;a.exec(t);)r++,i=a.lastIndex}var s={type:"function"==typeof e.type&&e.type(t)||e.defaultType,value:"function"==typeof e.value?e.value(t):t,text:t,toString:h,offset:n,lineBreaks:r,line:this.line,col:this.col},o=t.length;if(this.index+=o,this.line+=r,0!==r?this.col=o-i+1:this.col+=o,e.shouldThrow)throw new Error(this.formatError(s,"invalid syntax"));return e.pop?this.popState():e.push?this.pushState(e.push):e.next&&this.setState(e.next),s},"undefined"!=typeof Symbol&&Symbol.iterator){var y=function(e){this.lexer=e};y.prototype.next=function(){var e=this.lexer.next();return{value:e,done:!e}},y.prototype[Symbol.iterator]=function(){return this},f.prototype[Symbol.iterator]=function(){return new y(this)}}return f.prototype.formatError=function(e,t){if(null==e){var n=this.buffer.slice(this.index);e={text:n,offset:this.index,lineBreaks:-1===n.indexOf("\n")?0:1,line:this.line,col:this.col}}var r=Math.max(0,e.offset-e.col+1),a=e.lineBreaks?e.text.indexOf("\n"):e.text.length,i=this.buffer.substring(r,e.offset+a);return t+=" at line "+e.line+" col "+e.col+":\n\n",t+="  "+i+"\n",t+="  "+Array(e.col).join(" ")+"^"},f.prototype.clone=function(){return new f(this.states,this.state)},f.prototype.has=function(e){return!0},{compile:function(e){var t=u(l(e));return new f({start:t},"start")},states:function(e,t){var n=e.$all?l(e.$all):[];delete e.$all;var r=Object.getOwnPropertyNames(e);t||(t=r[0]);for(var a=Object.create(null),i=0;i<r.length;i++)a[b=r[i]]=l(e[b]).concat(n);for(i=0;i<r.length;i++)for(var s=a[b=r[i]],o=Object.create(null),c=0;c<s.length;c++){var m=s[c];if(m.include){var d=[c,1];if(m.include!==b&&!o[m.include]){o[m.include]=!0;var h=a[m.include];if(!h)throw new Error("Cannot include nonexistent state '"+m.include+"' (in state '"+b+"')");for(var y=0;y<h.length;y++){var v=h[y];-1===s.indexOf(v)&&d.push(v)}}s.splice.apply(s,d),c--}}var g=Object.create(null);for(i=0;i<r.length;i++){var b;g[b=r[i]]=u(a[b],!0)}for(i=0;i<r.length;i++){var $=r[i],O=g[$],I=O.groups;for(c=0;c<I.length;c++)p(I[c],$,g);var x=Object.getOwnPropertyNames(O.fast);for(c=0;c<x.length;c++)p(O.fast[x[c]],$,g)}return new f(g,t)},error:Object.freeze({error:!0}),fallback:Object.freeze({fallback:!0}),keywords:function(e){for(var t=Object.create(null),n=Object.create(null),r=Object.getOwnPropertyNames(e),a=0;a<r.length;a++){var i=r[a],s=e[i];(Array.isArray(s)?s:[s]).forEach((function(e){if((n[e.length]=n[e.length]||[]).push(e),"string"!=typeof e)throw new Error("keyword must be string (in keyword '"+i+"')");t[e]=i}))}function o(e){return JSON.stringify(e)}var c="";for(var l in c+="switch (value.length) {\n",n){var m=n[l];c+="case "+l+":\n",c+="switch (value) {\n",m.forEach((function(e){var n=t[e];c+="case "+o(e)+": return "+o(n)+"\n"})),c+="}\n"}return c+="}\n",Function("value",c)}}},e.exports?e.exports=n():t.moo=n()})).compile({WS:{match:/(?:(?:\r?\n)|[ \t])+/,lineBreaks:!0},punctuation:/[:,]/,number:new RegExp("-?(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][-+][0-9]+)?"),property:new RegExp(fi),string:new RegExp(pi),grouping:["{","}","[","]"],boolean:["true","false"],null:["null"],other:/./});function hi(e,t,n){const r=e.slice();return r[9]=t[n],r}function yi(e,t,n){const r=e.slice();return r[12]=t[n],r[14]=n,r}function vi(e){let t,n,f=e[14]+1+"";return{c(){t=r("div"),n=a(f),this.h()},l(e){t=i(e,"DIV",{class:!0});var r=s(t);n=o(r,f),r.forEach(c),this.h()},h(){l(t,"class","svelte-o0qsb5")},m(e,r){m(e,t,r),u(t,n)},p:p,d(e){e&&c(t)}}}function gi(e){let t,n=e[9].value+"";return{c(){t=a(n)},l(e){t=o(e,n)},m(e,n){m(e,t,n)},p(e,r){16&r&&n!==(n=e[9].value+"")&&I(t,n)},d(e){e&&c(t)}}}function bi(e){let t,n,p=e[9].value+"";return{c(){t=r("span"),n=a(p),this.h()},l(e){t=i(e,"SPAN",{class:!0});var r=s(t);n=o(r,p),r.forEach(c),this.h()},h(){l(t,"class","null svelte-o0qsb5")},m(e,r){m(e,t,r),u(t,n)},p(e,t){16&t&&p!==(p=e[9].value+"")&&I(n,p)},d(e){e&&c(t)}}}function $i(e){let t,n,p=e[9].value+"";return{c(){t=r("span"),n=a(p),this.h()},l(e){t=i(e,"SPAN",{class:!0});var r=s(t);n=o(r,p),r.forEach(c),this.h()},h(){l(t,"class","boolean svelte-o0qsb5")},m(e,r){m(e,t,r),u(t,n)},p(e,t){16&t&&p!==(p=e[9].value+"")&&I(n,p)},d(e){e&&c(t)}}}function Oi(e){let t,n,p=e[9].value+"";return{c(){t=r("span"),n=a(p),this.h()},l(e){t=i(e,"SPAN",{class:!0});var r=s(t);n=o(r,p),r.forEach(c),this.h()},h(){l(t,"class","number svelte-o0qsb5")},m(e,r){m(e,t,r),u(t,n)},p(e,t){16&t&&p!==(p=e[9].value+"")&&I(n,p)},d(e){e&&c(t)}}}function Ii(e){let t,n,p,f,d=e[9].value.substring(1,e[9].value.length-1)+"";return{c(){t=a('"'),n=r("span"),p=a(d),f=a('"'),this.h()},l(e){t=o(e,'"'),n=i(e,"SPAN",{class:!0});var r=s(n);p=o(r,d),r.forEach(c),f=o(e,'"'),this.h()},h(){l(n,"class","string svelte-o0qsb5")},m(e,r){m(e,t,r),m(e,n,r),u(n,p),m(e,f,r)},p(e,t){16&t&&d!==(d=e[9].value.substring(1,e[9].value.length-1)+"")&&I(p,d)},d(e){e&&c(t),e&&c(n),e&&c(f)}}}function xi(e){let t,n,p,f,d=e[9].value.substring(1,e[9].value.length-1)+"";return{c(){t=a('"'),n=r("span"),p=a(d),f=a('"'),this.h()},l(e){t=o(e,'"'),n=i(e,"SPAN",{class:!0});var r=s(n);p=o(r,d),r.forEach(c),f=o(e,'"'),this.h()},h(){l(n,"class","property svelte-o0qsb5")},m(e,r){m(e,t,r),m(e,n,r),u(n,p),m(e,f,r)},p(e,t){16&t&&d!==(d=e[9].value.substring(1,e[9].value.length-1)+"")&&I(p,d)},d(e){e&&c(t),e&&c(n),e&&c(f)}}}function wi(e){let t,n,p=e[9].value+"";return{c(){t=r("span"),n=a(p),this.h()},l(e){t=i(e,"SPAN",{class:!0});var r=s(t);n=o(r,p),r.forEach(c),this.h()},h(){l(t,"class","grouping svelte-o0qsb5")},m(e,r){m(e,t,r),u(t,n)},p(e,t){16&t&&p!==(p=e[9].value+"")&&I(n,p)},d(e){e&&c(t)}}}function Si(e){let t;function n(e,t){return"grouping"===e[9].type?wi:"property"===e[9].type?xi:"string"===e[9].type?Ii:"number"===e[9].type?Oi:"boolean"===e[9].type?$i:"null"===e[9].type?bi:gi}let r=n(e),a=r(e);return{c(){a.c(),t=f()},l(e){a.l(e),t=f()},m(e,n){a.m(e,n),m(e,t,n)},p(e,i){r===(r=n(e))&&a?a.p(e,i):(a.d(1),a=r(e),a&&(a.c(),a.m(t.parentNode,t)))},d(e){a.d(e),e&&c(t)}}}function Ei(e){let t,n,a,o,f,$,O,I,x,w,S=[...Array(e[3])],E=[];for(let t=0;t<S.length;t+=1)E[t]=vi(yi(e,S,t));let j=e[4],P=[];for(let t=0;t<j.length;t+=1)P[t]=Si(hi(e,j,t));return{c(){t=r("div"),n=r("div");for(let e=0;e<E.length;e+=1)E[e].c();a=d(),o=r("div"),f=r("pre");for(let e=0;e<P.length;e+=1)P[e].c();$=d(),O=r("textarea"),this.h()},l(e){t=i(e,"DIV",{class:!0});var r=s(t);n=i(r,"DIV",{class:!0});var l=s(n);for(let e=0;e<E.length;e+=1)E[e].l(l);l.forEach(c),a=h(r),o=i(r,"DIV",{class:!0});var m=s(o);f=i(m,"PRE",{class:!0});var u=s(f);for(let e=0;e<P.length;e+=1)P[e].l(u);u.forEach(c),$=h(m),O=i(m,"TEXTAREA",{class:!0,"aria-label":!0}),s(O).forEach(c),m.forEach(c),r.forEach(c),this.h()},h(){l(n,"class","line-numbers svelte-o0qsb5"),l(f,"class","highlighted svelte-o0qsb5"),l(O,"class","src svelte-o0qsb5"),l(O,"aria-label","Code Editor"),l(o,"class","editable svelte-o0qsb5"),l(t,"class",I="Editor "+e[1]+" svelte-o0qsb5")},m(r,i){m(r,t,i),u(t,n);for(let e=0;e<E.length;e+=1)E[e].m(n,null);u(t,a),u(t,o),u(o,f);for(let e=0;e<P.length;e+=1)P[e].m(f,null);u(o,$),u(o,O),e[7](O),y(O,e[0]),x||(w=[v(O,"input",e[8]),v(O,"input",e[6])],x=!0)},p(e,[r]){if(8&r){let t;for(S=[...Array(e[3])],t=0;t<S.length;t+=1){const a=yi(e,S,t);E[t]?E[t].p(a,r):(E[t]=vi(a),E[t].c(),E[t].m(n,null))}for(;t<E.length;t+=1)E[t].d(1);E.length=S.length}if(16&r){let t;for(j=e[4],t=0;t<j.length;t+=1){const n=hi(e,j,t);P[t]?P[t].p(n,r):(P[t]=Si(n),P[t].c(),P[t].m(f,null))}for(;t<P.length;t+=1)P[t].d(1);P.length=j.length}1&r&&y(O,e[0]),2&r&&I!==(I="Editor "+e[1]+" svelte-o0qsb5")&&l(t,"class",I)},i:p,o:p,d(n){n&&c(t),g(E,n),g(P,n),e[7](null),x=!1,b(w)}}}function ji(e,t,n){let r,{theme:a="solarized-dark"}=t,{value:i=""}=t;let s,o;return e.$$set=e=>{"theme"in e&&n(1,a=e.theme),"value"in e&&n(0,i=e.value)},e.$$.update=()=>{1&e.$$.dirty&&n(3,s=(i.match(/\n/g)||[]).length+1),1&e.$$.dirty&&n(4,(di.reset(i),o=Array.from(di)))},[i,a,r,s,o,()=>{r.focus()},function(t){$(e,t)},function(e){O[e?"unshift":"push"]((()=>{r=e,n(2,r)}))},function(){i=this.value,n(0,i)}]}class Pi extends e{constructor(e){super(),t(this,e,ji,Ei,n,{theme:1,value:0,focus:5})}get focus(){return this.$$.ctx[5]}}function Ai(e,t,n){const r=e.slice();return r[16]=t[n],r[18]=n,r}function ki(e){let t,n,p,f;function d(){return e[11](e[18])}return{c(){t=r("button"),n=a(""),this.h()},l(e){t=i(e,"BUTTON",{class:!0});var r=s(t);n=o(r,""),r.forEach(c),this.h()},h(){l(t,"class","tab-close svelte-1ylgy73")},m(e,r){m(e,t,r),u(t,n),p||(f=v(t,"click",d),p=!0)},p(t,n){e=t},d(e){e&&c(t),p=!1,f()}}}function Ti(e){let t,n,p,f,y,g,b,$,O=e[16].label+"",w=!e[16].persistent&&e[0].length>e[5]&&ki(e);function S(){return e[12](e[18])}return{c(){t=r("button"),n=r("span"),p=a(O),f=d(),w&&w.c(),this.h()},l(e){t=i(e,"BUTTON",{role:!0,id:!0,"aria-selected":!0,"aria-controls":!0,class:!0});var r=s(t);n=i(r,"SPAN",{class:!0});var a=s(n);p=o(a,O),a.forEach(c),f=h(r),w&&w.l(r),r.forEach(c),this.h()},h(){l(n,"class","tab-label svelte-1ylgy73"),l(t,"role","tab"),l(t,"id",y=`${e[2]}-tab-${e[18]}`),l(t,"aria-selected",g=e[18]===e[1]),l(t,"aria-controls","tabpanel"),l(t,"class","svelte-1ylgy73"),x(t,"active",e[18]===e[4])},m(e,r){m(e,t,r),u(t,n),u(n,p),u(t,f),w&&w.m(t,null),b||($=v(t,"click",S),b=!0)},p(n,r){e=n,1&r&&O!==(O=e[16].label+"")&&I(p,O),!e[16].persistent&&e[0].length>e[5]?w?w.p(e,r):(w=ki(e),w.c(),w.m(t,null)):w&&(w.d(1),w=null),4&r&&y!==(y=`${e[2]}-tab-${e[18]}`)&&l(t,"id",y),2&r&&g!==(g=e[18]===e[1])&&l(t,"aria-selected",g),16&r&&x(t,"active",e[18]===e[4])},d(e){e&&c(t),w&&w.d(),b=!1,$()}}}function Ci(e){let t,n,p,f,d,h;return{c(){t=r("button"),n=r("span"),p=a("+"),this.h()},l(e){t=i(e,"BUTTON",{role:!0,id:!0,class:!0});var r=s(t);n=i(r,"SPAN",{class:!0});var a=s(n);p=o(a,"+"),a.forEach(c),r.forEach(c),this.h()},h(){l(n,"class","tab-label svelte-1ylgy73"),l(t,"role","tab"),l(t,"id",f=`${e[2]}-tab-${e[0].length}`),l(t,"class","svelte-1ylgy73")},m(r,a){m(r,t,a),u(t,n),u(n,p),d||(h=v(t,"click",e[9]),d=!0)},p(e,n){5&n&&f!==(f=`${e[2]}-tab-${e[0].length}`)&&l(t,"id",f)},d(e){e&&c(t),d=!1,h()}}}function Ni(e){let t,n,a,o,p,f,y,v,b=e[0],$=[];for(let t=0;t<b.length;t+=1)$[t]=Ti(Ai(e,b,t));let I=e[3]&&Ci(e);function x(t){e[14].call(null,t)}let C={};return void 0!==e[0][e[1]].text&&(C.value=e[0][e[1]].text),p=new Pi({props:C}),e[13](p),O.push((()=>w(p,"value",x))),p.$on("input",e[15]),{c(){t=r("div");for(let e=0;e<$.length;e+=1)$[e].c();n=d(),I&&I.c(),a=d(),o=r("div"),S(p.$$.fragment),this.h()},l(e){t=i(e,"DIV",{role:!0,class:!0});var r=s(t);for(let e=0;e<$.length;e+=1)$[e].l(r);n=h(r),I&&I.l(r),r.forEach(c),a=h(e),o=i(e,"DIV",{role:!0,id:!0,"aria-labelledby":!0,class:!0});var l=s(o);E(p.$$.fragment,l),l.forEach(c),this.h()},h(){l(t,"role","tablist"),l(t,"class","svelte-1ylgy73"),l(o,"role","tabpanel"),l(o,"id","tabpanel"),l(o,"aria-labelledby",y=`${e[2]}-tab-${e[1]}`),l(o,"class","svelte-1ylgy73")},m(e,r){m(e,t,r);for(let e=0;e<$.length;e+=1)$[e].m(t,null);u(t,n),I&&I.m(t,null),m(e,a,r),m(e,o,r),j(p,o,null),v=!0},p(e,[r]){if(1335&r){let a;for(b=e[0],a=0;a<b.length;a+=1){const i=Ai(e,b,a);$[a]?$[a].p(i,r):($[a]=Ti(i),$[a].c(),$[a].m(t,n))}for(;a<$.length;a+=1)$[a].d(1);$.length=b.length}e[3]?I?I.p(e,r):(I=Ci(e),I.c(),I.m(t,null)):I&&(I.d(1),I=null);const a={};!f&&3&r&&(f=!0,a.value=e[0][e[1]].text,P((()=>f=!1))),p.$set(a),(!v||6&r&&y!==(y=`${e[2]}-tab-${e[1]}`))&&l(o,"aria-labelledby",y)},i(e){v||(A(p.$$.fragment,e),v=!0)},o(e){k(p.$$.fragment,e),v=!1},d(n){n&&c(t),g($,n),I&&I.d(),n&&c(a),n&&c(o),e[13](null),T(p)}}}function Ri(e,t,n){let r,{ns:a=""}=t,{tabs:i=[]}=t,{newTab:s}=t,{active:o=0}=t,{selected:c=0}=t,{minTabs:l=1}=t;const m=C();function u(e){n(1,c=e),r.focus()}function p(e){c>=e&&c>0&&n(1,c-=1),i.splice(e,1),n(0,i),r.focus()}return e.$$set=e=>{"ns"in e&&n(2,a=e.ns),"tabs"in e&&n(0,i=e.tabs),"newTab"in e&&n(3,s=e.newTab),"active"in e&&n(4,o=e.active),"selected"in e&&n(1,c=e.selected),"minTabs"in e&&n(5,l=e.minTabs)},[i,c,a,s,o,l,r,m,u,function(){n(0,i[i.length]=s(),i),n(1,c=i.length-1),r.focus()},p,e=>p(e),e=>u(e),function(e){O[e?"unshift":"push"]((()=>{r=e,n(6,r)}))},function(e){i[c].text=e,n(0,i)},e=>m("input",i)]}class qi extends e{constructor(e){super(),t(this,e,Ri,Ni,n,{ns:2,tabs:0,newTab:3,active:4,selected:1,minTabs:5})}}function Mi(e,t,n){const r=e.slice();return r[2]=t[n],r}function Di(e){let t;function n(e,t){return e[1].output?Li:Vi}let r=n(e),a=r(e);return{c(){a.c(),t=f()},l(e){a.l(e),t=f()},m(e,n){a.m(e,n),m(e,t,n)},p(e,i){r===(r=n(e))&&a?a.p(e,i):(a.d(1),a=r(e),a&&(a.c(),a.m(t.parentNode,t)))},d(e){a.d(e),e&&c(t)}}}function Vi(e){let t,n=e[1]+"";return{c(){t=a(n)},l(e){t=o(e,n)},m(e,n){m(e,t,n)},p(e,r){1&r&&n!==(n=e[1]+"")&&I(t,n)},d(e){e&&c(t)}}}function Li(e){let t,n,l=e[1].output.errors,u=[];for(let t=0;t<l.length;t+=1)u[t]=Ji(Mi(e,l,t));return{c(){t=a("Invalid\n    "),n=r("ul");for(let e=0;e<u.length;e+=1)u[e].c()},l(e){t=o(e,"Invalid\n    "),n=i(e,"UL",{});var r=s(n);for(let e=0;e<u.length;e+=1)u[e].l(r);r.forEach(c)},m(e,r){m(e,t,r),m(e,n,r);for(let e=0;e<u.length;e+=1)u[e].m(n,null)},p(e,t){if(1&t){let r;for(l=e[1].output.errors,r=0;r<l.length;r+=1){const a=Mi(e,l,r);u[r]?u[r].p(a,t):(u[r]=Ji(a),u[r].c(),u[r].m(n,null))}for(;r<u.length;r+=1)u[r].d(1);u.length=l.length}},d(e){e&&c(t),e&&c(n),g(u,e)}}}function _i(e){let t,n,p,f,d,h,y=e[2].instanceLocation+"",v=e[2].absoluteKeywordLocation+"";return{c(){t=r("li"),n=r("code"),p=a(y),f=a(" fails schema constraint "),d=r("code"),h=a(v),this.h()},l(e){t=i(e,"LI",{class:!0});var r=s(t);n=i(r,"CODE",{class:!0});var a=s(n);p=o(a,y),a.forEach(c),f=o(r," fails schema constraint "),d=i(r,"CODE",{class:!0});var l=s(d);h=o(l,v),l.forEach(c),r.forEach(c),this.h()},h(){l(n,"class","svelte-1sdf2dp"),l(d,"class","svelte-1sdf2dp"),l(t,"class","svelte-1sdf2dp")},m(e,r){m(e,t,r),u(t,n),u(n,p),u(t,f),u(t,d),u(d,h)},p(e,t){1&t&&y!==(y=e[2].instanceLocation+"")&&I(p,y),1&t&&v!==(v=e[2].absoluteKeywordLocation+"")&&I(h,v)},d(e){e&&c(t)}}}function Ji(e){let t,n=!e[2].valid&&!e[2].keyword.endsWith("#validate"),r=n&&_i(e);return{c(){r&&r.c(),t=f()},l(e){r&&r.l(e),t=f()},m(e,n){r&&r.m(e,n),m(e,t,n)},p(e,a){1&a&&(n=!e[2].valid&&!e[2].keyword.endsWith("#validate")),n?r?r.p(e,a):(r=_i(e),r.c(),r.m(t.parentNode,t)):r&&(r.d(1),r=null)},d(e){r&&r.d(e),e&&c(t)}}}function Fi(e){let t,n=e[0]?"Valid":"";return{c(){t=a(n)},l(e){t=o(e,n)},m(e,n){m(e,t,n)},p(e,r){1&r&&n!==(n=e[0]?"Valid":"")&&I(t,n)},d(e){e&&c(t)}}}function zi(e){let t;return{c(){t=a("Validating ...")},l(e){t=o(e,"Validating ...")},m(e,n){m(e,t,n)},p:p,d(e){e&&c(t)}}}function Ui(e){let t,n,r={ctx:e,current:null,token:null,hasCatch:!0,pending:zi,then:Fi,catch:Di,value:0,error:1};return N(n=e[0],r),{c(){t=f(),r.block.c()},l(e){t=f(),r.block.l(e)},m(e,n){m(e,t,n),r.block.m(e,r.anchor=n),r.mount=()=>t.parentNode,r.anchor=t},p(t,[a]){if(e=t,r.ctx=e,1&a&&n!==(n=e[0])&&N(n,r));else{const t=e.slice();t[0]=t[1]=r.resolved,r.block.p(t,a)}},i:p,o:p,d(e){e&&c(t),r.block.d(e),r.token=null,r=null}}}function Bi(e,t,n){let{results:r}=t;return e.$$set=e=>{"results"in e&&n(0,r=e.results)},[r]}class Ki extends e{constructor(e){super(),t(this,e,Bi,Ui,n,{results:0})}}function Gi(e){let t,n,a,o,p;const f=e[2].default,y=R(f,e,e[1],null);return{c(){t=r("a"),n=q("svg"),a=q("path"),o=d(),y&&y.c(),this.h()},l(e){t=i(e,"A",{href:!0,class:!0});var r=s(t);n=i(r,"svg",{height:!0,viewBox:!0,version:!0,"aria-hidden":!0,class:!0},1);var l=s(n);a=i(l,"path",{"fill-rule":!0,d:!0},1),s(a).forEach(c),l.forEach(c),o=h(r),y&&y.l(r),r.forEach(c),this.h()},h(){l(a,"fill-rule","evenodd"),l(a,"d","M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"),l(n,"height","1.5em"),l(n,"viewBox","0 0 16 16"),l(n,"version","1.1"),l(n,"aria-hidden","true"),l(n,"class","svelte-i8toq"),l(t,"href",e[0]),l(t,"class","svelte-i8toq")},m(e,r){m(e,t,r),u(t,n),u(n,a),u(t,o),y&&y.m(t,null),p=!0},p(e,[n]){y&&y.p&&2&n&&M(y,f,e,e[1],n,null,null),(!p||1&n)&&l(t,"href",e[0])},i(e){p||(A(y,e),p=!0)},o(e){k(y,e),p=!1},d(e){e&&c(t),y&&y.d(e)}}}function Xi(e,t,n){let{$$slots:r={},$$scope:a}=t,{href:i=""}=t;return e.$$set=e=>{"href"in e&&n(0,i=e.href),"$$scope"in e&&n(1,a=e.$$scope)},[i,a,r]}class Hi extends e{constructor(e){super(),t(this,e,Xi,Gi,n,{href:0})}}function Wi(e){let t,n,a,o,p;const f=e[2].default,y=R(f,e,e[1],null);return{c(){t=r("a"),n=q("svg"),a=q("path"),o=d(),y&&y.c(),this.h()},l(e){t=i(e,"A",{href:!0,class:!0});var r=s(t);n=i(r,"svg",{height:!0,viewBox:!0,version:!0,"aria-hidden":!0,class:!0},1);var l=s(n);a=i(l,"path",{d:!0},1),s(a).forEach(c),l.forEach(c),o=h(r),y&&y.l(r),r.forEach(c),this.h()},h(){l(a,"d","M240,250h100v-50h100V0H240V250z M340,50h50v100h-50V50z M480,0v200h100V50h50v150h50V50h50v150h50V0H480z M0,200h100V50h50v150h50V0H0V200z"),l(n,"height","1em"),l(n,"viewBox","0 0 780 250"),l(n,"version","1.1"),l(n,"aria-hidden","true"),l(n,"class","svelte-wj8h0n"),l(t,"href",e[0]),l(t,"class","svelte-wj8h0n")},m(e,r){m(e,t,r),u(t,n),u(n,a),u(t,o),y&&y.m(t,null),p=!0},p(e,[n]){y&&y.p&&2&n&&M(y,f,e,e[1],n,null,null),(!p||1&n)&&l(t,"href",e[0])},i(e){p||(A(y,e),p=!0)},o(e){k(y,e),p=!1},d(e){e&&c(t),y&&y.d(e)}}}function Zi(e,t,n){let{$$slots:r={},$$scope:a}=t,{href:i=""}=t;return e.$$set=e=>{"href"in e&&n(0,i=e.href),"$$scope"in e&&n(1,a=e.$$scope)},[i,a,r]}class Qi extends e{constructor(e){super(),t(this,e,Zi,Wi,n,{href:0})}}function Yi(e){let t,n,a,o,p,f,y,v,g;const b=e[2].default,$=R(b,e,e[1],null);return{c(){t=r("a"),n=q("svg"),a=q("g"),o=q("path"),p=q("path"),f=q("path"),y=q("path"),v=d(),$&&$.c(),this.h()},l(e){t=i(e,"A",{href:!0,class:!0});var r=s(t);n=i(r,"svg",{version:!0,viewBox:!0,height:!0,class:!0},1);var l=s(n);a=i(l,"g",{transform:!0,id:!0},1);var m=s(a);o=i(m,"path",{id:!0,d:!0,style:!0},1),s(o).forEach(c),p=i(m,"path",{id:!0,d:!0,style:!0},1),s(p).forEach(c),f=i(m,"path",{id:!0,d:!0,style:!0},1),s(f).forEach(c),y=i(m,"path",{id:!0,d:!0,style:!0},1),s(y).forEach(c),m.forEach(c),l.forEach(c),v=h(r),$&&$.l(r),r.forEach(c),this.h()},h(){l(o,"id","path4544"),l(o,"d","m 122.99401,114.18985 c -4.32897,-0.9404 -7.58044,-3.47848 -8.71251,-6.80095 -0.78921,-2.31618 -0.67682,-6.07238 0.33363,-11.150598 0.48507,-2.437836 0.88169,-5.347843 0.88139,-6.466688 -9.8e-4,-3.718098 -1.71106,-5.735418 -5.1001,-6.016462 l -1.9549,-0.162116 v -2.392655 -2.392657 l 1.85208,-0.250855 c 2.70243,-0.366031 3.74441,-1.02838 4.57629,-2.908984 0.61121,-1.381726 0.68884,-2.068648 0.50552,-4.472869 -0.11913,-1.562244 -0.53527,-4.348568 -0.92477,-6.191832 -0.98954,-4.682868 -0.94822,-8.485471 0.11707,-10.773163 1.56862,-3.368589 5.43705,-5.854553 9.93248,-6.382903 l 1.93299,-0.227185 v 2.518015 2.518015 h -1.29973 c -1.77186,0 -4.2497,1.262413 -4.8835,2.488054 -0.60797,1.175674 -0.65405,2.864146 -0.15834,5.802223 0.78343,4.643508 1.04707,9.098344 0.67592,11.421636 -0.42464,2.658142 -1.97477,5.796328 -3.6791,7.448236 l -1.18012,1.143813 1.61497,1.982752 c 1.99051,2.443801 2.76458,4.148744 3.24284,7.142561 0.37835,2.368341 0.0844,7.282673 -0.67072,11.213982 -1.05359,5.48514 0.1623,7.65141 4.66209,8.30613 l 1.67569,0.24382 v 2.44782 c 0,2.79211 0.17086,2.69708 -3.43917,1.91286 z"),D(o,"fill","stroke-width:0.35277775"),l(p,"id","path4546"),l(p,"d","m 152.2304,112.24932 v -2.42987 l 2.04969,-0.42336 c 2.26276,-0.46736 4.054,-1.8634 4.45842,-3.47475 0.1274,-0.50758 -0.11267,-3.16398 -0.53347,-5.90311 -1.37183,-8.929552 -0.6114,-13.537042 2.85482,-17.297452 l 1.48237,-1.60818 -1.1108,-1.26512 c -3.97855,-4.53132 -4.66885,-8.552208 -3.15364,-18.369547 0.76342,-4.946305 0.76409,-4.994322 0.087,-6.173611 -0.79713,-1.388278 -3.28385,-2.776033 -4.97438,-2.776033 h -1.15997 v -2.469445 c 0,-2.811057 -0.0583,-2.773846 3.24583,-2.072788 3.9645,0.841179 6.80448,2.853272 8.27787,5.864775 0.84544,1.728026 0.97275,2.400136 0.94911,5.010889 -0.015,1.658349 -0.35758,4.682054 -0.76125,6.719346 -1.49867,7.563594 -1.3651,9.576204 0.7654,11.532814 0.98915,0.90842 1.64012,1.17274 3.37032,1.36849 l 2.14439,0.24261 v 2.42387 2.42388 l -1.6757,7.1e-4 c -2.1517,7e-4 -3.9323,0.90924 -4.83869,2.46889 -0.95194,1.63803 -0.89239,5.20675 0.17364,10.40695 0.90648,4.421902 1.05253,8.458452 0.3882,10.728752 -0.70059,2.39406 -3.81995,5.29609 -6.74745,6.27718 -1.26118,0.42266 -2.96775,0.87096 -3.79236,0.99623 l -1.49931,0.22775 z"),D(p,"stroke-width","0.35277778"),l(f,"id","path4548"),l(f,"d","m 131.74239,108.26592 c -1.02163,-1.2988 -0.87294,-3.53652 0.38087,-5.73185 0.92776,-1.62446 4.80862,-6.948549 7.61066,-10.440949 l 1.13094,-1.40958 -1.80213,-5.22523 c -2.02147,-5.86123 -2.0098,-5.97467 0.65581,-6.37225 l 1.46834,-0.219 1.64076,3.3506 c 0.90242,1.84283 1.76982,3.35061 1.92755,3.35061 0.15774,0 1.77489,-1.75542 3.59368,-3.90092 3.15918,-3.72667 3.35688,-3.89165 4.42591,-3.69334 0.64552,0.11974 1.21858,0.0465 1.35432,-0.17316 0.31818,-0.51481 1.23083,0.24704 1.23083,1.02746 0,0.32009 -0.45438,1.13409 -1.00972,1.80888 -2.26771,2.75549 -7.10417,9.27155 -7.10417,9.5713 0,0.17685 0.97502,2.45302 2.16671,5.05816 l 2.1667,4.736609 -0.65823,0.98459 c -0.36203,0.54152 -0.66236,1.12603 -0.6674,1.29891 -0.005,0.17288 -0.27769,0.48371 -0.60588,0.69073 -0.83174,0.52464 -1.44656,-0.11541 -3.9894,-4.153119 -1.16417,-1.84856 -2.23163,-3.36491 -2.37215,-3.36967 -0.31309,-0.0106 -3.7911,5.131969 -6.47955,9.580639 -2.37093,3.92324 -1.93885,3.4204 -3.26614,3.80106 -0.95533,0.27398 -1.19348,0.19843 -1.79831,-0.57048 z"),D(f,"stroke-width","0.35277775"),l(y,"id","path4550"),l(y,"d","m 131.98567,83.677091 c -2.15148,-3.8472 -6.0183,-9.42829 -7.57842,-10.93815 -0.79252,-0.76698 -1.44094,-1.57494 -1.44094,-1.79546 0,-0.6016 1.61695,-1.21975 3.19058,-1.21975 1.69822,0 3.49597,1.47777 5.0997,4.19203 0.58208,0.98515 1.15641,1.79434 1.27629,1.79819 0.11988,0.004 0.80873,-1.65116 1.53078,-3.67779 1.5464,-4.34039 5.62351,-12.777999 7.22453,-14.951229 1.3726,-1.86316 3.42936,-2.865165 5.90274,-2.875676 3.23375,-0.01374 3.24268,0.130067 0.20474,3.296663 -4.63599,4.832327 -6.76321,8.809632 -11.25155,21.037252 -1.24637,3.39549 -2.39032,6.47895 -2.54212,6.85214 -0.23022,0.56597 -0.49833,0.28096 -1.61633,-1.71822 z"),D(y,"stroke-width","0.35277775"),l(a,"transform","translate(-104.22785,-45.507923)"),l(a,"id","layer1"),l(n,"version","1.1"),l(n,"viewBox","0 0 70.423268 70.42326"),l(n,"height","1.25em"),l(n,"class","svelte-27u907"),l(t,"href",e[0]),l(t,"class","svelte-27u907")},m(e,r){m(e,t,r),u(t,n),u(n,a),u(a,o),u(a,p),u(a,f),u(a,y),u(t,v),$&&$.m(t,null),g=!0},p(e,[n]){$&&$.p&&2&n&&M($,b,e,e[1],n,null,null),(!g||1&n)&&l(t,"href",e[0])},i(e){g||(A($,e),g=!0)},o(e){k($,e),g=!1},d(e){e&&c(t),$&&$.d(e)}}}function es(e,t,n){let{$$slots:r={},$$scope:a}=t,{href:i=""}=t;return e.$$set=e=>{"href"in e&&n(0,i=e.href),"$$scope"in e&&n(1,a=e.$$scope)},[i,a,r]}class ts extends e{constructor(e){super(),t(this,e,es,Yi,n,{href:0})}}function ns(e){let t;return{c(){t=a("hyperjump-io/json-schema.hyperjump.io")},l(e){t=o(e,"hyperjump-io/json-schema.hyperjump.io")},m(e,n){m(e,t,n)},d(e){e&&c(t)}}}function rs(e){let t;return{c(){t=a("hyperjump-io/json-schema-validator")},l(e){t=o(e,"hyperjump-io/json-schema-validator")},m(e,n){m(e,t,n)},d(e){e&&c(t)}}}function as(e){let t;return{c(){t=a("@hyperjump/json-schema")},l(e){t=o(e,"@hyperjump/json-schema")},m(e,n){m(e,t,n)},d(e){e&&c(t)}}}function is(e){let t;return{c(){t=a("@hyperjump/json-schema-core")},l(e){t=o(e,"@hyperjump/json-schema-core")},m(e,n){m(e,t,n)},d(e){e&&c(t)}}}function ss(e){let t;return{c(){t=a("JSON Schema")},l(e){t=o(e,"JSON Schema")},m(e,n){m(e,t,n)},d(e){e&&c(t)}}}function os(e){let t,n,a,o,p,f,y,v,g,b,$,O,I,x,w,P,C;return o=new Hi({props:{href:"https://github.com/hyperjump-io/json-schema.hyperjump.io",$$slots:{default:[ns]},$$scope:{ctx:e}}}),y=new Hi({props:{href:"https://github.com/hyperjump-io/json-schema-validator",$$slots:{default:[rs]},$$scope:{ctx:e}}}),b=new Qi({props:{href:"https://www.npmjs.com/package/@hyperjump/json-schema",$$slots:{default:[as]},$$scope:{ctx:e}}}),I=new Qi({props:{href:"https://www.npmjs.com/package/@hyperjump/json-schema-core",$$slots:{default:[is]},$$scope:{ctx:e}}}),P=new ts({props:{href:"https://json-schema.org",$$slots:{default:[ss]},$$scope:{ctx:e}}}),{c(){t=r("footer"),n=r("ul"),a=r("li"),S(o.$$.fragment),p=d(),f=r("li"),S(y.$$.fragment),v=d(),g=r("li"),S(b.$$.fragment),$=d(),O=r("li"),S(I.$$.fragment),x=d(),w=r("li"),S(P.$$.fragment),this.h()},l(e){t=i(e,"FOOTER",{class:!0});var r=s(t);n=i(r,"UL",{class:!0});var l=s(n);a=i(l,"LI",{class:!0});var m=s(a);E(o.$$.fragment,m),m.forEach(c),p=h(l),f=i(l,"LI",{class:!0});var u=s(f);E(y.$$.fragment,u),u.forEach(c),v=h(l),g=i(l,"LI",{class:!0});var d=s(g);E(b.$$.fragment,d),d.forEach(c),$=h(l),O=i(l,"LI",{class:!0});var S=s(O);E(I.$$.fragment,S),S.forEach(c),x=h(l),w=i(l,"LI",{class:!0});var j=s(w);E(P.$$.fragment,j),j.forEach(c),l.forEach(c),r.forEach(c),this.h()},h(){l(a,"class","svelte-17tbtsq"),l(f,"class","svelte-17tbtsq"),l(g,"class","svelte-17tbtsq"),l(O,"class","svelte-17tbtsq"),l(w,"class","svelte-17tbtsq"),l(n,"class","links svelte-17tbtsq"),l(t,"class","svelte-17tbtsq")},m(e,r){m(e,t,r),u(t,n),u(n,a),j(o,a,null),u(n,p),u(n,f),j(y,f,null),u(n,v),u(n,g),j(b,g,null),u(n,$),u(n,O),j(I,O,null),u(n,x),u(n,w),j(P,w,null),C=!0},p(e,[t]){const n={};1&t&&(n.$$scope={dirty:t,ctx:e}),o.$set(n);const r={};1&t&&(r.$$scope={dirty:t,ctx:e}),y.$set(r);const a={};1&t&&(a.$$scope={dirty:t,ctx:e}),b.$set(a);const i={};1&t&&(i.$$scope={dirty:t,ctx:e}),I.$set(i);const s={};1&t&&(s.$$scope={dirty:t,ctx:e}),P.$set(s)},i(e){C||(A(o.$$.fragment,e),A(y.$$.fragment,e),A(b.$$.fragment,e),A(I.$$.fragment,e),A(P.$$.fragment,e),C=!0)},o(e){k(o.$$.fragment,e),k(y.$$.fragment,e),k(b.$$.fragment,e),k(I.$$.fragment,e),k(P.$$.fragment,e),C=!1},d(e){e&&c(t),T(o),T(y),T(b),T(I),T(P)}}}class cs extends e{constructor(e){super(),t(this,e,null,os,n,{})}}var ls=J((function(e,t){var n;n={},("object"==typeof window&&window||_).PubSub=n,function(e){var t={},n=-1,r="*";function a(e){var t;for(t in e)if(e.hasOwnProperty(t))return!0;return!1}function i(e){return function(){throw e}}function s(e,t,n){try{e(t,n)}catch(e){setTimeout(i(e),0)}}function o(e,t,n){e(t,n)}function c(e,n,r,a){var i,c=t[n],l=a?o:s;if(t.hasOwnProperty(n))for(i in c)c.hasOwnProperty(i)&&l(c[i],e,r)}function l(e,t,n){return function(){var a=String(e),i=a.lastIndexOf(".");for(c(e,e,t,n);-1!==i;)i=(a=a.substr(0,i)).lastIndexOf("."),c(e,a,t,n);c(e,r,t,n)}}function m(e){var n=String(e);return Boolean(t.hasOwnProperty(n)&&a(t[n]))}function u(e){for(var t=String(e),n=m(t)||m(r),a=t.lastIndexOf(".");!n&&-1!==a;)a=(t=t.substr(0,a)).lastIndexOf("."),n=m(t);return n}function p(e,t,n,r){var a=l(e="symbol"==typeof e?e.toString():e,t,r);return!!u(e)&&(!0===n?a():setTimeout(a,0),!0)}e.publish=function(t,n){return p(t,n,!1,e.immediateExceptions)},e.publishSync=function(t,n){return p(t,n,!0,e.immediateExceptions)},e.subscribe=function(e,r){if("function"!=typeof r)return!1;e="symbol"==typeof e?e.toString():e,t.hasOwnProperty(e)||(t[e]={});var a="uid_"+String(++n);return t[e][a]=r,a},e.subscribeAll=function(t){return e.subscribe(r,t)},e.subscribeOnce=function(t,n){var r=e.subscribe(t,(function(){e.unsubscribe(r),n.apply(this,arguments)}));return e},e.clearAllSubscriptions=function(){t={}},e.clearSubscriptions=function(e){var n;for(n in t)t.hasOwnProperty(n)&&0===n.indexOf(e)&&delete t[n]},e.countSubscriptions=function(e){var n,r=0;for(n in t)t.hasOwnProperty(n)&&0===n.indexOf(e)&&r++;return r},e.getSubscriptions=function(e){var n,r=[];for(n in t)t.hasOwnProperty(n)&&0===n.indexOf(e)&&r.push(n);return r},e.unsubscribe=function(n){var r,a,i,s=function(e){var n;for(n in t)if(t.hasOwnProperty(n)&&0===n.indexOf(e))return!0;return!1},o="string"==typeof n&&(t.hasOwnProperty(n)||s(n)),c=!o&&"string"==typeof n,l="function"==typeof n,m=!1;if(!o){for(r in t)if(t.hasOwnProperty(r)){if(a=t[r],c&&a[n]){delete a[n],m=n;break}if(l)for(i in a)a.hasOwnProperty(i)&&a[i]===n&&(delete a[i],m=!0)}return m}e.clearSubscriptions(n)}}(n),void 0!==e&&e.exports&&(t=e.exports=n),t.PubSub=n,e.exports=t=n}));ls.PubSub;const ms={null:e=>null===e,boolean:e=>"boolean"==typeof e,object:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,array:e=>Array.isArray(e),number:e=>"number"==typeof e,integer:e=>Number.isInteger(e),string:e=>"string"==typeof e};var us={jsonTypeOf:(e,t)=>ms[t](e),splitUrl:e=>{const t=e.indexOf("#"),n=-1===t?e.length:t,r=e.slice(0,n),a=e.slice(n+1);return[decodeURI(r),decodeURI(a)]}};const ps=Symbol("$__value"),fs=Symbol("$__href"),ds=Symbol("$__isDynamic");var hs=(e,t,n=!1)=>Object.freeze({[fs]:e,[ps]:t,[ds]:n}),ys=e=>e&&void 0!==e[fs],vs=e=>e[fs],gs=e=>e[ps],bs=e=>e[ds];const{jsonTypeOf:$s}=us,Os=Object.freeze({id:"",pointer:"",instance:void 0,value:void 0}),Is=e=>ys(e.value)?gs(e.value):e.value,xs=L(((e,t)=>$s(Is(e),t))),ws=(e,t)=>Object.freeze({...t,pointer:ee.append(e,t.pointer),value:Is(t)[e]}),Ss=L(((e,t)=>Is(t).map(((n,r,a,i)=>e(ws(r,t),r,a,i))))),Es=L(((e,t)=>Is(t).map(((e,n,r,a)=>ws(n,t))).filter(((t,n,r,a)=>e(t,n,r,a))))),js=L(((e,t,n)=>Is(n).reduce(((t,r,a)=>e(t,ws(a,n),a)),t))),Ps=L(((e,t)=>Is(t).every(((n,r,a,i)=>e(ws(r,t),r,a,i))))),As=L(((e,t)=>Is(t).some(((n,r,a,i)=>e(ws(r,t),r,a,i)))));var ks={cons:(e,t="")=>Object.freeze({...Os,id:t,instance:e,value:e}),uri:e=>`${e.id}#${encodeURI(e.pointer)}`,value:Is,typeOf:xs,step:ws,entries:e=>Object.keys(Is(e)).map((t=>[t,ws(t,e)])),keys:e=>Object.keys(Is(e)),map:Ss,filter:Es,reduce:js,every:Ps,some:As,length:e=>Is(e).length},Ts=fetch;const{jsonTypeOf:Cs,splitUrl:Ns}=us,Rs={},qs={},Ms=(e,t)=>{const n=e in qs?qs[e]:e;if(n in Rs)return Rs[n][t]},Ds={},Vs={},Ls=(e,t="",n="")=>{e=JSON.parse(JSON.stringify(e));const r=Ns(e.$schema||n)[0];if(!r)throw Error("Couldn't determine schema version");delete e.$schema;const a=Ms(r,"baseToken"),i=Ms(r,"anchorToken"),s=Ns(t)[0];if(!s&&!Ns(e[a]||"")[0])throw Error("Couldn't determine an identifier for the schema");const o=Bs(s,e[a]||""),[c,l]=Ns(o);delete e[a],l&&a===i&&(e[i]=i!==a?encodeURI(l):"#"+encodeURI(l)),s&&(Vs[s]=c);const m={},u=Ms(r,"recursiveAnchorToken");let p;!0===e[u]&&(m["#"]=c,e[i]="",delete e[u]);const f=Ms(r,"vocabularyToken");Cs(e[f],"object")?(qs[c]=r,p=e[f],delete e[f]):(qs[c]=r,p={[r]:!0});const d={};Ds[c]={id:c,schemaVersion:r,schema:_s(e,c,r,ee.nil,d,m),anchors:d,dynamicAnchors:m,vocabulary:p,validated:!1}},_s=(e,t,n,r,a,i)=>{if(Cs(e,"object")){const s="string"==typeof e.$schema?Ns(e.$schema)[0]:n,o=Ms(s,"embeddedToken"),c=Ms(s,"anchorToken");if("string"==typeof e[o]&&(o!==c||"#"!==e[o][0])){const r=Bs(t,e[o]);return e[o]=r,Ls(e,r,n),hs(e[o],e)}const l=Ms(n,"anchorToken"),m=Ms(n,"dynamicAnchorToken");"string"==typeof e[m]&&(i["#"+e[m]]=t,e[l]=e[m],delete e[m]);const u=Ms(n,"embeddedToken");if("string"==typeof e[l]){const t=l!==u?e[l]:e[l].slice(1);a[t]=r,delete e[l]}const p=Ms(n,"jrefToken");if("string"==typeof e[p])return hs(e[p],e);for(let s in e)e[s]=_s(e[s],t,n,ee.append(s,r),a,i);const f=Ms(n,"jsrefToken");"string"==typeof e[f]&&(e[f]=hs(e[f],e[f]));const d=Ms(n,"dynamicJsrefToken");return"string"==typeof e[d]&&(e[d]=hs(e[d],e[d],!0)),e}return Array.isArray(e)?e.map(((e,s)=>_s(e,t,n,ee.append(s,r),a,i))):e},Js=e=>Ds[Vs[e]]||Ds[e],Fs=Object.freeze({id:"",schemaVersion:void 0,pointer:"",schema:void 0,dynamicAnchors:{}}),zs=async(e,t=Fs,n=!1)=>{const r=n&&t.dynamicAnchors[e]?t.dynamicAnchors[e]:Xs(t),a=Bs(r,e),[i,s]=Ns(a);if(!(e=>e in Ds||e in Vs)(i)){const e=await Ts(i,{headers:{Accept:"application/schema+json"}});if(e.status>=400)throw await e.text(),Error("Failed to retrieve schema with id: "+i);if(e.headers.has("content-type")){const t=ke.parse(e.headers.get("content-type")).type;if("application/schema+json"!==t)throw Error(`${i} is not a schema. Found a document with media type: ${t}`)}Ls(await e.json(),i)}const o=Js(i),c=s&&"/"!==s[0]?Gs(o,s):s,l=Object.freeze({id:o.id,schemaVersion:o.schemaVersion,vocabulary:o.vocabulary,pointer:c,schema:o.schema,value:ee.get(c,o.schema),dynamicAnchors:{...o.dynamicAnchors,...t.dynamicAnchors},validated:o.validated});return Us(l)},Us=e=>ys(e.value)?zs(vs(e.value),e,bs(e.value)):e,Bs=(e,t)=>{const n=Le(e,t),r=Ns(e)[0];if(r&&"file"===Ks(n)&&"file"!==Ks(r))throw Error(`Can't access file '${n}' resource from network context '${e}'`);return n},Ks=e=>{const t=e.match(/^(.+):\/\//);return t?t[1]:""},Gs=(e,t)=>{if(!(t in e.anchors))throw Error(`No such anchor '${encodeURI(e.id)}#${encodeURI(t)}'`);return e.anchors[t]},Xs=e=>`${e.id}#${encodeURI(e.pointer)}`,Hs=e=>ys(e.value)?gs(e.value):e.value,Ws=(e,t)=>{const n=Js(t.id),r=Object.freeze({id:t.id,schemaVersion:t.schemaVersion,vocabulary:t.vocabulary,pointer:ee.append(e,t.pointer),schema:n.schema,value:Hs(t)[e],dynamicAnchors:t.dynamicAnchors,validated:n.validated});return Us(r)},Zs=L(((e,t)=>Ve.pipeline([Hs,Ve.map((async(n,r)=>e(await Ws(r,t),r))),Ve.all],t)));var Qs={setConfig:(e,t,n)=>{Rs[e]||(Rs[e]={}),Rs[e][t]=n},getConfig:Ms,add:Ls,get:zs,markValidated:e=>{Ds[e].validated=!0},uri:Xs,value:Hs,typeOf:(e,t)=>Cs(Hs(e),t),has:(e,t)=>e in Hs(t),step:Ws,keys:e=>Object.keys(Hs(e)),entries:e=>Ve.pipeline([Hs,Object.keys,Ve.map((async t=>[t,await Ws(t,e)])),Ve.all],e),map:Zs,length:e=>Hs(e).length};class Ys extends Error{constructor(e){super("Invalid Schema"),this.name=this.constructor.name,this.output=e}}var eo=Ys;const to="FLAG",no="BASIC",ro="DETAILED",ao="VERBOSE";let io=ro,so=!0;const oo=async e=>{const t={};return{ast:t,schemaUri:await yo(e,t)}},co=L((({ast:e,schemaUri:t},n,r=to)=>{if(![to,no,ro,ao].includes(r))throw Error(`The '${r}' error format is not supported`);let a=[];const i=ls.subscribe("result",lo(r,a));return vo(t,n,e),ls.unsubscribe(i),a[0]})),lo=(e,t)=>{const n=[];return(r,a)=>{if("result"===r){const{keyword:e,absoluteKeywordLocation:t,instanceLocation:r,valid:i}=a,s={keyword:e,absoluteKeywordLocation:t,instanceLocation:r,valid:i,errors:[]};n.push(s)}else if("result.start"===r)n.push(r);else if("result.end"===r){const r=n.pop();for(;"result.start"!==n[n.length-1];){const t=n.pop(),a=[t];e===no&&(a.push(...t.errors),delete t.errors),(e===ao||e!==to&&!t.valid)&&r.errors.unshift(...a)}n[n.length-1]=r,t[0]=r}}},mo={},uo=e=>mo[e],po=e=>e in mo,fo={},ho={},yo=async(e,t)=>{if(!po(e.schemaVersion+"#validate")){const t=await Qs.get(e.schemaVersion);(Qs.getConfig(t.id,"mandatoryVocabularies")||[]).forEach((e=>{if(!t.vocabulary[e])throw Error(`Vocabulary '${e}' must be explicitly declared and required`)})),Object.entries(t.vocabulary).forEach((([e,n])=>{if(e in fo)Object.entries(fo[e]).forEach((([e,n])=>{((e,t)=>{mo[e]={collectEvaluatedItems:(e,n,r)=>t.interpret(e,n,r)&&0,collectEvaluatedProperties:(e,n,r)=>t.interpret(e,n,r)&&[],...t}})(`${t.id}#${e}`,n)}));else if(n)throw Error("Missing required vocabulary: "+e)}))}if(so&&!e.validated){if(Qs.markValidated(e.id),!(e.schemaVersion in ho)){const t=await Qs.get(e.schemaVersion),n={},r=await yo(t,n);ho[t.id]=co({ast:n,schemaUri:r})}const t=ks.cons(e.schema,e.id),n=ho[e.schemaVersion](t,io);if(!n.valid)throw new eo(n)}return await uo(e.schemaVersion+"#validate").compile(e,t),Qs.uri(e)},vo=(e,t,n)=>{const[r]=n[e];return uo(r).interpret(e,t,n)};var go={validate:async(e,t,n)=>{const r=await oo(e),a=(e,t=to)=>co(r,ks.cons(e),t);return void 0===t?a:a(t,n)},compile:oo,interpret:co,setMetaOutputFormat:e=>{io=e},setShouldMetaValidate:e=>{so=e},FLAG:to,BASIC:no,DETAILED:ro,VERBOSE:ao,getKeyword:uo,hasKeyword:po,defineVocabulary:(e,t)=>{fo[e]=t},compileSchema:yo,interpretSchema:vo,collectEvaluatedProperties:(e,t,n,r)=>{const[a]=n[e];return uo(a).collectEvaluatedProperties(e,t,n,r)},collectEvaluatedItems:(e,t,n,r)=>{const[a]=n[e];return uo(a).collectEvaluatedItems(e,t,n,r)}};var bo={compile:e=>Qs.value(e),interpret:()=>!0};var $o={compile:async(e,t)=>{const n=Qs.uri(e);if(!(n in t)){t[n]=!1;const r=Qs.value(e);t[n]=[e.schemaVersion+"#validate",Qs.uri(e),"boolean"==typeof r?r:await Ve.pipeline([Qs.entries,Ve.map((([t,n])=>[`${e.schemaVersion}#${t}`,n])),Ve.filter((([t])=>go.hasKeyword(t)&&t!==e.schemaVersion+"#validate")),Ve.map((async([n,r])=>{const a=await go.getKeyword(n).compile(r,t,e);return[n,Qs.uri(r),a]})),Ve.all],e)]}return n},interpret:(e,t,n)=>{const[r,a,i]=n[e];ls.publishSync("result.start");const s="boolean"==typeof i?i:i.every((([e,r,a])=>{ls.publishSync("result.start");const i=go.getKeyword(e).interpret(a,t,n);return ls.publishSync("result",{keyword:e,absoluteKeywordLocation:r,instanceLocation:ks.uri(t),valid:i,ast:a}),ls.publishSync("result.end"),i}));return ls.publishSync("result",{keyword:r,absoluteKeywordLocation:a,instanceLocation:ks.uri(t),valid:s,ast:e}),ls.publishSync("result.end"),s},collectEvaluatedProperties:(e,t,n,r=!1)=>{const a=n[e][2];return"boolean"==typeof a?!!a&&[]:a.filter((([e])=>!r||!e.endsWith("#unevaluatedProperties"))).reduce(((e,[r,,a])=>{const i=e&&go.getKeyword(r).collectEvaluatedProperties(a,t,n);return i&&e.concat(i)}),[])},collectEvaluatedItems:(e,t,n,r=!1)=>{const a=n[e][2];return"boolean"==typeof a?!!a&&[]:a.filter((([e])=>!r||!e.endsWith("#unevaluatedItems"))).reduce(((e,[r,,a])=>{const i=!1!==e&&go.getKeyword(r).collectEvaluatedItems(a,t,n);return!1!==i&&Math.max(e,i)}),0)}},Oo={Core:go,Schema:Qs,Instance:ks,Keywords:{metaData:bo,validate:$o}};const{Core:Io,Schema:xo,Instance:wo}=Oo;var So={compile:async(e,t,n)=>{const r=await xo.step("items",n),a=xo.typeOf(r,"array")?xo.length(r):Number.MAX_SAFE_INTEGER;return xo.typeOf(e,"boolean")?[a,xo.value(e)]:[a,await Io.compileSchema(e,t)]},interpret:([e,t],n,r)=>!wo.typeOf(n,"array")||("string"==typeof t?wo.every(((n,a)=>a<e||Io.interpretSchema(t,n,r)),n):wo.every(((n,r)=>r<e||t),n))};const{Core:Eo,Schema:jo,Instance:Po}=Oo,Ao=([e,t],n,r)=>!Po.typeOf(n,"array")||Po.every(((n,a)=>a<e||Eo.interpretSchema(t,n,r)),n);var ko={compile:async(e,t,n)=>{const r=await jo.step("items",n);return[jo.typeOf(r,"array")?jo.length(r):Number.MAX_SAFE_INTEGER,await Eo.compileSchema(e,t)]},interpret:Ao,collectEvaluatedItems:(e,t,n)=>Ao(e,t,n)&&Number.MAX_SAFE_INTEGER};const{Core:To,Schema:Co,Instance:No}=Oo;var Ro={compile:async(e,t,n)=>{const r=await Co.step("properties",n),a=Co.typeOf(r,"object")?Co.keys(r):[],i=await Co.step("patternProperties",n),s=Co.typeOf(i,"object")?Co.keys(i).map((e=>new RegExp(e))):[];return Co.typeOf(e,"boolean")?[a,s,Co.value(e)]:[a,s,await To.compileSchema(e,t)]},interpret:([e,t,n],r,a)=>{if(!No.typeOf(r,"object"))return!0;const i=No.entries(r).filter((([n])=>!e.includes(n)&&!t.some((e=>e.test(n)))));return"string"==typeof n?i.every((([,e])=>To.interpretSchema(n,e,a))):0===i.length||n}};const{Core:qo,Schema:Mo,Instance:Do}=Oo,Vo=([e,t,n],r,a)=>!Do.typeOf(r,"object")||Do.entries(r).filter((([n])=>!e.includes(n)&&!t.some((e=>e.test(n))))).every((([,e])=>qo.interpretSchema(n,e,a)));var Lo={compile:async(e,t,n)=>{const r=await Mo.step("properties",n),a=Mo.typeOf(r,"object")?Mo.keys(r):[],i=await Mo.step("patternProperties",n);return[a,Mo.typeOf(i,"object")?Mo.keys(i).map((e=>new RegExp(e))):[],await qo.compileSchema(e,t)]},interpret:Vo,collectEvaluatedProperties:(e,t,n)=>Vo(e,t,n)&&[new RegExp("")]};const{Core:_o,Schema:Jo}=Oo;var Fo={compile:(e,t)=>Ve.pipeline([Jo.map((async e=>_o.compileSchema(await e,t))),Ve.all],e),interpret:(e,t,n)=>e.every((e=>_o.interpretSchema(e,t,n))),collectEvaluatedProperties:(e,t,n)=>e.reduce(((e,r)=>{const a=e&&_o.collectEvaluatedProperties(r,t,n);return a&&e.concat(a)}),[]),collectEvaluatedItems:(e,t,n)=>e.reduce(((e,r)=>{const a=!1!==e&&_o.collectEvaluatedItems(r,t,n);return!1!==a&&Math.max(e,a)}),0)};const{Core:zo,Schema:Uo}=Oo;var Bo={compile:(e,t)=>Ve.pipeline([Uo.map((async e=>zo.compileSchema(await e,t))),Ve.all],e),interpret:(e,t,n)=>e.filter((e=>zo.interpretSchema(e,t,n))).length>0,collectEvaluatedProperties:(e,t,n)=>e.reduce(((e,r)=>{const a=zo.collectEvaluatedProperties(r,t,n);return a?(e||[]).concat(a):e}),!1),collectEvaluatedItems:(e,t,n)=>e.reduce(((e,r)=>{const a=zo.collectEvaluatedItems(r,t,n);return!1!==a?Math.max(e,a):e}),!1)};const{Schema:Ko,Instance:Go}=Oo;var Xo={compile:e=>on(Ko.value(e)),interpret:(e,t)=>on(Go.value(t))===e};const{Core:Ho,Instance:Wo}=Oo;var Zo={compile:(e,t)=>Ho.compileSchema(e,t),interpret:(e,t,n)=>!Wo.typeOf(t,"array")||Wo.some((t=>Ho.interpretSchema(e,t,n)),t)};const{Core:Qo,Schema:Yo,Instance:ec}=Oo;var tc={compile:async(e,t,n)=>{const r=await Qo.compileSchema(e,t),a=await Yo.step("minContains",n),i=Yo.typeOf(a,"number")?Yo.value(a):1,s=await Yo.step("maxContains",n);return{contains:r,minContains:i,maxContains:Yo.typeOf(s,"number")?Yo.value(s):Number.MAX_SAFE_INTEGER}},interpret:({contains:e,minContains:t,maxContains:n},r,a)=>{if(!ec.typeOf(r,"array"))return!0;const i=ec.reduce(((t,n)=>Qo.interpretSchema(e,n,a)?t+1:t),0,r);return i>=t&&i<=n}};const{Core:nc,Schema:rc}=Oo;var ac={compile:async(e,t)=>{await Ve.pipeline([rc.entries,Ve.map((([,e])=>nc.compileSchema(e,t))),Ve.all],e)},interpret:()=>!0};const{Core:ic,Schema:sc,Instance:oc}=Oo;var cc={compile:(e,t)=>Ve.pipeline([sc.entries,Ve.map((async([e,n])=>[e,sc.typeOf(n,"array")?sc.value(n):await ic.compileSchema(n,t)])),Ve.all],e),interpret:(e,t,n)=>{const r=oc.value(t);return!oc.typeOf(t,"object")||e.every((([e,a])=>!(e in r)||(Array.isArray(a)?a.every((e=>e in r)):ic.interpretSchema(a,t,n))))}};const{Schema:lc,Instance:mc}=Oo;var uc={compile:e=>Ve.pipeline([lc.entries,Ve.map((([e,t])=>[e,lc.value(t)])),Ve.all],e),interpret:(e,t)=>{const n=mc.value(t);return!mc.typeOf(t,"object")||e.every((([e,t])=>!(e in n)||t.every((e=>e in n))))}};const{Core:pc,Schema:fc,Instance:dc}=Oo;var hc={compile:(e,t)=>Ve.pipeline([fc.entries,Ve.map((async([e,n])=>[e,await pc.compileSchema(n,t)])),Ve.all],e),interpret:(e,t,n)=>{const r=dc.value(t);return!dc.typeOf(t,"object")||e.every((([e,a])=>!(e in r)||pc.interpretSchema(a,t,n)))},collectEvaluatedProperties:(e,t,n)=>{const r=dc.value(t);return e.reduce(((e,[a,i])=>{if(!e||!(a in r))return e;const s=pc.collectEvaluatedProperties(i,t,n);return s&&e.concat(s)}),[])}};const{Schema:yc,Instance:vc}=Oo;var gc={compile:e=>yc.value(e).map(on),interpret:(e,t)=>e.some((e=>on(vc.value(t))===e))};const{Schema:bc,Instance:$c}=Oo;var Oc={compile:async e=>bc.value(e),interpret:(e,t)=>!$c.typeOf(t,"number")||$c.value(t)<e};const{Schema:Ic,Instance:xc}=Oo;var wc={compile:async e=>Ic.value(e),interpret:(e,t)=>!xc.typeOf(t,"number")||xc.value(t)>e};const{Core:Sc}=Oo;var Ec={compile:(e,t)=>Sc.compileSchema(e,t),interpret:(e,t,n)=>(Sc.interpretSchema(e,t,n),!0)};const{Core:jc,Schema:Pc}=Oo,Ac=(e,t,n)=>{const r=n[e][2];return"boolean"==typeof r?r:r.every((([e,,r])=>jc.getKeyword(e).interpret(r,t,n)))};var kc={compile:async(e,t,n)=>{if(Pc.has("if",n)){const r=await Pc.step("if",n);return[await jc.compileSchema(r,t),await jc.compileSchema(e,t)]}return[]},interpret:([e,t],n,r)=>void 0===e||!Ac(e,n,r)||jc.interpretSchema(t,n,r),collectEvaluatedProperties:([e,t],n,r)=>{if(void 0===e)return[];const a=jc.collectEvaluatedProperties(e,n,r);if(!1===a)return[];const i=jc.collectEvaluatedProperties(t,n,r);return!1!==i&&a.concat(i)},collectEvaluatedItems:([e,t],n,r)=>void 0!==e&&jc.interpretSchema(e,n,r)?Math.max(jc.collectEvaluatedItems(e,n,r),jc.collectEvaluatedItems(t,n,r)):0};const{Core:Tc,Schema:Cc}=Oo,Nc=(e,t,n)=>{const r=n[e][2];return"boolean"==typeof r?r:r.every((([e,,r])=>Tc.getKeyword(e).interpret(r,t,n)))};var Rc={compile:async(e,t,n)=>{if(Cc.has("if",n)){const r=await Cc.step("if",n);return[await Tc.compileSchema(r,t),await Tc.compileSchema(e,t)]}return[]},interpret:([e,t],n,r)=>void 0===e||Nc(e,n,r)||Tc.interpretSchema(t,n,r),collectEvaluatedProperties:([e,t],n,r)=>void 0===e||!1!==Tc.collectEvaluatedProperties(e,n,r)?[]:Tc.collectEvaluatedProperties(t,n,r),collectEvaluatedItems:([e,t],n,r)=>void 0===e||Tc.interpretSchema(e,n,r)?0:Tc.collectEvaluatedItems(t,n,r)};const{Core:qc,Schema:Mc,Instance:Dc}=Oo,Vc=(e,t,n)=>!Dc.typeOf(t,"array")||("string"==typeof e?Dc.every((t=>qc.interpretSchema(e,t,n)),t):Dc.every(((t,r)=>!(r in e)||qc.interpretSchema(e[r],t,n)),t));var Lc={compile:(e,t)=>Mc.typeOf(e,"array")?Ve.pipeline([Mc.map((e=>qc.compileSchema(e,t))),Ve.all],e):qc.compileSchema(e,t),interpret:Vc,collectEvaluatedItems:(e,t,n)=>Vc(e,t,n)&&("string"==typeof e?Number.MAX_SAFE_INTEGER:e.length)};const{Core:_c,Schema:Jc,Instance:Fc}=Oo,zc=([e,t],n,r)=>!Fc.typeOf(n,"array")||Fc.every(((n,a)=>a<e||_c.interpretSchema(t,n,r)),n);var Uc={compile:async(e,t,n)=>{const r=await Jc.step("prefixItems",n);return[Jc.typeOf(r,"array")?Jc.length(r):0,await _c.compileSchema(e,t)]},interpret:zc,collectEvaluatedItems:(e,t,n)=>zc(e,t,n)&&Number.MAX_SAFE_INTEGER};const{Schema:Bc,Instance:Kc}=Oo;var Gc={compile:e=>Bc.value(e),interpret:(e,t)=>!Kc.typeOf(t,"array")||Kc.length(t)<=e};const{Schema:Xc,Instance:Hc}=Oo;var Wc={compile:e=>Xc.value(e),interpret:(e,t)=>!Hc.typeOf(t,"string")||Hc.length(t)<=e};const{Schema:Zc,Instance:Qc}=Oo;var Yc={compile:e=>Zc.value(e),interpret:(e,t)=>!Qc.typeOf(t,"string")||[...Qc.value(t)].length<=e};const{Schema:el,Instance:tl}=Oo;var nl={compile:e=>el.value(e),interpret:(e,t)=>!tl.typeOf(t,"object")||tl.keys(t).length<=e};const{Schema:rl,Instance:al}=Oo;var il={compile:async(e,t,n)=>{const r=await rl.step("exclusiveMaximum",n),a=rl.value(r);return[rl.value(e),a]},interpret:([e,t],n)=>{if(!al.typeOf(n,"number"))return!0;const r=al.value(n);return t?r<e:r<=e}};const{Schema:sl,Instance:ol}=Oo;var cl={compile:async e=>sl.value(e),interpret:(e,t)=>!ol.typeOf(t,"number")||ol.value(t)<=e};const{Schema:ll,Instance:ml}=Oo;var ul={compile:e=>ll.value(e),interpret:(e,t)=>!ml.typeOf(t,"array")||ml.length(t)>=e};const{Schema:pl,Instance:fl}=Oo;var dl={compile:e=>pl.value(e),interpret:(e,t)=>!fl.typeOf(t,"string")||fl.value(t).length>=e};const{Schema:hl,Instance:yl}=Oo;var vl={compile:e=>hl.value(e),interpret:(e,t)=>!yl.typeOf(t,"string")||[...yl.value(t)].length>=e};const{Schema:gl,Instance:bl}=Oo;var $l={compile:e=>gl.value(e),interpret:(e,t)=>{const n=bl.value(t);return!bl.typeOf(t,"object")||Object.keys(n).length>=e}};const{Schema:Ol,Instance:Il}=Oo;var xl={compile:async(e,t,n)=>{const r=await Ol.step("exclusiveMinimum",n),a=Ol.value(r);return[Ol.value(e),a]},interpret:([e,t],n)=>{if(!Il.typeOf(n,"number"))return!0;const r=Il.value(n);return t?r>e:r>=e}};const{Schema:wl,Instance:Sl}=Oo;var El={compile:async e=>wl.value(e),interpret:(e,t)=>!Sl.typeOf(t,"number")||Sl.value(t)>=e};const{Schema:jl,Instance:Pl}=Oo,Al=(e,t)=>Math.abs(e-t)<1.1920929e-7;var kl={compile:e=>jl.value(e),interpret:(e,t)=>{if(!Pl.typeOf(t,"number"))return!0;const n=Pl.value(t)%e;return Al(0,n)||Al(e,n)}};const{Core:Tl}=Oo;var Cl={compile:Tl.compileSchema,interpret:(e,t,n)=>!Tl.interpretSchema(e,t,n)};const{Core:Nl,Schema:Rl}=Oo;var ql={compile:(e,t)=>Ve.pipeline([Rl.map((async e=>Nl.compileSchema(await e,t))),Ve.all],e),interpret:(e,t,n)=>{let r=0;for(const a of e)if(Nl.interpretSchema(a,t,n)&&r++,r>1)break;return 1===r},collectEvaluatedProperties:(e,t,n)=>{let r=0;return e.reduce(((e,a)=>{if(r>1)return!1;const i=Nl.collectEvaluatedProperties(a,t,n);return i?0==r++&&i:e}),!1)},collectEvaluatedItems:(e,t,n)=>{let r=0;return e.reduce(((e,a)=>{if(r>1)return!1;const i=Nl.collectEvaluatedItems(a,t,n);return"number"==typeof i?0==r++&&i:e}),!1)}};const{Schema:Ml,Instance:Dl}=Oo;var Vl={compile:e=>new RegExp(Ml.value(e),"u"),interpret:(e,t)=>!Dl.typeOf(t,"string")||e.test(Dl.value(t))};const{Core:Ll,Schema:_l,Instance:Jl}=Oo,Fl=(e,t,n)=>!Jl.typeOf(t,"object")||e.every((([e,r])=>Jl.entries(t).filter((([t])=>e.test(t))).every((([,e])=>Ll.interpretSchema(r,e,n)))));var zl={compile:(e,t)=>Ve.pipeline([_l.entries,Ve.map((async([e,n])=>[new RegExp(e,"u"),await Ll.compileSchema(n,t)])),Ve.all],e),interpret:Fl,collectEvaluatedProperties:(e,t,n)=>Fl(e,t,n)&&e.map((([e])=>e))};var Ul={isObject:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,escapeRegExp:e=>e.replace(/[.*+\-?^${}()|[\]\\]/g,"\\$&")};const{Core:Bl,Schema:Kl,Instance:Gl}=Oo,{escapeRegExp:Xl}=Ul,Hl=(e,t,n)=>!Gl.typeOf(t,"object")||Gl.entries(t).filter((([t])=>t in e)).every((([t,r])=>Bl.interpretSchema(e[t],r,n)));var Wl={compile:(e,t)=>Ve.pipeline([Kl.entries,Ve.reduce((async(e,[n,r])=>(e[n]=await Bl.compileSchema(r,t),e)),Object.create(null))],e),interpret:Hl,collectEvaluatedProperties:(e,t,n)=>Hl(e,t,n)&&Object.keys(e).map((e=>new RegExp(`^${Xl(e)}$`)))};const{Core:Zl,Instance:Ql}=Oo;var Yl={compile:(e,t)=>Zl.compileSchema(e,t),interpret:(e,t,n)=>!Ql.typeOf(t,"object")||Ql.keys(t).every((t=>Zl.interpretSchema(e,Ql.cons(t),n)))};const{Core:em}=Oo;var tm={compile:em.compileSchema,interpret:em.interpretSchema,collectEvaluatedProperties:em.collectEvaluatedProperties,collectEvaluatedItems:em.collectEvaluatedItems};const{Core:nm}=Oo;var rm={compile:nm.compileSchema,interpret:nm.interpretSchema,collectEvaluatedProperties:nm.collectEvaluatedProperties,collectEvaluatedItems:nm.collectEvaluatedItems};const{Schema:am,Instance:im}=Oo;var sm={compile:e=>am.value(e),interpret:(e,t)=>!im.typeOf(t,"object")||e.every((e=>im.value(t).hasOwnProperty(e)))};const{Core:om,Schema:cm,Instance:lm}=Oo,mm=(e,t,n)=>!lm.typeOf(t,"array")||lm.every(((t,r)=>!(r in e)||om.interpretSchema(e[r],t,n)),t);var um={compile:(e,t)=>Ve.pipeline([cm.map((e=>om.compileSchema(e,t))),Ve.all],e),interpret:mm,collectEvaluatedItems:(e,t,n)=>mm(e,t,n)&&e.length};const{Schema:pm,Instance:fm}=Oo;var dm={compile:e=>pm.value(e),interpret:(e,t)=>"string"==typeof e?fm.typeOf(t,e):e.some(fm.typeOf(t))};const{Core:hm,Schema:ym,Instance:vm}=Oo,gm=([e,t],n,r)=>{if(!vm.typeOf(n,"array"))return!0;const a=hm.collectEvaluatedItems(e,n,r,!0);return!1===a||vm.filter(((e,t)=>t>=a),n).every((e=>hm.interpretSchema(t,e,r)))};var bm={compile:async(e,t,n)=>[ym.uri(n),await hm.compileSchema(e,t)],interpret:gm,collectEvaluatedItems:(e,t,n)=>gm(e,t,n)&&Number.MAX_SAFE_INTEGER};const{Core:$m,Schema:Om,Instance:Im}=Oo,xm=([e,t],n,r)=>{if(!Im.typeOf(n,"object"))return!0;const a=$m.collectEvaluatedProperties(e,n,r,!0);return!a||Im.entries(n).filter((([e])=>!a.some((t=>e.match(t))))).every((([,e])=>$m.interpretSchema(t,e,r)))};var wm={compile:async(e,t,n)=>[Om.uri(n),await $m.compileSchema(e,t)],interpret:xm,collectEvaluatedProperties:(e,t,n)=>xm(e,t,n)&&[new RegExp("")]};const{Schema:Sm,Instance:Em}=Oo;var jm={compile:e=>Sm.value(e),interpret:(e,t)=>{if(!Em.typeOf(t,"array")||!1===e)return!0;const n=Em.map((e=>on(Em.value(e))),t);return new Set(n).size===n.length}};const{Keywords:Pm}=Oo;var Am={additionalItems:So,additionalItems6:ko,additionalProperties:Ro,additionalProperties6:Lo,allOf:Fo,anyOf:Bo,const:Xo,contains:Zo,containsMinContainsMaxContains:tc,definitions:ac,dependencies:cc,dependentRequired:uc,dependentSchemas:hc,enum:gc,exclusiveMaximum:Oc,exclusiveMinimum:wc,if:Ec,then:kc,else:Rc,items:Lc,itemsFUTURE:Uc,maxItems:Gc,maxLength:Wc,maxLength6:Yc,maxProperties:nl,maximumExclusiveMaximum:il,maximum:cl,metaData:Pm.metaData,minItems:ul,minLength:dl,minLength6:vl,minProperties:$l,minimumExclusiveMinimum:xl,minimum:El,multipleOf:kl,not:Cl,oneOf:ql,pattern:Vl,patternProperties:zl,properties:Wl,propertyNames:Yl,dynamicRef:tm,ref:rm,required:sm,tupleItems:um,type:dm,unevaluatedItems:bm,unevaluatedProperties:wm,uniqueItems:jm,validate:Pm.validate};const{Core:km,Schema:Tm}=Oo,Cm="https://json-schema.org/draft/future/schema";function Nm(e){return{c:p,l:p,m:p,p:p,i:p,o:p,d:p}}function Rm(e){let t,n;return t=new Ki({props:{results:e[4]}}),{c(){S(t.$$.fragment)},l(e){E(t.$$.fragment,e)},m(e,r){j(t,e,r),n=!0},p(e,n){const r={};16&n&&(r.results=e[4]),t.$set(r)},i(e){n||(A(t.$$.fragment,e),n=!0)},o(e){k(t.$$.fragment,e),n=!1},d(e){T(t,e)}}}function qm(e){return{c:p,l:p,m:p,p:p,i:p,o:p,d:p}}function Mm(e){let t,n,p,f,y,v,g,b,$,I,x,C,R,q,M,D,L,_,J,F,z,U,B;function K(t){e[9].call(null,t)}function G(t){e[10].call(null,t)}g=new qi({props:{ns:"schemas",tabs:e[0],newTab:e[5],active:0}}),g.$on("input",e[7]);let X={ns:"instances",tabs:e[1],newTab:e[6]};void 0!==e[2]&&(X.selected=e[2]),void 0!==e[2]&&(X.active=e[2]),I=new qi({props:X}),O.push((()=>w(I,"selected",K))),O.push((()=>w(I,"active",G))),I.$on("input",e[8]),M=new Ki({props:{results:e[3]}});let H={ctx:e,current:null,token:null,hasCatch:!1,pending:qm,then:Rm,catch:Nm,value:12,blocks:[,,,]};return N(J=e[3],H),U=new cs({}),{c(){t=d(),n=r("main"),p=r("h1"),f=a("Hyperjump - JSON Schema Validator"),y=d(),v=r("div"),S(g.$$.fragment),b=d(),$=r("div"),S(I.$$.fragment),R=d(),q=r("div"),S(M.$$.fragment),L=d(),_=r("div"),H.block.c(),z=d(),S(U.$$.fragment),this.h()},l(e){V('[data-svelte="svelte-14138tz"]',document.head).forEach(c),t=h(e),n=i(e,"MAIN",{class:!0});var r=s(n);p=i(r,"H1",{class:!0});var a=s(p);f=o(a,"Hyperjump - JSON Schema Validator"),a.forEach(c),y=h(r),v=i(r,"DIV",{class:!0});var l=s(v);E(g.$$.fragment,l),l.forEach(c),b=h(r),$=i(r,"DIV",{class:!0});var m=s($);E(I.$$.fragment,m),m.forEach(c),R=h(r),q=i(r,"DIV",{class:!0});var u=s(q);E(M.$$.fragment,u),u.forEach(c),L=h(r),_=i(r,"DIV",{class:!0});var d=s(_);H.block.l(d),d.forEach(c),z=h(r),E(U.$$.fragment,r),r.forEach(c),this.h()},h(){document.title="Hyperjump - JSON Schema Validator",l(p,"class","svelte-1fbysc"),l(v,"class","editor-section svelte-1fbysc"),l($,"class","editor-section svelte-1fbysc"),l(q,"class",D="results "+Vm+" svelte-1fbysc"),l(_,"class",F="results "+Vm+" svelte-1fbysc"),l(n,"class","svelte-1fbysc")},m(e,r){m(e,t,r),m(e,n,r),u(n,p),u(p,f),u(n,y),u(n,v),j(g,v,null),u(n,b),u(n,$),j(I,$,null),u(n,R),u(n,q),j(M,q,null),u(n,L),u(n,_),H.block.m(_,H.anchor=null),H.mount=()=>_,H.anchor=null,u(n,z),j(U,n,null),B=!0},p(t,[n]){e=t;const r={};1&n&&(r.tabs=e[0]),g.$set(r);const a={};2&n&&(a.tabs=e[1]),!x&&4&n&&(x=!0,a.selected=e[2],P((()=>x=!1))),!C&&4&n&&(C=!0,a.active=e[2],P((()=>C=!1))),I.$set(a);const i={};if(8&n&&(i.results=e[3]),M.$set(i),H.ctx=e,8&n&&J!==(J=e[3])&&N(J,H));else{const t=e.slice();t[12]=H.resolved,H.block.p(t,n)}},i(e){B||(A(g.$$.fragment,e),A(I.$$.fragment,e),A(M.$$.fragment,e),A(H.block),A(U.$$.fragment,e),B=!0)},o(e){k(g.$$.fragment,e),k(I.$$.fragment,e),k(M.$$.fragment,e);for(let e=0;e<3;e+=1){const t=H.blocks[e];k(t)}k(U.$$.fragment,e),B=!1},d(e){e&&c(t),e&&c(n),T(g),T(I),T(M),H.block.d(),H.token=null,H=null,T(U)}}}Tm.setConfig(Cm,"baseToken","$id"),Tm.setConfig(Cm,"embeddedToken","$id"),Tm.setConfig(Cm,"anchorToken","$anchor"),Tm.setConfig(Cm,"jsrefToken","$ref"),Tm.setConfig(Cm,"dynamicJsrefToken","$dynamicRef"),Tm.setConfig(Cm,"dynamicAnchorToken","$dynamicAnchor"),Tm.setConfig(Cm,"commentToken","$comment"),Tm.setConfig(Cm,"vocabularyToken","$vocabulary"),Tm.setConfig(Cm,"mandatoryVocabularies",["https://json-schema.org/draft/future/vocab/core"]),Tm.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$id": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/future/vocab/core": true,\n        "https://json-schema.org/draft/future/vocab/applicator": true,\n        "https://json-schema.org/draft/future/vocab/validation": true,\n        "https://json-schema.org/draft/future/vocab/meta-data": true,\n        "https://json-schema.org/draft/future/vocab/format": false,\n        "https://json-schema.org/draft/future/vocab/content": true\n    },\n    "$dynamicAnchor": "schema",\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$dynamicRef": "#" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),Tm.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/core",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/future/vocab/core": true\n    },\n    "$dynamicAnchor": "schema",\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z][-A-Za-z0-9.:_]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$dynamicRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recusriveAnchor": {\n            "type": "boolean",\n            "const": true,\n            "default": false\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$dynmaicRef": "#schema" },\n            "default": {}\n        }\n    }\n}')),km.defineVocabulary("https://json-schema.org/draft/future/vocab/core",{validate:Am.validate,$defs:Am.definitions,$dynamicRef:Am.dynamicRef,$ref:Am.ref}),Tm.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/applicator",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/future/vocab/applicator": true\n    },\n    "$dynamicAnchor": "schema",\n\n    "title": "Applicator vocabulary meta-schema",\n    "properties": {\n        "items": { "$dynamicRef": "#schema" },\n        "unevaluatedItems": { "$dynamicRef": "#schema" },\n        "prefixItems": { "$ref": "#/$defs/schemaArray" },\n        "contains": { "$dynamicRef": "#schema" },\n        "additionalProperties": { "$dynamicRef": "#schema" },\n        "unevaluatedProperties": { "$dynamicRef": "#schema" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#schema" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#schema" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$dynamicRef": "#schema"\n            }\n        },\n        "propertyNames": { "$dynamicRef": "#schema" },\n        "if": { "$dynamicRef": "#schema" },\n        "then": { "$dynamicRef": "#schema" },\n        "else": { "$dynamicRef": "#schema" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$dynamicRef": "#schema" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$dynamicRef": "#schema" }\n        }\n    }\n}')),km.defineVocabulary("https://json-schema.org/draft/future/vocab/applicator",{additionalProperties:Am.additionalProperties6,allOf:Am.allOf,anyOf:Am.anyOf,contains:Am.containsMinContainsMaxContains,dependentSchemas:Am.dependentSchemas,if:Am.if,then:Am.then,else:Am.else,items:Am.itemsFUTURE,not:Am.not,oneOf:Am.oneOf,patternProperties:Am.patternProperties,prefixItems:Am.tupleItems,properties:Am.properties,propertyNames:Am.propertyNames,unevaluatedItems:Am.unevaluatedItems,unevaluatedProperties:Am.unevaluatedProperties}),Tm.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/validation",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/future/vocab/validation": true\n    },\n    "$dynamicAnchor": "schema",\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": ["number", "boolean"]\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": ["number", "boolean"]\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "allOf": [\n        {\n            "if": {\n                "properties": {\n                    "exclusiveMinimum": { "type": "boolean" }\n                },\n                "required": ["exclusiveMinimum"]\n            },\n            "then": {\n                "required": ["minimum"]\n            }\n        },\n        {\n            "if": {\n                "properties": {\n                    "exclusiveMaximum": { "type": "boolean" }\n                },\n                "required": ["exclusiveMaximum"]\n            },\n            "then": {\n                "required": ["maximum"]\n            }\n        }\n    ],\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),km.defineVocabulary("https://json-schema.org/draft/future/vocab/validation",{const:Am.const,dependentRequired:Am.dependentRequired,enum:Am.enum,exclusiveMaximum:Am.exclusiveMaximum,exclusiveMinimum:Am.exclusiveMinimum,maxItems:Am.maxItems,maxLength:Am.maxLength6,maxProperties:Am.maxProperties,maximum:Am.maximum,minItems:Am.minItems,minLength:Am.minLength6,minProperties:Am.minProperties,minimum:Am.minimum,multipleOf:Am.multipleOf,pattern:Am.pattern,required:Am.required,type:Am.type,uniqueItems:Am.uniqueItems}),Tm.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/future/vocab/meta-data": true\n    },\n    "$dynamicAnchor": "schema",\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),km.defineVocabulary("https://json-schema.org/draft/future/vocab/meta-data",{default:Am.metaData,deprecated:Am.metaData,description:Am.metaData,examples:Am.metaData,readOnly:Am.metaData,title:Am.metaData,writeOnly:Am.metaData}),Tm.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/format",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/future/vocab/format": true\n    },\n    "$dynamicAnchor": "schema",\n\n    "title": "Format vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),Tm.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/content",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/future/vocab/content": true\n    },\n    "$dynamicAnchor": "schema",\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$dynamicRef": "#schema" }\n    }\n}')),km.defineVocabulary("https://json-schema.org/draft/future/vocab/content",{contentEncoding:Am.metaData,contentMediaType:Am.metaData,contentSchema:Am.metaData});const Dm="https://json-schema.hyperjump.io/schema",Vm="solarized-dark";function Lm(e,t,n){const r=function(){let e=1;return(t,n,r=!1)=>{const a=n||`${Dm}${++e}`;return{label:t||"Schema "+e,text:`{\n  "$id": "${a}",\n  "$schema": "https://json-schema.org/draft/2019-09/schema"\n}`,persistent:r}}}(),a=function(){let e=1;return()=>({label:"Instance "+e++,text:""})}();let i=[r("Schema",Dm,!0)],s=[a("Instance")],o=0;const c=function(e,t){let n;return({detail:r})=>{clearTimeout(n),n=setTimeout((()=>e(r)),t)}},l=c((e=>n(0,i=e)),750),m=c((e=>n(1,s=e)),750);let u,p;return mi.setMetaOutputFormat(mi.BASIC),e.$$.update=()=>{1&e.$$.dirty&&n(3,u=async function(){i.forEach(((e,t)=>{const n=0===t?Dm:"";mi.add(JSON.parse(e.text||"true"),n,"https://json-schema.org/draft/2019-09/schema")}));const e=await mi.get(Dm);return mi.validate(e)}()),14&e.$$.dirty&&n(4,p=async function(){if(""!==s[o].text){let e;try{e=await u}catch(e){}if(e){const t=e(JSON.parse(s[o].text),mi.BASIC);if(t.valid)return t;throw{output:t}}}}())},[i,s,o,u,p,r,a,l,m,function(e){o=e,n(2,o)},function(e){o=e,n(2,o)}]}export default class extends e{constructor(e){super(),t(this,e,Lm,Mm,n,{})}}
