import{S as e,i as n,s as t,e as r,t as a,c as i,a as s,b as o,d as c,f as l,g as u,h as m,n as p,j as f,k as d,l as h,m as y,o as v,p as g,r as $,q as b,u as x,v as O,w as I,x as w,y as j,z as E,A as S,B as P,C as A,D as k,E as N,F as T,G as q,H as R,I as C,J as M,K as D,L as V}from"./client.d31e3b5d.js";var L="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function X(e,n){return e(n={exports:{}},n.exports),n.exports}var J=X(function(e,n){!function(t,r){var a={};t.PubSub=a;var i=t.define;!function(e){var n={},t=-1;function r(e){var n;for(n in e)if(e.hasOwnProperty(n))return!0;return!1}function a(e,n,t){try{e(n,t)}catch(e){setTimeout(function(e){return function(){throw e}}(e),0)}}function i(e,n,t){e(n,t)}function s(e,t,r,s){var o,c=n[t],l=s?i:a;if(n.hasOwnProperty(t))for(o in c)c.hasOwnProperty(o)&&l(c[o],e,r)}function o(e,t,a,i){var o=function(e,n,t){return function(){var r=String(e),a=r.lastIndexOf(".");for(s(e,e,n,t);-1!==a;)r=r.substr(0,a),a=r.lastIndexOf("."),s(e,r,n,t)}}(e="symbol"==typeof e?e.toString():e,t,i),c=function(e){var t=String(e),a=Boolean(n.hasOwnProperty(t)&&r(n[t])),i=t.lastIndexOf(".");for(;!a&&-1!==i;)t=t.substr(0,i),i=t.lastIndexOf("."),a=Boolean(n.hasOwnProperty(t)&&r(n[t]));return a}(e);return!!c&&(!0===a?o():setTimeout(o,0),!0)}e.publish=function(n,t){return o(n,t,!1,e.immediateExceptions)},e.publishSync=function(n,t){return o(n,t,!0,e.immediateExceptions)},e.subscribe=function(e,r){if("function"!=typeof r)return!1;e="symbol"==typeof e?e.toString():e,n.hasOwnProperty(e)||(n[e]={});var a="uid_"+String(++t);return n[e][a]=r,a},e.subscribeOnce=function(n,t){var r=e.subscribe(n,function(){e.unsubscribe(r),t.apply(this,arguments)});return e},e.clearAllSubscriptions=function(){n={}},e.clearSubscriptions=function(e){var t;for(t in n)n.hasOwnProperty(t)&&0===t.indexOf(e)&&delete n[t]},e.countSubscriptions=function(e){var t,r=0;for(t in n)n.hasOwnProperty(t)&&0===t.indexOf(e)&&r++;return r},e.getSubscriptions=function(e){var t,r=[];for(t in n)n.hasOwnProperty(t)&&0===t.indexOf(e)&&r.push(t);return r},e.unsubscribe=function(t){var r,a,i,s="string"==typeof t&&(n.hasOwnProperty(t)||function(e){var t;for(t in n)if(n.hasOwnProperty(t)&&0===t.indexOf(e))return!0;return!1}(t)),o=!s&&"string"==typeof t,c="function"==typeof t,l=!1;if(!s){for(r in n)if(n.hasOwnProperty(r)){if(a=n[r],o&&a[t]){delete a[t],l=t;break}if(c)for(i in a)a.hasOwnProperty(i)&&a[i]===t&&(delete a[i],l=!0)}return l}e.clearSubscriptions(t)}}(a),"function"==typeof i&&i.amd?i(function(){return a}):(void 0!==e&&e.exports&&(n=e.exports=a),n.PubSub=a,e.exports=n=a)}("object"==typeof window&&window||L)}),z=(J.PubSub,function(e,n){return function t(){null==n&&(n=e.length);var r=[].slice.call(arguments);return r.length>=n?e.apply(this,r):function(){return t.apply(this,r.concat([].slice.call(arguments)))}}});const _=e=>{if(e.length>0&&"/"!==e[0])throw Error("Invalid JSON Pointer");return e.split("/").slice(1).map(W)},B=(e,n,t,r)=>{if(0===e.length)return t;if(e.length>1){const a=e.shift();return{...n,[a]:B(e,Q(n,a,r),t,U(a,r))}}if(Array.isArray(n)){const r=[...n];return r[Z(n,e[0])]=t,r}return"object"==typeof n&&null!==n?{...n,[e[0]]:t}:Q(n,e[0],r)},F=(e,n,t,r)=>{if(0!==e.length)if(1!==e.length||Y(n)){const a=e.shift();F(e,Q(n,a,r),t,U(a,r))}else{n[Z(n,e[0])]=t}},G=(e,n,t)=>{if(0!=e.length){if(e.length>1){const r=e.shift(),a=Q(n,r,t);return{...n,[r]:G(e,a,U(r,t))}}if(Array.isArray(n))return n.filter((n,t)=>t!=e[0]);if("object"==typeof n&&null!==n){const{[e[0]]:t,...r}=n;return r}return Q(n,e[0],t)}},K=(e,n,t)=>{if(0!==e.length)if(e.length>1){const r=e.shift(),a=Q(n,r,t);K(e,a,U(r,t))}else Array.isArray(n)?n.splice(e[0],1):"object"==typeof n&&null!==n?delete n[e[0]]:Q(n,e[0],t)},U=z((e,n)=>n+"/"+H(e)),H=e=>e.toString().replace(/~/g,"~0").replace(/\//g,"~1"),W=e=>e.toString().replace(/~1/g,"/").replace(/~0/g,"~"),Z=(e,n)=>Array.isArray(e)&&"-"===n?e.length:n,Q=(e,n,t="")=>{if(void 0===e)throw TypeError(`Value at '${t}' is undefined and does not have property '${n}'`);if(null===e)throw TypeError(`Value at '${t}' is null and does not have property '${n}'`);if(Y(e))throw TypeError(`Value at '${t}' is a ${typeof e} and does not have property '${n}'`);return e[Z(e,n)]},Y=e=>null===e||"object"!=typeof e;var ee={nil:"",append:U,get:(e,n)=>{const t=_(e),r=e=>t.reduce(([e,n],t)=>[Q(e,t,n),U(t,n)],[e,""])[0];return void 0===n?r:r(n)},set:(e,n,t)=>{const r=_(e),a=z((e,n)=>B(r,e,n,""));return void 0===n?a:a(n,t)},assign:(e,n,t)=>{const r=_(e),a=z((e,n)=>F(r,e,n,""));return void 0===n?a:a(n,t)},unset:(e,n)=>{const t=_(e),r=e=>G(t,e,"");return void 0===n?r:r(n)},delete:(e,n)=>{const t=_(e),r=e=>K(t,e,"");return void 0===n?r:r(n)}};const ne={null:e=>null===e,boolean:e=>"boolean"==typeof e,object:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,array:e=>Array.isArray(e),number:e=>"number"==typeof e,integer:e=>Number.isInteger(e),string:e=>"string"==typeof e};var te={jsonTypeOf:(e,n)=>ne[n](e),splitUrl:e=>{const n=e.indexOf("#"),t=-1===n?e.length:n,r=e.slice(0,t),a=e.slice(t+1);return[decodeURI(r),decodeURI(a)]}};const re=Symbol("$__value"),ae=Symbol("$__href"),ie=Symbol("$__isDynamic");var se=(e,n,t=!1)=>Object.freeze({[ae]:e,[re]:n,[ie]:t}),oe=e=>e&&void 0!==e[ae],ce=e=>e[ae],le=e=>e[re],ue=e=>e[ie];const{jsonTypeOf:me}=te,pe=Object.freeze({id:"",pointer:"",instance:void 0,value:void 0}),fe=e=>oe(e.value)?le(e.value):e.value,de=z((e,n)=>me(fe(e),n)),he=(e,n)=>Object.freeze({...n,pointer:ee.append(e,n.pointer),value:fe(n)[e]}),ye=z((e,n)=>fe(n).map((t,r,a,i)=>e(he(r,n),r,a,i))),ve=z((e,n)=>fe(n).map((e,t,r,a)=>he(t,n)).filter((n,t,r,a)=>e(n,t,r,a))),ge=z((e,n,t)=>fe(t).reduce((n,r,a)=>e(n,he(a,t),a),n)),$e=z((e,n)=>fe(n).every((t,r,a,i)=>e(he(r,n),r,a,i))),be=z((e,n)=>fe(n).some((t,r,a,i)=>e(he(r,n),r,a,i)));var xe={cons:(e,n="")=>Object.freeze({...pe,id:n,instance:e,value:e}),uri:e=>`${e.id}#${encodeURI(e.pointer)}`,value:fe,typeOf:de,step:he,entries:e=>Object.keys(fe(e)).map(n=>[n,he(n,e)]),keys:e=>Object.keys(fe(e)),map:ye,filter:ve,reduce:ge,every:$e,some:be,length:e=>fe(e).length},Oe=/; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g,Ie=/^[\u000b\u0020-\u007e\u0080-\u00ff]+$/,we=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/,je=/\\([\u000b\u0020-\u00ff])/g,Ee=/([\\"])/g,Se=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;function Pe(e){var n=String(e);if(we.test(n))return n;if(n.length>0&&!Ie.test(n))throw new TypeError("invalid parameter value");return'"'+n.replace(Ee,"\\$1")+'"'}function Ae(e){this.parameters=Object.create(null),this.type=e}var ke={format:function(e){if(!e||"object"!=typeof e)throw new TypeError("argument obj is required");var n=e.parameters,t=e.type;if(!t||!Se.test(t))throw new TypeError("invalid type");var r=t;if(n&&"object"==typeof n)for(var a,i=Object.keys(n).sort(),s=0;s<i.length;s++){if(a=i[s],!we.test(a))throw new TypeError("invalid parameter name");r+="; "+a+"="+Pe(n[a])}return r},parse:function(e){if(!e)throw new TypeError("argument string is required");var n="object"==typeof e?function(e){var n;"function"==typeof e.getHeader?n=e.getHeader("content-type"):"object"==typeof e.headers&&(n=e.headers&&e.headers["content-type"]);if("string"!=typeof n)throw new TypeError("content-type header is missing from object");return n}(e):e;if("string"!=typeof n)throw new TypeError("argument string is required to be a string");var t=n.indexOf(";"),r=-1!==t?n.substr(0,t).trim():n.trim();if(!Se.test(r))throw new TypeError("invalid media type");var a=new Ae(r.toLowerCase());if(-1!==t){var i,s,o;for(Oe.lastIndex=t;s=Oe.exec(n);){if(s.index!==t)throw new TypeError("invalid parameter format");t+=s[0].length,i=s[1].toLowerCase(),'"'===(o=s[2])[0]&&(o=o.substr(1,o.length-2).replace(je,"$1")),a.parameters[i]=o}if(t!==n.length)throw new TypeError("invalid parameter format")}return a}},Ne=async e=>Object.entries(await e),Te=z(async(e,n)=>(await n).map(e)),qe=z(async(e,n,t)=>(await t).reduce(async(n,t)=>e(await n,t),n)),Re=z(async(e,n,t={})=>qe(async(n,t)=>await e(t)?n.concat([t]):n,[],n,t)),Ce=z(async(e,n)=>{const t=await Te(e,n);return(await Promise.all(t)).some(e=>e)}),Me=z(async(e,n)=>{const t=await Te(e,n);return(await Promise.all(t)).every(e=>e)}),De=z((e,n)=>e.reduce(async(e,n)=>n(await e),n)),Ve={entries:Ne,map:Te,filter:Re,reduce:qe,some:Ce,every:Me,pipeline:De,all:e=>Promise.all(e),allValues:e=>De([Ne,qe(async(e,[n,t])=>(e[n]=await t,e),{})],e)},Le=function(e,n){if(e=e.trim(),(n=n.trim()).startsWith("about:"))return n;const t=function(e){const n={host:"",path:"",query:"",protocol:""};let t=e,r=e.indexOf("//");n.protocol=t.substring(0,r),r+=2;const a=e.indexOf("/",r),i=e.indexOf("?"),s=e.indexOf("#");-1!==s&&(t=t.substring(0,s));if(-1!==i){const e=t.substring(i);n.query=e,t=t.substring(0,i)}if(-1!==a){const e=t.substring(0,a);n.host=e,t=t.substring(a),n.path=t}else n.host=t;return n}(e),r=function(e){const n={href:e,hash:"",query:"",netPath:!1,absolutePath:!1,relativePath:!1};if(ze.test(e))return n.netPath=!0,n;"/"===e[0]?n.absolutePath=!0:""!==e&&(n.relativePath=!0);let t=e;const r=e.indexOf("?"),a=e.indexOf("#");if(-1!==a){const e=t.substring(a);n.hash=e,t=t.substring(0,a)}if(-1!==r){const e=t.substring(r);n.query=e,t=t.substring(0,r)}return n.path=t,n}(n);if(!t.protocol&&!r.netPath)throw new Error("Error, protocol is not specified");if(r.netPath)return r.href.startsWith("//")&&(r.href=t.protocol+r.href),function(e){const n=e.indexOf("//")+2,t=!e.includes("/",n),r=!e.includes("?",n),a=!e.includes("#",n);return t&&r&&a}(r.href)?Xe(r.href):r.href;if(r.absolutePath){const{path:e,query:n,hash:a}=r;return t.host+Je(e)+n+a}if(r.relativePath){const{path:e,query:n,hash:a}=r;let i,s=t.path,o=t.host;return 0===e.length?i=s:(s=s.substring(0,s.lastIndexOf("/")),i=Je(s+"/"+e)),o+=""!==i||n||a?i+n+a:"/"}{const{host:e,path:n,query:a}=t;return n||a?e+n+a+r.hash:Xe(e)}};function Xe(e){return e+("/"===e[e.length-1]?"":"/")}function Je(e){let n=e.split("/");""===n[0]&&(n=n.slice(1));let t=[];return n.forEach((e,r)=>{"."!==e&&(".."===e?t.pop():""===e&&r!==n.length-1||t.push(e))}),"/"+t.join("/")}const ze=new RegExp("^([a-z][a-z0-9+.-]*:)?//","i");var _e=fetch;const{jsonTypeOf:Be,splitUrl:Fe}=te,Ge={},Ke={},Ue=(e,n)=>{const t=e in Ke?Ke[e]:e;if(t in Ge)return Ge[t][n]},He={},We={},Ze=(e,n="",t="")=>{e=JSON.parse(JSON.stringify(e));const r=Fe(e.$schema||t)[0];if(!r)throw Error("Couldn't determine schema version");delete e.$schema;const a=Ue(r,"idToken"),i=Ue(r,"anchorToken"),s=Fe(n)[0];if(!s&&!Fe(e[a]||"")[0])throw Error("Couldn't determine an identifier for the schema");const o=rn(s,e[a]||""),[c,l]=Fe(o);delete e[a],l&&a===i&&(e[i]=i!==a?encodeURI(l):`#${encodeURI(l)}`),s&&(We[s]=c);const u={},m=Ue(r,"recursiveAnchorToken");let p;!0===e[m]&&(u["#"]=c,e[i]="",delete e[m]),Ue(r,"vocabulary")&&Be(e,"object")&&"$vocabulary"in e?(Ke[c]=r,p=e.$vocabulary,delete e.$vocabulary):p=c===r?{[r]:!0}:{};const f={};He[c]={id:c,schemaVersion:r,schema:Qe(e,c,r,ee.nil,f,u),anchors:f,recursiveAnchors:u,vocabulary:p,validated:!1}},Qe=(e,n,t,r,a,i)=>{if(Be(e,"object")){const s="string"==typeof e.$schema?e.$schema:t,o=Ue(s,"idToken"),c=Ue(s,"anchorToken");if("string"==typeof e[o]&&(o!==c||"#"!==e[o][0])){const r=rn(n,e[o]);return e[o]=r,Ze(e,r,t),se(e[o],e)}const l=Ue(t,"anchorToken"),u=Ue(t,"dynamicAnchorToken");"string"==typeof e[u]&&(i[`#${e[u]}`]=n,e[l]=e[u],delete e[u]);const m=Ue(t,"idToken");if("string"==typeof e[l]){const n=l!==m?e[l]:e[l].slice(1);a[n]=r,delete e[l]}const p=Ue(t,"jrefToken");if("string"==typeof e[p])return se(e[p],e);e=Object.entries(e).reduce((e,[s,o])=>(e[s]=Qe(o,n,t,ee.append(s,r),a,i),e),{});const f=Ue(t,"jsrefToken");"string"==typeof e[f]&&(e[f]=se(e[f],e[f]));const d=Ue(t,"dynamicJsrefToken");return"string"==typeof e[d]&&(e[d]=se(e[d],e[d],!0)),e}return Array.isArray(e)?e.map((e,s)=>Qe(e,n,t,ee.append(s,r),a,i)):e},Ye=e=>He[We[e]]||He[e],en=Object.freeze({id:"",schemaVersion:void 0,pointer:"",schema:void 0,recursiveAnchors:{}}),nn=async(e,n=en,t=!1)=>{const r=t&&n.recursiveAnchors[e]?n.recursiveAnchors[e]:on(n),a=rn(r,e),[i,s]=Fe(a);if(!(e=>e in He||e in We)(i)){const e=await _e(i,{headers:{Accept:"application/schema+json"}});if(e.status>=400)throw await e.text(),Error(`Failed to retrieve schema with id: ${i}`);if(e.headers.has("content-type")){const n=ke.parse(e.headers.get("content-type")).type;if("application/schema+json"!==n)throw Error(`${i} is not a schema. Found a document with media type: ${n}`)}Ze(await e.json(),i)}const o=Ye(i),c=s&&"/"!==s[0]?sn(o,s):s,l=Object.freeze({id:o.id,schemaVersion:o.schemaVersion,vocabulary:o.vocabulary,pointer:c,schema:o.schema,value:ee.get(c,o.schema),recursiveAnchors:{...o.recursiveAnchors,...n.recursiveAnchors},validated:o.validated});return tn(l)},tn=e=>oe(e.value)?nn(ce(e.value),e,ue(e.value)):e,rn=(e,n)=>{const t=Le(e,n),r=Fe(e)[0];if(r&&"file"===an(t)&&"file"!==an(r))throw Error(`Can't access file '${t}' resource from network context '${e}'`);return t},an=e=>{const n=e.match(/^(.+):\/\//);return n?n[1]:""},sn=(e,n)=>{if(!(n in e.anchors))throw Error(`No such anchor '${encodeURI(e.id)}#${encodeURI(n)}'`);return e.anchors[n]},on=e=>`${e.id}#${encodeURI(e.pointer)}`,cn=e=>oe(e.value)?le(e.value):e.value,ln=(e,n)=>{const t=Ye(n.id),r=Object.freeze({id:n.id,schemaVersion:n.schemaVersion,vocabulary:n.vocabulary,pointer:ee.append(e,n.pointer),schema:t.schema,value:cn(n)[e],recursiveAnchors:n.recursiveAnchors,validated:t.validated});return tn(r)},un=z((e,n)=>Ve.pipeline([cn,Ve.map(async(t,r)=>e(await ln(r,n),r)),Ve.all],n));var mn={setConfig:(e,n,t)=>{Ge[e]||(Ge[e]={}),Ge[e][n]=t},getConfig:Ue,add:Ze,get:nn,markValidated:e=>{He[e].validated=!0},uri:on,value:cn,typeOf:(e,n)=>Be(cn(e),n),has:(e,n)=>e in cn(n),step:ln,keys:e=>Object.keys(cn(e)),entries:e=>Ve.pipeline([cn,Object.keys,Ve.map(async n=>[n,await ln(n,e)]),Ve.all],e),map:un,length:e=>cn(e).length};var pn=class extends Error{constructor(e){super("Invalid Schema"),this.name=this.constructor.name,this.output=e}};const fn="FLAG",dn="BASIC",hn="DETAILED",yn="VERBOSE";let vn=hn,gn=!0;const $n=(e,n)=>(t,r=fn)=>{if(![fn,dn,hn,yn].includes(r))throw Error(`The '${r}' error format is not supported`);let a=[];const i=J.subscribe("result",bn(r,a));return An(n,t,e),J.unsubscribe(i),a[0]},bn=(e,n)=>{const t=[];return(r,a)=>{const i={...a,errors:[]};for(;t.length>0&&xn(t[t.length-1],i);){const n=t.pop();let r=[];if(e===dn&&(r=n.errors,delete n.errors),i.errors.unshift(n,...r),On(i))break}(e===yn||e!==fn&&!i.valid)&&t.push(i),n[0]=i}},xn=(e,n)=>e.instanceLocation.startsWith(n.instanceLocation)&&(e.absoluteKeywordLocation.startsWith(n.absoluteKeywordLocation)||On(e)),On=e=>e.keyword.endsWith("#$ref")||e.keyword.endsWith("#$recursiveRef"),In={},wn=e=>In[e],jn=e=>e in In,En={},Sn={},Pn=async(e,n)=>{if(!jn(`${e.schemaVersion}#validate`)){const n=await mn.get(e.schemaVersion);(mn.getConfig(n.id,"mandatoryVocabularies")||[]).forEach(e=>{if(!n.vocabulary[e])throw Error(`Vocabulary '${e}' must be explicitly declared and required`)}),Object.entries(n.vocabulary).forEach(([e,t])=>{if(e in En)Object.entries(En[e]).forEach(([e,t])=>{((e,n)=>{In[e]={collectEvaluatedItems:(e,t,r)=>n.interpret(e,t,r)&&0,collectEvaluatedProperties:(e,t,r)=>n.interpret(e,t,r)&&[],...n}})(`${n.id}#${e}`,t)});else if(t)throw Error(`Missing required vocabulary: ${e}`)})}if(gn&&!e.validated){if(mn.markValidated(e.id),!(e.schemaVersion in Sn)){const n=await mn.get(e.schemaVersion),t={},r=await Pn(n,t);Sn[n.id]=$n(t,r)}const n=xe.cons(e.schema,e.id),t=Sn[e.schemaVersion](n,vn);if(!t.valid)throw new pn(t)}return await wn(`${e.schemaVersion}#validate`).compile(e,n),mn.uri(e)},An=(e,n,t)=>{const[r]=t[e];return wn(r).interpret(e,n,t)};var kn={validate:async(e,n,t)=>{const r={},a=await Pn(e,r),i=(e,n=fn)=>$n(r,a)(xe.cons(e),n);return void 0===n?i:i(n,t)},setMetaOutputFormat:e=>{vn=e},setShouldMetaValidate:e=>{gn=e},FLAG:fn,BASIC:dn,DETAILED:hn,VERBOSE:yn,getKeyword:wn,hasKeyword:jn,defineVocabulary:(e,n)=>{En[e]=n},compileSchema:Pn,interpretSchema:An,collectEvaluatedProperties:(e,n,t,r)=>{const[a]=t[e];return wn(a).collectEvaluatedProperties(e,n,t,r)},collectEvaluatedItems:(e,n,t,r)=>{const[a]=t[e];return wn(a).collectEvaluatedItems(e,n,t,r)}};var Nn={compile:async(e,n)=>{const t=mn.uri(e);if(!(t in n)){n[t]=!1;const r=mn.value(e);n[t]=[`${e.schemaVersion}#validate`,mn.uri(e),"boolean"==typeof r?r:await Ve.pipeline([mn.entries,Ve.map(([n,t])=>[`${e.schemaVersion}#${n}`,t]),Ve.filter(([n])=>kn.hasKeyword(n)&&n!==`${e.schemaVersion}#validate`),Ve.map(async([t,r])=>{const a=await kn.getKeyword(t).compile(r,n,e);return[t,mn.uri(r),a]}),Ve.all],e)]}},interpret:(e,n,t)=>{const[r,a,i]=t[e],s="boolean"==typeof i?i:i.every(([e,r,a])=>{const i=kn.getKeyword(e).interpret(a,n,t);return J.publishSync("result",{keyword:e,absoluteKeywordLocation:r,instanceLocation:xe.uri(n),valid:i}),i});return J.publishSync("result",{keyword:r,absoluteKeywordLocation:a,instanceLocation:xe.uri(n),valid:s}),s},collectEvaluatedProperties:(e,n,t,r=!1)=>{const a=t[e][2];return"boolean"==typeof a?!!a&&[]:a.filter(([e])=>!r||!e.endsWith("#unevaluatedProperties")).reduce((e,[r,,a])=>{const i=e&&kn.getKeyword(r).collectEvaluatedProperties(a,n,t);return i&&e.concat(i)},[])},collectEvaluatedItems:(e,n,t,r=!1)=>{const a=t[e][2];return"boolean"==typeof a?!!a&&[]:a.filter(([e])=>!r||!e.endsWith("#unevaluatedItems")).reduce((e,[r,,a])=>{const i=!1!==e&&kn.getKeyword(r).collectEvaluatedItems(a,n,t);return!1!==i&&Math.max(e,i)},0)}},Tn={Core:kn,Schema:mn,Instance:xe,Keywords:{metaData:{compile:()=>void 0,interpret:()=>!0},validate:Nn}},qn=Tn.Core,Rn=Tn.Schema;const{Core:Cn,Schema:Mn,Instance:Dn}=Tn;var Vn={compile:async(e,n,t)=>{const r=await Mn.step("items",t),a=Mn.typeOf(r,"array")?Mn.length(r):Number.MAX_SAFE_INTEGER;return Mn.typeOf(e,"boolean")?[a,Mn.value(e)]:[a,await Cn.compileSchema(e,n)]},interpret:([e,n],t,r)=>!Dn.typeOf(t,"array")||("string"==typeof n?Dn.every((t,a)=>a<e||Cn.interpretSchema(n,t,r),t):Dn.every((t,r)=>r<e||n,t))};const{Core:Ln,Schema:Xn,Instance:Jn}=Tn,zn=([e,n],t,r)=>!Jn.typeOf(t,"array")||Jn.every((t,a)=>a<e||Ln.interpretSchema(n,t,r),t);var _n={compile:async(e,n,t)=>{const r=await Xn.step("items",t);return[Xn.typeOf(r,"array")?Xn.length(r):Number.MAX_SAFE_INTEGER,await Ln.compileSchema(e,n)]},interpret:zn,collectEvaluatedItems:(e,n,t)=>zn(e,n,t)&&Number.MAX_SAFE_INTEGER};const{Core:Bn,Schema:Fn,Instance:Gn}=Tn;var Kn={compile:async(e,n,t)=>{const r=await Fn.step("properties",t),a=Fn.typeOf(r,"object")?Fn.keys(r):[],i=await Fn.step("patternProperties",t),s=Fn.typeOf(i,"object")?Fn.keys(i).map(e=>new RegExp(e)):[];return Fn.typeOf(e,"boolean")?[a,s,Fn.value(e)]:[a,s,await Bn.compileSchema(e,n)]},interpret:([e,n,t],r,a)=>{if(!Gn.typeOf(r,"object"))return!0;const i=Gn.entries(r).filter(([t])=>!e.includes(t)&&!n.some(e=>e.test(t)));return"string"==typeof t?i.every(([,e])=>Bn.interpretSchema(t,e,a)):0===i.length||t}};const{Core:Un,Schema:Hn,Instance:Wn}=Tn,Zn=([e,n,t],r,a)=>!Wn.typeOf(r,"object")||Wn.entries(r).filter(([t])=>!e.includes(t)&&!n.some(e=>e.test(t))).every(([,e])=>Un.interpretSchema(t,e,a));var Qn={compile:async(e,n,t)=>{const r=await Hn.step("properties",t),a=Hn.typeOf(r,"object")?Hn.keys(r):[],i=await Hn.step("patternProperties",t);return[a,Hn.typeOf(i,"object")?Hn.keys(i).map(e=>new RegExp(e)):[],await Un.compileSchema(e,n)]},interpret:Zn,collectEvaluatedProperties:(e,n,t)=>Zn(e,n,t)&&[new RegExp("")]};const{Core:Yn,Schema:et}=Tn;var nt={compile:(e,n)=>Ve.pipeline([et.map(async e=>Yn.compileSchema(await e,n)),Ve.all],e),interpret:(e,n,t)=>e.every(e=>Yn.interpretSchema(e,n,t)),collectEvaluatedProperties:(e,n,t)=>e.reduce((e,r)=>{const a=e&&Yn.collectEvaluatedProperties(r,n,t);return a&&e.concat(a)},[]),collectEvaluatedItems:(e,n,t)=>e.reduce((e,r)=>{const a=!1!==e&&Yn.collectEvaluatedItems(r,n,t);return!1!==a&&Math.max(e,a)},0)};const{Core:tt,Schema:rt}=Tn;var at={compile:(e,n)=>Ve.pipeline([rt.map(async e=>tt.compileSchema(await e,n)),Ve.all],e),interpret:(e,n,t)=>e.some(e=>tt.interpretSchema(e,n,t)),collectEvaluatedProperties:(e,n,t)=>e.reduce((e,r)=>{const a=tt.collectEvaluatedProperties(r,n,t);return a?(e||[]).concat(a):e},!1),collectEvaluatedItems:(e,n,t)=>e.reduce((e,r)=>{const a=tt.collectEvaluatedItems(r,n,t);return!1!==a?Math.max(e,a):e},!1)},it=Object.keys,st=JSON.stringify;var ot=function(e){return""+function e(n,t){var r,a,i,s,o,c,l;if("string"==(l=typeof n))return st(n);if(!0===n)return"true";if(!1===n)return"false";if(null===n)return"null";if(n instanceof Array){for(i="[",a=n.length-1,r=0;r<a;r++)i+=e(n[r],!1)+",";return a>-1&&(i+=e(n[r],!1)),i+"]"}if(n instanceof Object){if("function"==typeof n.toJSON)return e(n.toJSON(),t);for(a=(s=it(n).sort()).length,i="",r=0;r<a;)void 0!==(c=e(n[o=s[r]],!0))&&(r&&""!==i&&(i+=","),i+=st(o)+":"+c),r++;return"{"+i+"}"}switch(l){case"function":case"undefined":return t?void 0:null;default:return isFinite(n)?n:null}}(e,!1)};const{Schema:ct,Instance:lt}=Tn;var ut={compile:e=>ot(ct.value(e)),interpret:(e,n)=>ot(lt.value(n))===e};const{Core:mt,Instance:pt}=Tn;var ft={compile:(e,n)=>mt.compileSchema(e,n),interpret:(e,n,t)=>!pt.typeOf(n,"array")||pt.some(n=>mt.interpretSchema(e,n,t),n)};const{Core:dt,Schema:ht,Instance:yt}=Tn;var vt={compile:async(e,n,t)=>{const r=await dt.compileSchema(e,n),a=await ht.step("minContains",t),i=ht.typeOf(a,"number")?ht.value(a):1,s=await ht.step("maxContains",t);return{contains:r,minContains:i,maxContains:ht.typeOf(s,"number")?ht.value(s):Number.MAX_SAFE_INTEGER}},interpret:({contains:e,minContains:n,maxContains:t},r,a)=>{if(!yt.typeOf(r,"array"))return!0;const i=yt.reduce((n,t)=>dt.interpretSchema(e,t,a)?n+1:n,0,r);return i>=n&&i<=t}};const{Core:gt,Schema:$t}=Tn;var bt={compile:async(e,n)=>{await Ve.pipeline([$t.entries,Ve.map(([,e])=>gt.compileSchema(e,n)),Ve.all],e)},interpret:()=>!0};const{Core:xt,Schema:Ot,Instance:It}=Tn;var wt={compile:(e,n)=>Ve.pipeline([Ot.entries,Ve.map(async([e,t])=>[e,Ot.typeOf(t,"array")?Ot.value(t):await xt.compileSchema(t,n)]),Ve.all],e),interpret:(e,n,t)=>{const r=It.value(n);return!It.typeOf(n,"object")||e.every(([e,a])=>!(e in r)||(Array.isArray(a)?a.every(e=>e in r):xt.interpretSchema(a,n,t)))}};const{Schema:jt,Instance:Et}=Tn;var St={compile:e=>Ve.pipeline([jt.entries,Ve.map(([e,n])=>[e,jt.value(n)]),Ve.all],e),interpret:(e,n)=>{const t=Et.value(n);return!Et.typeOf(n,"object")||e.every(([e,n])=>!(e in t)||n.every(e=>e in t))}};const{Core:Pt,Schema:At,Instance:kt}=Tn;var Nt={compile:(e,n)=>Ve.pipeline([At.entries,Ve.map(async([e,t])=>[e,await Pt.compileSchema(t,n)]),Ve.all],e),interpret:(e,n,t)=>{const r=kt.value(n);return!kt.typeOf(n,"object")||e.every(([e,a])=>!(e in r)||Pt.interpretSchema(a,n,t))},collectEvaluatedProperties:(e,n,t)=>{const r=kt.value(n);return e.reduce((e,[a,i])=>{if(!(e&&a in r))return e;const s=Pt.collectEvaluatedProperties(i,n,t);return s&&e.concat(s)},[])}};const{Schema:Tt,Instance:qt}=Tn;var Rt={compile:e=>Tt.value(e).map(ot),interpret:(e,n)=>e.some(e=>ot(qt.value(n))===e)};const{Schema:Ct,Instance:Mt}=Tn;var Dt={compile:async e=>Ct.value(e),interpret:(e,n)=>!Mt.typeOf(n,"number")||Mt.value(n)<e};const{Schema:Vt,Instance:Lt}=Tn;var Xt={compile:async e=>Vt.value(e),interpret:(e,n)=>!Lt.typeOf(n,"number")||Lt.value(n)>e};const{Schema:Jt,Instance:zt}=Tn;var _t={compile:async e=>Jt.value(e),interpret:(e,n)=>!zt.typeOf(n,"number")||"boolean"==typeof e||zt.value(n)<e};const{Schema:Bt,Instance:Ft}=Tn;var Gt={compile:async e=>Bt.value(e),interpret:(e,n)=>!Ft.typeOf(n,"number")||"boolean"==typeof e||Ft.value(n)>e};const{Core:Kt,Schema:Ut}=Tn;var Ht={compile:async(e,n,t)=>{const r={};if(r.if=await Kt.compileSchema(e,n),Ut.has("then",t)){const e=await Ut.step("then",t);r.then=await Kt.compileSchema(e,n)}if(Ut.has("else",t)){const e=await Ut.step("else",t);r.else=await Kt.compileSchema(e,n)}return r},interpret:(e,n,t)=>Kt.interpretSchema(e.if,n,t)?!("then"in e)||Kt.interpretSchema(e.then,n,t):!("else"in e)||Kt.interpretSchema(e.else,n,t),collectEvaluatedProperties:(e,n,t)=>{const r=Kt.collectEvaluatedProperties(e.if,n,t),a=r?"then":"else";if(e[a]){const i=Kt.collectEvaluatedProperties(e[a],n,t);return i&&(r||[]).concat(i)}return r||[]},collectEvaluatedItems:(e,n,t)=>{const r=Kt.collectEvaluatedItems(e.if,n,t),a="number"==typeof r?"then":"else";if(e[a]){const i=Kt.collectEvaluatedItems(e[a],n,t);return!1!==i&&Math.max(r,i)}return r||0}};const{Core:Wt,Schema:Zt,Instance:Qt}=Tn,Yt=(e,n,t)=>!Qt.typeOf(n,"array")||("string"==typeof e?Qt.every(n=>Wt.interpretSchema(e,n,t),n):Qt.every((n,r)=>!(r in e)||Wt.interpretSchema(e[r],n,t),n));var er={compile:(e,n)=>Zt.typeOf(e,"array")?Ve.pipeline([Zt.map(e=>Wt.compileSchema(e,n)),Ve.all],e):Wt.compileSchema(e,n),interpret:Yt,collectEvaluatedItems:(e,n,t)=>Yt(e,n,t)&&("string"==typeof e?Number.MAX_SAFE_INTEGER:e.length)};const{Schema:nr,Instance:tr}=Tn;var rr={compile:e=>nr.value(e),interpret:(e,n)=>!tr.typeOf(n,"array")||tr.length(n)<=e};const{Schema:ar,Instance:ir}=Tn;var sr={compile:e=>ar.value(e),interpret:(e,n)=>!ir.typeOf(n,"string")||ir.length(n)<=e};const{Schema:or,Instance:cr}=Tn;var lr={compile:e=>or.value(e),interpret:(e,n)=>!cr.typeOf(n,"string")||[...cr.value(n)].length<=e};const{Schema:ur,Instance:mr}=Tn;var pr={compile:e=>ur.value(e),interpret:(e,n)=>!mr.typeOf(n,"object")||mr.keys(n).length<=e};const{Schema:fr,Instance:dr}=Tn;var hr={compile:async(e,n,t)=>{const r=await fr.step("exclusiveMaximum",t),a=fr.value(r);return[fr.value(e),a]},interpret:([e,n],t)=>{if(!dr.typeOf(t,"number"))return!0;const r=dr.value(t);return n?r<e:r<=e}};const{Schema:yr,Instance:vr}=Tn;var gr={compile:async(e,n,t)=>{const r=await yr.step("exclusiveMaximum",t),a=!!yr.typeOf(r,"boolean")&&yr.value(r);return[yr.value(e),a]},interpret:([e,n],t)=>{if(!vr.typeOf(t,"number"))return!0;const r=vr.value(t);return n?r<e:r<=e}};const{Schema:$r,Instance:br}=Tn;var xr={compile:async e=>$r.value(e),interpret:(e,n)=>!br.typeOf(n,"number")||br.value(n)<=e};const{Schema:Or,Instance:Ir}=Tn;var wr={compile:e=>Or.value(e),interpret:(e,n)=>!Ir.typeOf(n,"array")||Ir.length(n)>=e};const{Schema:jr,Instance:Er}=Tn;var Sr={compile:e=>jr.value(e),interpret:(e,n)=>!Er.typeOf(n,"string")||Er.value(n).length>=e};const{Schema:Pr,Instance:Ar}=Tn;var kr={compile:e=>Pr.value(e),interpret:(e,n)=>!Ar.typeOf(n,"string")||[...Ar.value(n)].length>=e};const{Schema:Nr,Instance:Tr}=Tn;var qr={compile:e=>Nr.value(e),interpret:(e,n)=>{const t=Tr.value(n);return!Tr.typeOf(n,"object")||Object.keys(t).length>=e}};const{Schema:Rr,Instance:Cr}=Tn;var Mr={compile:async(e,n,t)=>{const r=await Rr.step("exclusiveMinimum",t),a=Rr.value(r);return[Rr.value(e),a]},interpret:([e,n],t)=>{if(!Cr.typeOf(t,"number"))return!0;const r=Cr.value(t);return n?r>e:r>=e}};const{Schema:Dr,Instance:Vr}=Tn;var Lr={compile:async(e,n,t)=>{const r=await Dr.step("exclusiveMinimum",t),a=!!Dr.typeOf(r,"boolean")&&Dr.value(r);return[Dr.value(e),a]},interpret:([e,n],t)=>{if(!Vr.typeOf(t,"number"))return!0;const r=Vr.value(t);return n?r>e:r>=e}};const{Schema:Xr,Instance:Jr}=Tn;var zr={compile:async e=>Xr.value(e),interpret:(e,n)=>!Jr.typeOf(n,"number")||Jr.value(n)>=e};const{Schema:_r,Instance:Br}=Tn,Fr=(e,n)=>Math.abs(e-n)<Number.EPSILON;var Gr={compile:e=>_r.value(e),interpret:(e,n)=>{if(!Br.typeOf(n,"number"))return!0;const t=Br.value(n)%e;return Fr(0,t)||Fr(e,t)}};const{Core:Kr}=Tn;var Ur={compile:Kr.compileSchema,interpret:(e,n,t)=>!Kr.interpretSchema(e,n,t)};const{Core:Hr,Schema:Wr}=Tn;var Zr={compile:(e,n)=>Ve.pipeline([Wr.map(async e=>Hr.compileSchema(await e,n)),Ve.all],e),interpret:(e,n,t)=>{let r=0;for(const a of e)if(Hr.interpretSchema(a,n,t)&&r++,r>1)break;return 1===r},collectEvaluatedProperties:(e,n,t)=>{let r=0;return e.reduce((e,a)=>{if(r>1)return!1;const i=Hr.collectEvaluatedProperties(a,n,t);return i?0==r++&&i:e},!1)},collectEvaluatedItems:(e,n,t)=>{let r=0;return e.reduce((e,a)=>{if(r>1)return!1;const i=Hr.collectEvaluatedItems(a,n,t);return"number"==typeof i?0==r++&&i:e},!1)}};const{Schema:Qr,Instance:Yr}=Tn;var ea={compile:e=>new RegExp(Qr.value(e),"u"),interpret:(e,n)=>!Yr.typeOf(n,"string")||e.test(Yr.value(n))};const{Core:na,Schema:ta,Instance:ra}=Tn,aa=(e,n,t)=>!ra.typeOf(n,"object")||e.every(([e,r])=>ra.entries(n).filter(([n])=>e.test(n)).every(([,e])=>na.interpretSchema(r,e,t)));var ia={compile:(e,n)=>Ve.pipeline([ta.entries,Ve.map(async([e,t])=>[new RegExp(e,"u"),await na.compileSchema(t,n)]),Ve.all],e),interpret:aa,collectEvaluatedProperties:(e,n,t)=>aa(e,n,t)&&e.map(([e])=>e)};var sa={isObject:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,escapeRegExp:e=>e.replace(/[.*+\-?^${}()|[\]\\]/g,"\\$&")};const{Core:oa,Schema:ca,Instance:la}=Tn,{escapeRegExp:ua}=sa,ma=(e,n,t)=>!la.typeOf(n,"object")||la.entries(n).filter(([n])=>n in e).every(([n,r])=>oa.interpretSchema(e[n],r,t));var pa={compile:(e,n)=>Ve.pipeline([ca.entries,Ve.reduce(async(e,[t,r])=>(e[t]=await oa.compileSchema(r,n),e),{})],e),interpret:ma,collectEvaluatedProperties:(e,n,t)=>ma(e,n,t)&&Object.keys(e).map(e=>new RegExp(`^${ua(e)}$`))};const{Core:fa,Instance:da}=Tn;var ha={compile:(e,n)=>fa.compileSchema(e,n),interpret:(e,n,t)=>!da.typeOf(n,"object")||da.keys(n).every(n=>fa.interpretSchema(e,da.cons(n),t))};const{Core:ya}=Tn;var va={compile:ya.compileSchema,interpret:ya.interpretSchema,collectEvaluatedProperties:ya.collectEvaluatedProperties,collectEvaluatedItems:ya.collectEvaluatedItems};const{Core:ga}=Tn;var $a={compile:ga.compileSchema,interpret:ga.interpretSchema,collectEvaluatedProperties:ga.collectEvaluatedProperties,collectEvaluatedItems:ga.collectEvaluatedItems};const{Schema:ba,Instance:xa}=Tn;var Oa={compile:e=>ba.value(e),interpret:(e,n)=>!xa.typeOf(n,"object")||e.every(e=>e in xa.value(n))};const{Schema:Ia,Instance:wa}=Tn;var ja={compile:e=>Ia.value(e),interpret:(e,n)=>"string"==typeof e?wa.typeOf(n,e):e.some(wa.typeOf(n))};const{Core:Ea,Schema:Sa,Instance:Pa}=Tn,Aa=([e,n],t,r)=>{if(!Pa.typeOf(t,"array"))return!0;const a=Ea.collectEvaluatedItems(e,t,r,!0);return!1===a||Pa.filter((e,n)=>n>=a,t).every(e=>Ea.interpretSchema(n,e,r))};var ka={compile:async(e,n,t)=>[Sa.uri(t),await Ea.compileSchema(e,n)],interpret:Aa,collectEvaluatedItems:(e,n,t)=>Aa(e,n,t)&&Number.MAX_SAFE_INTEGER};const{Core:Na,Schema:Ta,Instance:qa}=Tn,Ra=([e,n],t,r)=>{if(!qa.typeOf(t,"object"))return!0;const a=Na.collectEvaluatedProperties(e,t,r,!0);return!a||qa.entries(t).filter(([e])=>!a.some(n=>e.match(n))).every(([,e])=>Na.interpretSchema(n,e,r))};var Ca={compile:async(e,n,t)=>[Ta.uri(t),await Na.compileSchema(e,n)],interpret:Ra,collectEvaluatedProperties:(e,n,t)=>Ra(e,n,t)&&[new RegExp("")]};const{Schema:Ma,Instance:Da}=Tn;var Va={compile:e=>Ma.value(e),interpret:(e,n)=>{if(!Da.typeOf(n,"array")||!1===e)return!0;const t=Da.map(e=>ot(Da.value(e)),n);return new Set(t).size===t.length}};const{Keywords:La}=Tn;var Xa={additionalItems:Vn,additionalItems6:_n,additionalProperties:Kn,additionalProperties6:Qn,allOf:nt,anyOf:at,const:ut,contains:ft,containsMinContainsMaxContains:vt,definitions:bt,dependencies:wt,dependentRequired:St,dependentSchemas:Nt,enum:Rt,exclusiveMaximum:Dt,exclusiveMinimum:Xt,exclusiveMaximumOas31:_t,exclusiveMinimumOas31:Gt,ifThenElse:Ht,items:er,maxItems:rr,maxLength:sr,maxLength6:lr,maxProperties:pr,maximumExclusiveMaximum:hr,maximumExclusiveMaximumOas31:gr,maximum:xr,metaData:La.metaData,minItems:wr,minLength:Sr,minLength6:kr,minProperties:qr,minimumExclusiveMinimum:Mr,minimumExclusiveMinimumOas31:Lr,minimum:zr,multipleOf:Gr,not:Ur,oneOf:Zr,pattern:ea,patternProperties:ia,properties:pa,propertyNames:ha,$recursiveRef:va,$ref:$a,required:Oa,type:ja,unevaluatedItems:ka,unevaluatedProperties:Ca,uniqueItems:Va,validate:La.validate};const{Core:Ja,Schema:za}=Tn,_a="http://json-schema.org/draft-04/schema";za.setConfig(_a,"jrefToken","$ref"),za.setConfig(_a,"idToken","id"),za.setConfig(_a,"anchorToken","id"),za.add(JSON.parse('{\n    "id": "http://json-schema.org/draft-04/schema#",\n    "$schema": "http://json-schema.org/draft-04/schema#",\n    "description": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "positiveInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "positiveIntegerDefault0": {\n            "allOf": [ { "$ref": "#/definitions/positiveInteger" }, { "default": 0 } ]\n        },\n        "simpleTypes": {\n            "enum": [ "array", "boolean", "integer", "null", "number", "object", "string" ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "minItems": 1,\n            "uniqueItems": true\n        }\n    },\n    "type": "object",\n    "properties": {\n        "id": {\n            "type": "string"\n        },\n        "$schema": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "multipleOf": {\n            "type": "number",\n            "minimum": 0,\n            "exclusiveMinimum": true\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "boolean",\n            "default": false\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxLength": { "$ref": "#/definitions/positiveInteger" },\n        "minLength": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/positiveInteger" },\n        "minItems": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxProperties": { "$ref": "#/definitions/positiveInteger" },\n        "minProperties": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "dependencies": {\n        "exclusiveMaximum": [ "maximum" ],\n        "exclusiveMinimum": [ "minimum" ]\n    },\n    "default": {}\n}')),Ja.defineVocabulary(_a,{validate:Xa.validate,additionalItems:Xa.additionalItems,additionalProperties:Xa.additionalProperties,allOf:Xa.allOf,anyOf:Xa.anyOf,default:Xa.metaData,definitions:Xa.definitions,dependencies:Xa.dependencies,description:Xa.metaData,enum:Xa.enum,format:Xa.metaData,items:Xa.items,maxItems:Xa.maxItems,maxLength:Xa.maxLength,maxProperties:Xa.maxProperties,maximum:Xa.maximumExclusiveMaximum,minItems:Xa.minItems,minLength:Xa.minLength,minProperties:Xa.minProperties,minimum:Xa.minimumExclusiveMinimum,multipleOf:Xa.multipleOf,not:Xa.not,oneOf:Xa.oneOf,pattern:Xa.pattern,patternProperties:Xa.patternProperties,properties:Xa.properties,required:Xa.required,title:Xa.metaData,type:Xa.type,uniqueItems:Xa.uniqueItems});const Ba="http://json-schema.org/draft-04/hyper-schema";za.setConfig(Ba,"jrefToken","$ref"),za.setConfig(Ba,"idToken","id"),za.setConfig(Ba,"anchorToken","id"),za.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-04/hyper-schema#",\n    "id": "http://json-schema.org/draft-04/hyper-schema#",\n    "title": "JSON Hyper-Schema",\n    "allOf": [\n        {"$ref": "http://json-schema.org/draft-04/schema#"}\n    ],\n    "properties": {\n        "additionalItems": {\n            "anyOf": [\n                {"type": "boolean"},\n                {"$ref": "#"}\n            ]\n        },\n        "additionalProperties": {\n            "anyOf": [\n                {"type": "boolean"},\n                {"$ref": "#"}\n            ]\n        },\n        "dependencies": {\n            "additionalProperties": {\n                "anyOf": [\n                    {"$ref": "#"},\n                    {"type": "array"}\n                ]\n            }\n        },\n        "items": {\n            "anyOf": [\n                {"$ref": "#"},\n                {"$ref": "#/definitions/schemaArray"}\n            ]\n        },\n        "definitions": {\n            "additionalProperties": {"$ref": "#"}\n        },\n        "patternProperties": {\n            "additionalProperties": {"$ref": "#"}\n        },\n        "properties": {\n            "additionalProperties": {"$ref": "#"}\n        },\n        "allOf": {"$ref": "#/definitions/schemaArray"},\n        "anyOf": {"$ref": "#/definitions/schemaArray"},\n        "oneOf": {"$ref": "#/definitions/schemaArray"},\n        "not": { "$ref": "#" },\n\n        "links": {\n            "type": "array",\n            "items": {"$ref": "#/definitions/linkDescription"}\n        },\n        "fragmentResolution": {\n            "type": "string"\n        },\n        "media": {\n            "type": "object",\n            "properties": {\n                "type": {\n                    "description": "A media type, as described in RFC 2046",\n                    "type": "string"\n                },\n                "binaryEncoding": {\n                    "description": "A content encoding scheme, as described in RFC 2045",\n                    "type": "string"\n                }\n            }\n        },\n        "pathStart": {\n            "description": "Instances\' URIs must start with this value for this schema to apply to them",\n            "type": "string",\n            "format": "uri"\n        }\n    },\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "items": {"$ref": "#"}\n        },\n        "linkDescription": {\n            "title": "Link Description Object",\n            "type": "object",\n            "required": ["href", "rel"],\n            "properties": {\n                "href": {\n                    "description": "a URI template, as defined by RFC 6570, with the addition of the $, ( and ) characters for pre-processing",\n                    "type": "string"\n                },\n                "rel": {\n                    "description": "relation to the target resource of the link",\n                    "type": "string"\n                },\n                "title": {\n                    "description": "a title for the link",\n                    "type": "string"\n                },\n                "targetSchema": {\n                    "description": "JSON Schema describing the link target",\n                    "$ref": "#"\n                },\n                "mediaType": {\n                    "description": "media type (as defined by RFC 2046) describing the link target",\n                    "type": "string"\n                },\n                "method": {\n                    "description": "method for requesting the target of the link (e.g. for HTTP this might be \\"GET\\" or \\"DELETE\\")",\n                    "type": "string"\n                },\n                "encType": {\n                    "description": "The media type in which to submit data along with the request",\n                    "type": "string",\n                    "default": "application/json"\n                },\n                "schema": {\n                    "description": "Schema describing the data to submit along with the request",\n                    "$ref": "#"\n                }\n            }\n        },\n        "readOnly": {\n            "description": "If true, indicates that the value of this property is controlled by the server.",\n            "type": "boolean",\n            "default": false\n        }\n    },\n    "links": [\n        {\n            "rel": "self",\n            "href": "{+id}"\n        },\n        {\n            "rel": "full",\n            "href": "{+($ref)}"\n        }\n    ]\n}')),Ja.defineVocabulary(Ba,{validate:Xa.validate,additionalItems:Xa.additionalItems,additionalProperties:Xa.additionalProperties,allOf:Xa.allOf,anyOf:Xa.anyOf,default:Xa.metaData,definitions:Xa.definitions,dependencies:Xa.dependencies,description:Xa.metaData,enum:Xa.enum,format:Xa.metaData,fragmentResolution:Xa.metaData,items:Xa.items,maxItems:Xa.maxItems,minProperties:Xa.minProperties,maxProperties:Xa.maxProperties,maximum:Xa.maximumExclusiveMaximum,media:Xa.metaData,minItems:Xa.minItems,minLength:Xa.minLength,maxLength:Xa.maxLength,minimum:Xa.minimumExclusiveMinimum,multipleOf:Xa.multipleOf,links:Xa.metaData,not:Xa.not,oneOf:Xa.oneOf,pathStart:Xa.metaData,pattern:Xa.pattern,patternProperties:Xa.patternProperties,properties:Xa.properties,readOnly:Xa.metaData,required:Xa.required,title:Xa.metaData,type:Xa.type,uniqueItems:Xa.uniqueItems});const{Core:Fa,Schema:Ga}=Tn,Ka="http://json-schema.org/draft-06/schema";Ga.setConfig(Ka,"jrefToken","$ref"),Ga.setConfig(Ka,"idToken","$id"),Ga.setConfig(Ka,"anchorToken","$id"),Ga.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-06/schema#",\n    "$id": "http://json-schema.org/draft-06/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "examples": {\n            "type": "array",\n            "items": {}\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": {},\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": {}\n}')),Fa.defineVocabulary(Ka,{validate:Xa.validate,additionalItems:Xa.additionalItems6,additionalProperties:Xa.additionalProperties6,allOf:Xa.allOf,anyOf:Xa.anyOf,const:Xa.const,contains:Xa.contains,default:Xa.metaData,definitions:Xa.definitions,dependencies:Xa.dependencies,description:Xa.metaData,enum:Xa.enum,examples:Xa.metaData,exclusiveMaximum:Xa.exclusiveMaximum,exclusiveMinimum:Xa.exclusiveMinimum,format:Xa.metaData,items:Xa.items,maxItems:Xa.maxItems,maxLength:Xa.maxLength6,maxProperties:Xa.maxProperties,maximum:Xa.maximum,minItems:Xa.minItems,minLength:Xa.minLength6,minProperties:Xa.minProperties,minimum:Xa.minimum,multipleOf:Xa.multipleOf,not:Xa.not,oneOf:Xa.oneOf,pattern:Xa.pattern,patternProperties:Xa.patternProperties,properties:Xa.properties,propertyNames:Xa.propertyNames,required:Xa.required,title:Xa.metaData,type:Xa.type,uniqueItems:Xa.uniqueItems});const{Core:Ua,Schema:Ha}=Tn,Wa="http://json-schema.org/draft-07/schema";Ha.setConfig(Wa,"jrefToken","$ref"),Ha.setConfig(Wa,"idToken","$id"),Ha.setConfig(Wa,"anchorToken","$id"),Ha.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-07/schema#",\n    "$id": "http://json-schema.org/draft-07/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": true\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true,\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "if": { "$ref": "#" },\n        "then": { "$ref": "#" },\n        "else": { "$ref": "#" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": true\n}')),Ua.defineVocabulary(Wa,{validate:Xa.validate,additionalItems:Xa.additionalItems6,additionalProperties:Xa.additionalProperties6,allOf:Xa.allOf,anyOf:Xa.anyOf,const:Xa.const,contains:Xa.contains,default:Xa.metaData,definitions:Xa.definitions,dependencies:Xa.dependencies,description:Xa.metaData,enum:Xa.enum,exclusiveMaximum:Xa.exclusiveMaximum,exclusiveMinimum:Xa.exclusiveMinimum,format:Xa.metaData,if:Xa.ifThenElse,items:Xa.items,maxItems:Xa.maxItems,maxLength:Xa.maxLength6,maxProperties:Xa.maxProperties,maximum:Xa.maximum,minItems:Xa.minItems,minLength:Xa.minLength6,minProperties:Xa.minProperties,minimum:Xa.minimum,multipleOf:Xa.multipleOf,not:Xa.not,oneOf:Xa.oneOf,pattern:Xa.pattern,patternProperties:Xa.patternProperties,properties:Xa.properties,propertyNames:Xa.propertyNames,readOnly:Xa.metaData,required:Xa.required,title:Xa.metaData,type:Xa.type,uniqueItems:Xa.uniqueItems,writeOnly:Xa.metaData});const{Core:Za,Schema:Qa}=Tn,Ya="https://json-schema.org/draft/2019-09/schema";Qa.setConfig(Ya,"idToken","$id"),Qa.setConfig(Ya,"anchorToken","$anchor"),Qa.setConfig(Ya,"jsrefToken","$ref"),Qa.setConfig(Ya,"dynamicJsrefToken","$recursiveRef"),Qa.setConfig(Ya,"recursiveAnchorToken","$recursiveAnchor"),Qa.setConfig(Ya,"commentToken","$comment"),Qa.setConfig(Ya,"vocabulary",!0),Qa.setConfig(Ya,"mandatoryVocabularies",["https://json-schema.org/draft/2019-09/vocab/core"]),Qa.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$id": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/core": true,\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true,\n        "https://json-schema.org/draft/2019-09/vocab/validation": true,\n        "https://json-schema.org/draft/2019-09/vocab/meta-data": true,\n        "https://json-schema.org/draft/2019-09/vocab/format": false,\n        "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$recursiveRef": "#" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),Qa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/core",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/core": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z][-A-Za-z0-9.:_]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveAnchor": {\n            "type": "boolean",\n            "const": true,\n            "default": false\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        }\n    }\n}')),Za.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/core",{validate:Xa.validate,$defs:Xa.definitions,$recursiveRef:Xa.$recursiveRef,$ref:Xa.$ref}),Qa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/applicator",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/applicator": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Applicator vocabulary meta-schema",\n    "properties": {\n        "additionalItems": { "$recursiveRef": "#" },\n        "unevaluatedItems": { "$recursiveRef": "#" },\n        "items": {\n            "anyOf": [\n                { "$recursiveRef": "#" },\n                { "$ref": "#/$defs/schemaArray" }\n            ]\n        },\n        "contains": { "$recursiveRef": "#" },\n        "additionalProperties": { "$recursiveRef": "#" },\n        "unevaluatedProperties": { "$recursiveRef": "#" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$recursiveRef": "#"\n            }\n        },\n        "propertyNames": { "$recursiveRef": "#" },\n        "if": { "$recursiveRef": "#" },\n        "then": { "$recursiveRef": "#" },\n        "else": { "$recursiveRef": "#" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$recursiveRef": "#" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$recursiveRef": "#" }\n        }\n    }\n}')),Za.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/applicator",{additionalItems:Xa.additionalItems6,additionalProperties:Xa.additionalProperties6,allOf:Xa.allOf,anyOf:Xa.anyOf,contains:Xa.containsMinContainsMaxContains,dependentSchemas:Xa.dependentSchemas,if:Xa.ifThenElse,items:Xa.items,not:Xa.not,oneOf:Xa.oneOf,patternProperties:Xa.patternProperties,properties:Xa.properties,propertyNames:Xa.propertyNames,unevaluatedItems:Xa.unevaluatedItems,unevaluatedProperties:Xa.unevaluatedProperties}),Qa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/validation",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/validation": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": ["number", "boolean"]\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": ["number", "boolean"]\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "allOf": [\n        {\n            "if": {\n                "properties": {\n                    "exclusiveMinimum": { "type": "boolean" }\n                },\n                "required": ["exclusiveMinimum"]\n            },\n            "then": {\n                "required": ["minimum"]\n            }\n        },\n        {\n            "if": {\n                "properties": {\n                    "exclusiveMaximum": { "type": "boolean" }\n                },\n                "required": ["exclusiveMaximum"]\n            },\n            "then": {\n                "required": ["maximum"]\n            }\n        }\n    ],\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),Za.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/validation",{const:Xa.const,dependentRequired:Xa.dependentRequired,enum:Xa.enum,exclusiveMaximum:Xa.exclusiveMaximum,exclusiveMinimum:Xa.exclusiveMinimum,maxItems:Xa.maxItems,maxLength:Xa.maxLength6,maxProperties:Xa.maxProperties,maximum:Xa.maximum,minItems:Xa.minItems,minLength:Xa.minLength6,minProperties:Xa.minProperties,minimum:Xa.minimum,multipleOf:Xa.multipleOf,pattern:Xa.pattern,required:Xa.required,type:Xa.type,uniqueItems:Xa.uniqueItems}),Qa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/meta-data": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),Za.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/meta-data",{default:Xa.metaData,deprecated:Xa.metaData,description:Xa.metaData,examples:Xa.metaData,readOnly:Xa.metaData,title:Xa.metaData,writeOnly:Xa.metaData}),Qa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/format",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/format": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Format vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),Qa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/content",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$recursiveRef": "#" }\n    }\n}')),Za.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/content",{contentEncoding:Xa.metaData,contentMediaType:Xa.metaData,contentSchema:Xa.metaData});const{Core:ei,Schema:ni}=Tn;ni.add(JSON.parse('{\n    "$id": "https://spec.openapis.org/oas/3.1/meta/schema-object/2019-10",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/core": true,\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true,\n        "https://json-schema.org/draft/2019-09/vocab/meta-data": true,\n        "https://json-schema.org/draft/2019-09/vocab/format": false,\n        "https://json-schema.org/draft/2019-09/vocab/content": true,\n        "https://spec.openapis.org/oas/3.1/vocab/validation/2019-10": true,\n        "https://spec.openapis.org/oas/3.1/vocab/extensions/2019-10": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "https://json-schema.org/draft/2019-09/meta/core"},\n        {"$ref": "https://json-schema.org/draft/2019-09/meta/applicator"},\n        {"$ref": "https://json-schema.org/draft/2019-09/meta/meta-data"},\n        {"$ref": "https://json-schema.org/draft/2019-09/meta/format"},\n        {"$ref": "https://json-schema.org/draft/2019-09/meta/content"},\n        {"$ref": "https://spec.openapis.org/oas/3.1/meta/validation/2019-10"},\n        {"$ref": "https://spec.openapis.org/oas/3.1/meta/extensions/2019-10"}\n    ],\n    "type": ["object", "boolean"],\n    "unevaluatedProperties": false\n}')),ni.add(JSON.parse('{\n    "$id": "https://spec.openapis.org/oas/3.1/meta/validation/2019-10",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/validation": true\n    },\n    "$recursiveAnchor": true,\n\n    "$comment": "This is an alternate meta-schema for the standard validation vocabulary.  It is identical to the standard validation meta-schema except that it modifies minimum, maximum, exclusiveMinimum and exclusiveMaximum",\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": ["number", "boolean"]\n        },\n        "exclusiveMaximum": {\n            "type": ["number", "boolean"]\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "allOf": [\n        {\n            "if": {\n                "required": ["exclusiveMinimum"],\n                "properties": {\n                    "exclusiveMinimum": {"type": "boolean"}\n                }\n            },\n            "then": {\n                "required": ["minimum"]\n            }\n        },\n        {\n            "if": {\n                "required": ["exclusiveMaximum"],\n                "properties": {\n                    "exclusiveMaximum": {"type": "boolean"}\n                }\n            },\n            "then": {\n                "required": ["maximum"]\n            }\n        }\n    ],\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),ei.defineVocabulary("https://spec.openapis.org/oas/3.1/vocab/validation/2019-10",{const:Xa.const,dependentRequired:Xa.dependentRequired,enum:Xa.enum,exclusiveMaximum:Xa.exclusiveMaximumOas31,exclusiveMinimum:Xa.exclusiveMinimumOas31,maxItems:Xa.maxItems,maxLength:Xa.maxLength6,maxProperties:Xa.maxProperties,maximum:Xa.maximumExclusiveMaximumOas31,minItems:Xa.minItems,minLength:Xa.minLength6,minProperties:Xa.minProperties,minimum:Xa.minimumExclusiveMinimumOas31,multipleOf:Xa.multipleOf,pattern:Xa.pattern,required:Xa.required,type:Xa.type,uniqueItems:Xa.uniqueItems}),ni.add(JSON.parse('{\n    "$id": "https://spec.openapis.org/oas/3.1/meta/extensions/2019-10",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://spec.openapis.org/oas/3.1/vocab/extensions/2019-10": true\n    },\n    "$recursiveAnchor": true,\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "example": true,\n        "nullable": {\n            "type": "boolean",\n            "default": false\n        },\n        "discriminator": {\n            "$ref": "#/$defs/Discriminator"\n        },\n        "externalDocs": {\n            "$ref": "#/$defs/ExternalDocs"\n        },\n        "xml": {\n            "$ref": "#/$defs/Xml"\n        }\n    },\n    "patternProperties": {\n        "^x-": true\n    },\n    "$defs": {\n        "Discriminator": {\n            "type": "object",\n            "required": ["propertyName"],\n            "properties": {\n                "propertyName": {\n                    "type": "string"\n                },\n                "mapping": {\n                    "additionalProperties": {\n                        "type": "string"\n                    }\n                }\n            },\n            "additionalProperties": false\n        },\n        "ExternalDocs": {\n            "type": "object",\n            "required": ["url"],\n            "properties": {\n                "url": {\n                    "type": "string",\n                    "format": "uri-reference"\n                },\n                "description": {\n                    "type": "string"\n                }\n            },\n            "patternProperties": {\n                "^x-": true\n            },\n            "additionalProperties": false\n        },\n        "Xml": {\n            "type": "object",\n            "properties": {\n                "name": {\n                    "type": "string"\n                },\n                "namespace": {\n                    "type": "string",\n                    "format": "uri"\n                },\n                "prefix": {\n                    "type": "string"\n                },\n                "attribute": {\n                    "type": "boolean"\n                },\n                "wrapped": {\n                    "type": "boolean"\n                }\n            },\n            "patternProperties": {\n                "^x-": true\n            },\n            "additionalProperties": false\n        }\n    }\n}')),ei.defineVocabulary("https://spec.openapis.org/oas/3.1/vocab/extensions/2019-10",{discriminator:Xa.metaData,example:Xa.metaData,externalDocs:Xa.metaData,nullable:Xa.metaData,xml:Xa.metaData});const{Core:ti,Schema:ri}=Tn;var ai={add:ri.add,get:ri.get,validate:ti.validate,setMetaOutputFormat:ti.setMetaOutputFormat,setShouldMetaValidate:ti.setShouldMetaValidate,FLAG:ti.FLAG,BASIC:ti.BASIC,DETAILED:ti.DETAILED,VERBOSE:ti.VERBOSE};const ii='(?:\\\\["\\/\\\\brfnt]|\\\\u[0-9a-fA-F]{4}|[^"\\\\])',si=`"${ii}*"`,oi=`"${ii}*"(?=\\s*:)`;var ci=X(function(e){var n,t;n=L,t=function(){var e=Object.prototype.hasOwnProperty,n=Object.prototype.toString,t="boolean"==typeof(new RegExp).sticky;function r(e){return e&&"[object RegExp]"===n.call(e)}function a(e){return e&&"object"==typeof e&&!r(e)&&!Array.isArray(e)}function i(e){return"("+e+")"}function s(e){return e.length?"(?:"+e.map(function(e){return"(?:"+e+")"}).join("|")+")":"(?!)"}function o(e){if("string"==typeof e)return"(?:"+e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")+")";if(r(e)){if(e.ignoreCase)throw new Error("RegExp /i flag not allowed");if(e.global)throw new Error("RegExp /g flag is implied");if(e.sticky)throw new Error("RegExp /y flag is implied");if(e.multiline)throw new Error("RegExp /m flag is implied");return e.source}throw new Error("Not a pattern: "+e)}function c(n,t){if(a(t)||(t={match:t}),t.include)throw new Error("Matching rules cannot also include states");var i={defaultType:n,lineBreaks:!!t.error||!!t.fallback,pop:!1,next:null,push:null,error:!1,fallback:!1,value:null,type:null,shouldThrow:!1};for(var s in t)e.call(t,s)&&(i[s]=t[s]);if("string"==typeof i.type&&n!==i.type)throw new Error("Type transform cannot be a string (type '"+i.type+"' for token '"+n+"')");var o=i.match;return i.match=Array.isArray(o)?o:o?[o]:[],i.match.sort(function(e,n){return r(e)&&r(n)?0:r(n)?-1:r(e)?1:n.length-e.length}),i}function l(e){return Array.isArray(e)?function(e){for(var n=[],t=0;t<e.length;t++){var r=e[t];if(r.include)for(var a=[].concat(r.include),i=0;i<a.length;i++)n.push({include:a[i]});else{if(!r.type)throw new Error("Rule has no type: "+JSON.stringify(r));n.push(c(r.type,r))}}return n}(e):function(e){for(var n=Object.getOwnPropertyNames(e),t=[],r=0;r<n.length;r++){var i=n[r],s=e[i],o=[].concat(s);if("include"!==i){var l=[];o.forEach(function(e){a(e)?(l.length&&t.push(c(i,l)),t.push(c(i,e)),l=[]):l.push(e)}),l.length&&t.push(c(i,l))}else for(var u=0;u<o.length;u++)t.push({include:o[u]})}return t}(e)}var u=c("error",{lineBreaks:!0,shouldThrow:!0});function m(e,n){for(var a=null,c=Object.create(null),l=!0,m=null,p=[],f=[],d=0;d<e.length;d++)e[d].fallback&&(l=!1);for(d=0;d<e.length;d++){var h=e[d];if(h.include)throw new Error("Inheritance is not allowed in stateless lexers");if(h.error||h.fallback){if(a)throw!h.fallback==!a.fallback?new Error("Multiple "+(h.fallback?"fallback":"error")+" rules not allowed (for token '"+h.defaultType+"')"):new Error("fallback and error are mutually exclusive (for token '"+h.defaultType+"')");a=h}var y=h.match.slice();if(l)for(;y.length&&"string"==typeof y[0]&&1===y[0].length;){c[y.shift().charCodeAt(0)]=h}if(h.pop||h.push||h.next){if(!n)throw new Error("State-switching options are not allowed in stateless lexers (for token '"+h.defaultType+"')");if(h.fallback)throw new Error("State-switching options are not allowed on fallback tokens (for token '"+h.defaultType+"')")}if(0!==y.length){l=!1,p.push(h);for(var v=0;v<y.length;v++){var g=y[v];if(r(g))if(null===m)m=g.unicode;else if(m!==g.unicode&&!1===h.fallback)throw new Error("If one rule is /u then all must be")}var $=s(y.map(o)),b=new RegExp($);if(b.test(""))throw new Error("RegExp matches empty string: "+b);if(new RegExp("|"+$).exec("").length-1>0)throw new Error("RegExp has capture groups: "+b+"\nUse (?:  ) instead");if(!h.lineBreaks&&b.test("\n"))throw new Error("Rule should declare lineBreaks: "+b);f.push(i($))}}var x=a&&a.fallback,O=t&&!x?"ym":"gm",I=t||x?"":"|";return!0===m&&(O+="u"),{regexp:new RegExp(s(f)+I,O),groups:p,fast:c,error:a||u}}function p(e,n,t){var r=e&&(e.push||e.next);if(r&&!t[r])throw new Error("Missing state '"+r+"' (in token '"+e.defaultType+"' of state '"+n+"')");if(e&&e.pop&&1!=+e.pop)throw new Error("pop must be 1 (in token '"+e.defaultType+"' of state '"+n+"')")}var f=function(e,n){this.startState=n,this.states=e,this.buffer="",this.stack=[],this.reset()};f.prototype.reset=function(e,n){return this.buffer=e||"",this.index=0,this.line=n?n.line:1,this.col=n?n.col:1,this.queuedToken=n?n.queuedToken:null,this.queuedThrow=n?n.queuedThrow:null,this.setState(n?n.state:this.startState),this.stack=n&&n.stack?n.stack.slice():[],this},f.prototype.save=function(){return{line:this.line,col:this.col,state:this.state,stack:this.stack.slice(),queuedToken:this.queuedToken,queuedThrow:this.queuedThrow}},f.prototype.setState=function(e){if(e&&this.state!==e){this.state=e;var n=this.states[e];this.groups=n.groups,this.error=n.error,this.re=n.regexp,this.fast=n.fast}},f.prototype.popState=function(){this.setState(this.stack.pop())},f.prototype.pushState=function(e){this.stack.push(this.state),this.setState(e)};var d=t?function(e,n){return e.exec(n)}:function(e,n){var t=e.exec(n);return 0===t[0].length?null:t};function h(){return this.value}if(f.prototype._getGroup=function(e){for(var n=this.groups.length,t=0;t<n;t++)if(void 0!==e[t+1])return this.groups[t];throw new Error("Cannot find token type for matched text")},f.prototype.next=function(){var e=this.index;if(this.queuedGroup){var n=this._token(this.queuedGroup,this.queuedText,e);return this.queuedGroup=null,this.queuedText="",n}var t=this.buffer;if(e!==t.length){if(s=this.fast[t.charCodeAt(e)])return this._token(s,t.charAt(e),e);var r=this.re;r.lastIndex=e;var a=d(r,t),i=this.error;if(null==a)return this._token(i,t.slice(e,t.length),e);var s=this._getGroup(a),o=a[0];return i.fallback&&a.index!==e?(this.queuedGroup=s,this.queuedText=o,this._token(i,t.slice(e,a.index),e)):this._token(s,o,e)}},f.prototype._token=function(e,n,t){var r=0;if(e.lineBreaks){var a=/\n/g,i=1;if("\n"===n)r=1;else for(;a.exec(n);)r++,i=a.lastIndex}var s={type:"function"==typeof e.type&&e.type(n)||e.defaultType,value:"function"==typeof e.value?e.value(n):n,text:n,toString:h,offset:t,lineBreaks:r,line:this.line,col:this.col},o=n.length;if(this.index+=o,this.line+=r,0!==r?this.col=o-i+1:this.col+=o,e.shouldThrow)throw new Error(this.formatError(s,"invalid syntax"));return e.pop?this.popState():e.push?this.pushState(e.push):e.next&&this.setState(e.next),s},"undefined"!=typeof Symbol&&Symbol.iterator){var y=function(e){this.lexer=e};y.prototype.next=function(){var e=this.lexer.next();return{value:e,done:!e}},y.prototype[Symbol.iterator]=function(){return this},f.prototype[Symbol.iterator]=function(){return new y(this)}}return f.prototype.formatError=function(e,n){if(null==e){var t=this.buffer.slice(this.index);e={text:t,offset:this.index,lineBreaks:-1===t.indexOf("\n")?0:1,line:this.line,col:this.col}}var r=Math.max(0,e.offset-e.col+1),a=e.lineBreaks?e.text.indexOf("\n"):e.text.length,i=this.buffer.substring(r,e.offset+a);return n+=" at line "+e.line+" col "+e.col+":\n\n",n+="  "+i+"\n",n+="  "+Array(e.col).join(" ")+"^"},f.prototype.clone=function(){return new f(this.states,this.state)},f.prototype.has=function(e){return!0},{compile:function(e){var n=m(l(e));return new f({start:n},"start")},states:function(e,n){var t=e.$all?l(e.$all):[];delete e.$all;var r=Object.getOwnPropertyNames(e);n||(n=r[0]);for(var a=Object.create(null),i=0;i<r.length;i++)a[$=r[i]]=l(e[$]).concat(t);for(i=0;i<r.length;i++)for(var s=a[$=r[i]],o=Object.create(null),c=0;c<s.length;c++){var u=s[c];if(u.include){var d=[c,1];if(u.include!==$&&!o[u.include]){o[u.include]=!0;var h=a[u.include];if(!h)throw new Error("Cannot include nonexistent state '"+u.include+"' (in state '"+$+"')");for(var y=0;y<h.length;y++){var v=h[y];-1===s.indexOf(v)&&d.push(v)}}s.splice.apply(s,d),c--}}var g=Object.create(null);for(i=0;i<r.length;i++){var $;g[$=r[i]]=m(a[$],!0)}for(i=0;i<r.length;i++){var b=r[i],x=g[b],O=x.groups;for(c=0;c<O.length;c++)p(O[c],b,g);var I=Object.getOwnPropertyNames(x.fast);for(c=0;c<I.length;c++)p(x.fast[I[c]],b,g)}return new f(g,n)},error:Object.freeze({error:!0}),fallback:Object.freeze({fallback:!0}),keywords:function(e){for(var n=Object.create(null),t=Object.create(null),r=Object.getOwnPropertyNames(e),a=0;a<r.length;a++){var i=r[a],s=e[i];(Array.isArray(s)?s:[s]).forEach(function(e){if((t[e.length]=t[e.length]||[]).push(e),"string"!=typeof e)throw new Error("keyword must be string (in keyword '"+i+"')");n[e]=i})}function o(e){return JSON.stringify(e)}var c="";for(var l in c+="switch (value.length) {\n",t){var u=t[l];c+="case "+l+":\n",c+="switch (value) {\n",u.forEach(function(e){var t=n[e];c+="case "+o(e)+": return "+o(t)+"\n"}),c+="}\n"}return c+="}\n",Function("value",c)}}},e.exports?e.exports=t():n.moo=t()}).compile({WS:{match:/(?:(?:\r?\n)|[ \t])+/,lineBreaks:!0},punctuation:/[:,]/,number:new RegExp("-?(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][-+][0-9]+)?"),property:new RegExp(oi),string:new RegExp(si),grouping:["{","}","[","]"],boolean:["true","false"],null:["null"],other:/./});function li(e,n,t){const r=e.slice();return r[6]=n[t],r}function ui(e,n,t){const r=e.slice();return r[9]=n[t],r[11]=t,r}function mi(e){let n,t,f=e[11]+1+"";return{c(){n=r("div"),t=a(f),this.h()},l(e){n=i(e,"DIV",{class:!0});var r=s(n);t=o(r,f),r.forEach(c),this.h()},h(){l(n,"class","svelte-l280wh")},m(e,r){u(e,n,r),m(n,t)},p:p,d(e){e&&c(n)}}}function pi(e){let n,t=e[6].value+"";return{c(){n=a(t)},l(e){n=o(e,t)},m(e,t){u(e,n,t)},p(e,r){8&r&&t!==(t=e[6].value+"")&&x(n,t)},d(e){e&&c(n)}}}function fi(e){let n,t,p=e[6].value+"";return{c(){n=r("span"),t=a(p),this.h()},l(e){n=i(e,"SPAN",{class:!0});var r=s(n);t=o(r,p),r.forEach(c),this.h()},h(){l(n,"class","null svelte-l280wh")},m(e,r){u(e,n,r),m(n,t)},p(e,n){8&n&&p!==(p=e[6].value+"")&&x(t,p)},d(e){e&&c(n)}}}function di(e){let n,t,p=e[6].value+"";return{c(){n=r("span"),t=a(p),this.h()},l(e){n=i(e,"SPAN",{class:!0});var r=s(n);t=o(r,p),r.forEach(c),this.h()},h(){l(n,"class","boolean svelte-l280wh")},m(e,r){u(e,n,r),m(n,t)},p(e,n){8&n&&p!==(p=e[6].value+"")&&x(t,p)},d(e){e&&c(n)}}}function hi(e){let n,t,p=e[6].value+"";return{c(){n=r("span"),t=a(p),this.h()},l(e){n=i(e,"SPAN",{class:!0});var r=s(n);t=o(r,p),r.forEach(c),this.h()},h(){l(n,"class","number svelte-l280wh")},m(e,r){u(e,n,r),m(n,t)},p(e,n){8&n&&p!==(p=e[6].value+"")&&x(t,p)},d(e){e&&c(n)}}}function yi(e){let n,t,p,f,d=e[6].value.substring(1,e[6].value.length-1)+"";return{c(){n=a('"'),t=r("span"),p=a(d),f=a('"'),this.h()},l(e){n=o(e,'"'),t=i(e,"SPAN",{class:!0});var r=s(t);p=o(r,d),r.forEach(c),f=o(e,'"'),this.h()},h(){l(t,"class","string svelte-l280wh")},m(e,r){u(e,n,r),u(e,t,r),m(t,p),u(e,f,r)},p(e,n){8&n&&d!==(d=e[6].value.substring(1,e[6].value.length-1)+"")&&x(p,d)},d(e){e&&c(n),e&&c(t),e&&c(f)}}}function vi(e){let n,t,p,f,d=e[6].value.substring(1,e[6].value.length-1)+"";return{c(){n=a('"'),t=r("span"),p=a(d),f=a('"'),this.h()},l(e){n=o(e,'"'),t=i(e,"SPAN",{class:!0});var r=s(t);p=o(r,d),r.forEach(c),f=o(e,'"'),this.h()},h(){l(t,"class","property svelte-l280wh")},m(e,r){u(e,n,r),u(e,t,r),m(t,p),u(e,f,r)},p(e,n){8&n&&d!==(d=e[6].value.substring(1,e[6].value.length-1)+"")&&x(p,d)},d(e){e&&c(n),e&&c(t),e&&c(f)}}}function gi(e){let n,t,p=e[6].value+"";return{c(){n=r("span"),t=a(p),this.h()},l(e){n=i(e,"SPAN",{class:!0});var r=s(n);t=o(r,p),r.forEach(c),this.h()},h(){l(n,"class","grouping svelte-l280wh")},m(e,r){u(e,n,r),m(n,t)},p(e,n){8&n&&p!==(p=e[6].value+"")&&x(t,p)},d(e){e&&c(n)}}}function $i(e){let n;function t(e,n){return"grouping"===e[6].type?gi:"property"===e[6].type?vi:"string"===e[6].type?yi:"number"===e[6].type?hi:"boolean"===e[6].type?di:"null"===e[6].type?fi:pi}let r=t(e),a=r(e);return{c(){a.c(),n=f()},l(e){a.l(e),n=f()},m(e,t){a.m(e,t),u(e,n,t)},p(e,i){r===(r=t(e))&&a?a.p(e,i):(a.d(1),(a=r(e))&&(a.c(),a.m(n.parentNode,n)))},d(e){a.d(e),e&&c(n)}}}function bi(e){let n,t,a,o,f,b,x,O,I,w,j=[...Array(e[2])],E=[];for(let n=0;n<j.length;n+=1)E[n]=mi(ui(e,j,n));let S=e[3],P=[];for(let n=0;n<S.length;n+=1)P[n]=$i(li(e,S,n));return{c(){n=r("div"),t=r("div");for(let e=0;e<E.length;e+=1)E[e].c();a=d(),o=r("div"),f=r("pre");for(let e=0;e<P.length;e+=1)P[e].c();b=d(),x=r("textarea"),this.h()},l(e){n=i(e,"DIV",{class:!0});var r=s(n);t=i(r,"DIV",{class:!0});var l=s(t);for(let e=0;e<E.length;e+=1)E[e].l(l);l.forEach(c),a=h(r),o=i(r,"DIV",{class:!0});var u=s(o);f=i(u,"PRE",{class:!0});var m=s(f);for(let e=0;e<P.length;e+=1)P[e].l(m);m.forEach(c),b=h(u),x=i(u,"TEXTAREA",{class:!0,"aria-label":!0}),s(x).forEach(c),u.forEach(c),r.forEach(c),this.h()},h(){l(t,"class","line-numbers svelte-l280wh"),l(f,"class","highlighted svelte-l280wh"),l(x,"class","src svelte-l280wh"),l(x,"aria-label","Code Editor"),l(o,"class","editable svelte-l280wh"),l(n,"class",O="Editor "+e[1]+" svelte-l280wh")},m(r,i){u(r,n,i),m(n,t);for(let e=0;e<E.length;e+=1)E[e].m(t,null);m(n,a),m(n,o),m(o,f);for(let e=0;e<P.length;e+=1)P[e].m(f,null);m(o,b),m(o,x),y(x,e[0]),I||(w=[v(x,"input",e[5]),v(x,"input",e[4])],I=!0)},p(e,[r]){if(4&r){let n;for(j=[...Array(e[2])],n=0;n<j.length;n+=1){const a=ui(e,j,n);E[n]?E[n].p(a,r):(E[n]=mi(a),E[n].c(),E[n].m(t,null))}for(;n<E.length;n+=1)E[n].d(1);E.length=j.length}if(8&r){let n;for(S=e[3],n=0;n<S.length;n+=1){const t=li(e,S,n);P[n]?P[n].p(t,r):(P[n]=$i(t),P[n].c(),P[n].m(f,null))}for(;n<P.length;n+=1)P[n].d(1);P.length=S.length}1&r&&y(x,e[0]),2&r&&O!==(O="Editor "+e[1]+" svelte-l280wh")&&l(n,"class",O)},i:p,o:p,d(e){e&&c(n),g(E,e),g(P,e),I=!1,$(w)}}}function xi(e,n,t){let r,a,{theme:i="solarized-dark"}=n,{value:s=""}=n;return e.$set=(e=>{"theme"in e&&t(1,i=e.theme),"value"in e&&t(0,s=e.value)}),e.$$.update=(()=>{1&e.$$.dirty&&t(2,r=(s.match(/\n/g)||[]).length+1),1&e.$$.dirty&&t(3,(ci.reset(s),a=Array.from(ci)))}),[s,i,r,a,function(n){b(e,n)},function(){s=this.value,t(0,s)}]}class Oi extends e{constructor(e){super(),n(this,e,xi,bi,t,{theme:1,value:0})}}function Ii(e,n,t){const r=e.slice();return r[13]=n[t],r[15]=t,r}function wi(e){let n,t,p,f;function d(...n){return e[10](e[15],...n)}return{c(){n=r("span"),t=a(""),this.h()},l(e){n=i(e,"SPAN",{class:!0});var r=s(n);t=o(r,""),r.forEach(c),this.h()},h(){l(n,"class","close svelte-4eu6m3")},m(e,r){u(e,n,r),m(n,t),p||(f=v(n,"click",d),p=!0)},p(n,t){e=n},d(e){e&&c(n),p=!1,f()}}}function ji(e){let n,t,p,f,y,g,$=e[13].label+"";function b(...n){return e[9](e[15],...n)}let I=!e[13].persistent&&e[0].length>e[4]&&wi(e);return{c(){n=r("div"),t=r("span"),p=a($),f=d(),I&&I.c(),this.h()},l(e){n=i(e,"DIV",{class:!0});var r=s(n);t=i(r,"SPAN",{class:!0});var a=s(t);p=o(a,$),a.forEach(c),f=h(r),I&&I.l(r),r.forEach(c),this.h()},h(){l(t,"class","label svelte-4eu6m3"),l(n,"class","tab svelte-4eu6m3"),O(n,"selected",e[15]===e[1]),O(n,"active",e[15]===e[3])},m(e,r){u(e,n,r),m(n,t),m(t,p),m(n,f),I&&I.m(n,null),y||(g=v(t,"click",b),y=!0)},p(t,r){e=t,1&r&&$!==($=e[13].label+"")&&x(p,$),!e[13].persistent&&e[0].length>e[4]?I?I.p(e,r):((I=wi(e)).c(),I.m(n,null)):I&&(I.d(1),I=null),2&r&&O(n,"selected",e[15]===e[1]),8&r&&O(n,"active",e[15]===e[3])},d(e){e&&c(n),I&&I.d(),y=!1,g()}}}function Ei(e){let n,t,f,d,h;return{c(){n=r("div"),t=r("span"),f=a("+"),this.h()},l(e){n=i(e,"DIV",{class:!0});var r=s(n);t=i(r,"SPAN",{class:!0});var a=s(t);f=o(a,"+"),a.forEach(c),r.forEach(c),this.h()},h(){l(t,"class","label svelte-4eu6m3"),l(n,"class","tab svelte-4eu6m3")},m(r,a){u(r,n,a),m(n,t),m(t,f),d||(h=v(n,"click",e[7]),d=!0)},p:p,d(e){e&&c(n),d=!1,h()}}}function Si(e){let n,t,a,o,p,f,y=e[0],v=[];for(let n=0;n<y.length;n+=1)v[n]=ji(Ii(e,y,n));let $=e[2]&&Ei(e);function b(n){e[11].call(null,n)}let x={};return void 0!==e[0][e[1]].text&&(x.value=e[0][e[1]].text),o=new Oi({props:x}),I.push(()=>w(o,"value",b)),o.$on("input",e[12]),{c(){n=r("div");for(let e=0;e<v.length;e+=1)v[e].c();t=d(),$&&$.c(),a=d(),j(o.$$.fragment),this.h()},l(e){n=i(e,"DIV",{class:!0});var r=s(n);for(let e=0;e<v.length;e+=1)v[e].l(r);t=h(r),$&&$.l(r),r.forEach(c),a=h(e),E(o.$$.fragment,e),this.h()},h(){l(n,"class","tabs svelte-4eu6m3")},m(e,r){u(e,n,r);for(let e=0;e<v.length;e+=1)v[e].m(n,null);m(n,t),$&&$.m(n,null),u(e,a,r),S(o,e,r),f=!0},p(e,[r]){if(347&r){let a;for(y=e[0],a=0;a<y.length;a+=1){const i=Ii(e,y,a);v[a]?v[a].p(i,r):(v[a]=ji(i),v[a].c(),v[a].m(n,t))}for(;a<v.length;a+=1)v[a].d(1);v.length=y.length}e[2]?$?$.p(e,r):(($=Ei(e)).c(),$.m(n,null)):$&&($.d(1),$=null);const a={};!p&&3&r&&(p=!0,a.value=e[0][e[1]].text,P(()=>p=!1)),o.$set(a)},i(e){f||(A(o.$$.fragment,e),f=!0)},o(e){k(o.$$.fragment,e),f=!1},d(e){e&&c(n),g(v,e),$&&$.d(),e&&c(a),N(o,e)}}}function Pi(e,n,t){let{tabs:r=[]}=n,{newTab:a}=n,{active:i=0}=n,{selected:s=0}=n,{minTabs:o=1}=n;const c=T();function l(e){t(1,s=e)}function u(e){s>=e&&s>0&&t(1,s-=1),r.splice(e,1),t(0,r)}return e.$set=(e=>{"tabs"in e&&t(0,r=e.tabs),"newTab"in e&&t(2,a=e.newTab),"active"in e&&t(3,i=e.active),"selected"in e&&t(1,s=e.selected),"minTabs"in e&&t(4,o=e.minTabs)}),[r,s,a,i,o,c,l,function(){t(0,r[r.length]=a(),r),t(1,s=r.length-1)},u,e=>l(e),e=>u(e),function(e){r[s].text=e,t(0,r)},e=>c("input",r)]}class Ai extends e{constructor(e){super(),n(this,e,Pi,Si,t,{tabs:0,newTab:2,active:3,selected:1,minTabs:4})}}function ki(e,n,t){const r=e.slice();return r[2]=n[t],r}function Ni(e){let n;function t(e,n){return e[1].absoluteKeywordLocation?qi:Ti}let r=t(e),a=r(e);return{c(){a.c(),n=f()},l(e){a.l(e),n=f()},m(e,t){a.m(e,t),u(e,n,t)},p(e,i){r===(r=t(e))&&a?a.p(e,i):(a.d(1),(a=r(e))&&(a.c(),a.m(n.parentNode,n)))},d(e){a.d(e),e&&c(n)}}}function Ti(e){let n,t=e[1]+"";return{c(){n=a(t)},l(e){n=o(e,t)},m(e,t){u(e,n,t)},p(e,r){1&r&&t!==(t=e[1]+"")&&x(n,t)},d(e){e&&c(n)}}}function qi(e){let n,t,l=e[1].errors,m=[];for(let n=0;n<l.length;n+=1)m[n]=Ci(ki(e,l,n));return{c(){n=a("Invalid\n    "),t=r("ul");for(let e=0;e<m.length;e+=1)m[e].c()},l(e){n=o(e,"Invalid\n    "),t=i(e,"UL",{});var r=s(t);for(let e=0;e<m.length;e+=1)m[e].l(r);r.forEach(c)},m(e,r){u(e,n,r),u(e,t,r);for(let e=0;e<m.length;e+=1)m[e].m(t,null)},p(e,n){if(1&n){let r;for(l=e[1].errors,r=0;r<l.length;r+=1){const a=ki(e,l,r);m[r]?m[r].p(a,n):(m[r]=Ci(a),m[r].c(),m[r].m(t,null))}for(;r<m.length;r+=1)m[r].d(1);m.length=l.length}},d(e){e&&c(n),e&&c(t),g(m,e)}}}function Ri(e){let n,t,p,f,d,h,y=e[2].instanceLocation+"",v=e[2].absoluteKeywordLocation+"";return{c(){n=r("li"),t=r("code"),p=a(y),f=a(" fails schema constraint "),d=r("code"),h=a(v),this.h()},l(e){n=i(e,"LI",{class:!0});var r=s(n);t=i(r,"CODE",{class:!0});var a=s(t);p=o(a,y),a.forEach(c),f=o(r," fails schema constraint "),d=i(r,"CODE",{class:!0});var l=s(d);h=o(l,v),l.forEach(c),r.forEach(c),this.h()},h(){l(t,"class","svelte-1sdf2dp"),l(d,"class","svelte-1sdf2dp"),l(n,"class","svelte-1sdf2dp")},m(e,r){u(e,n,r),m(n,t),m(t,p),m(n,f),m(n,d),m(d,h)},p(e,n){1&n&&y!==(y=e[2].instanceLocation+"")&&x(p,y),1&n&&v!==(v=e[2].absoluteKeywordLocation+"")&&x(h,v)},d(e){e&&c(n)}}}function Ci(e){let n,t=!e[2].valid&&Ri(e);return{c(){t&&t.c(),n=f()},l(e){t&&t.l(e),n=f()},m(e,r){t&&t.m(e,r),u(e,n,r)},p(e,r){e[2].valid?t&&(t.d(1),t=null):t?t.p(e,r):((t=Ri(e)).c(),t.m(n.parentNode,n))},d(e){t&&t.d(e),e&&c(n)}}}function Mi(e){let n,t=e[0]?"Valid":"";return{c(){n=a(t)},l(e){n=o(e,t)},m(e,t){u(e,n,t)},p(e,r){1&r&&t!==(t=e[0]?"Valid":"")&&x(n,t)},d(e){e&&c(n)}}}function Di(e){let n;return{c(){n=a("Validating ...")},l(e){n=o(e,"Validating ...")},m(e,t){u(e,n,t)},p:p,d(e){e&&c(n)}}}function Vi(e){let n,t,r={ctx:e,current:null,token:null,pending:Di,then:Mi,catch:Ni,value:0,error:1};return q(t=e[0],r),{c(){n=f(),r.block.c()},l(e){n=f(),r.block.l(e)},m(e,t){u(e,n,t),r.block.m(e,r.anchor=t),r.mount=(()=>n.parentNode),r.anchor=n},p(n,[a]){if(e=n,r.ctx=e,1&a&&t!==(t=e[0])&&q(t,r));else{const n=e.slice();n[0]=r.resolved,r.block.p(n,a)}},i:p,o:p,d(e){e&&c(n),r.block.d(e),r.token=null,r=null}}}function Li(e,n,t){let{results:r}=n;return e.$set=(e=>{"results"in e&&t(0,r=e.results)}),[r]}class Xi extends e{constructor(e){super(),n(this,e,Li,Vi,t,{results:0})}}function Ji(e){let n,t,a,o,p;const f=e[2].default,y=R(f,e,e[1],null);return{c(){n=r("a"),t=C("svg"),a=C("path"),o=d(),y&&y.c(),this.h()},l(e){n=i(e,"A",{href:!0,class:!0});var r=s(n);t=i(r,"svg",{height:!0,viewBox:!0,version:!0,"aria-hidden":!0,class:!0},1);var l=s(t);a=i(l,"path",{"fill-rule":!0,d:!0},1),s(a).forEach(c),l.forEach(c),o=h(r),y&&y.l(r),r.forEach(c),this.h()},h(){l(a,"fill-rule","evenodd"),l(a,"d","M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"),l(t,"height","1.5em"),l(t,"viewBox","0 0 16 16"),l(t,"version","1.1"),l(t,"aria-hidden","true"),l(t,"class","svelte-i8toq"),l(n,"href",e[0]),l(n,"class","svelte-i8toq")},m(e,r){u(e,n,r),m(n,t),m(t,a),m(n,o),y&&y.m(n,null),p=!0},p(e,[t]){y&&y.p&&2&t&&M(y,f,e,e[1],t,null,null),(!p||1&t)&&l(n,"href",e[0])},i(e){p||(A(y,e),p=!0)},o(e){k(y,e),p=!1},d(e){e&&c(n),y&&y.d(e)}}}function zi(e,n,t){let{href:r=""}=n,{$$slots:a={},$$scope:i}=n;return e.$set=(e=>{"href"in e&&t(0,r=e.href),"$$scope"in e&&t(1,i=e.$$scope)}),[r,i,a]}class _i extends e{constructor(e){super(),n(this,e,zi,Ji,t,{href:0})}}function Bi(e){let n,t,a,o,p;const f=e[2].default,y=R(f,e,e[1],null);return{c(){n=r("a"),t=C("svg"),a=C("path"),o=d(),y&&y.c(),this.h()},l(e){n=i(e,"A",{href:!0,class:!0});var r=s(n);t=i(r,"svg",{height:!0,viewBox:!0,version:!0,"aria-hidden":!0,class:!0},1);var l=s(t);a=i(l,"path",{d:!0},1),s(a).forEach(c),l.forEach(c),o=h(r),y&&y.l(r),r.forEach(c),this.h()},h(){l(a,"d","M240,250h100v-50h100V0H240V250z M340,50h50v100h-50V50z M480,0v200h100V50h50v150h50V50h50v150h50V0H480z M0,200h100V50h50v150h50V0H0V200z"),l(t,"height","1em"),l(t,"viewBox","0 0 780 250"),l(t,"version","1.1"),l(t,"aria-hidden","true"),l(t,"class","svelte-wj8h0n"),l(n,"href",e[0]),l(n,"class","svelte-wj8h0n")},m(e,r){u(e,n,r),m(n,t),m(t,a),m(n,o),y&&y.m(n,null),p=!0},p(e,[t]){y&&y.p&&2&t&&M(y,f,e,e[1],t,null,null),(!p||1&t)&&l(n,"href",e[0])},i(e){p||(A(y,e),p=!0)},o(e){k(y,e),p=!1},d(e){e&&c(n),y&&y.d(e)}}}function Fi(e,n,t){let{href:r=""}=n,{$$slots:a={},$$scope:i}=n;return e.$set=(e=>{"href"in e&&t(0,r=e.href),"$$scope"in e&&t(1,i=e.$$scope)}),[r,i,a]}class Gi extends e{constructor(e){super(),n(this,e,Fi,Bi,t,{href:0})}}function Ki(e){let n,t,a,o,p,f,y,v,g;const $=e[2].default,b=R($,e,e[1],null);return{c(){n=r("a"),t=C("svg"),a=C("g"),o=C("path"),p=C("path"),f=C("path"),y=C("path"),v=d(),b&&b.c(),this.h()},l(e){n=i(e,"A",{href:!0,class:!0});var r=s(n);t=i(r,"svg",{version:!0,viewBox:!0,height:!0,class:!0},1);var l=s(t);a=i(l,"g",{transform:!0,id:!0},1);var u=s(a);o=i(u,"path",{id:!0,d:!0,style:!0},1),s(o).forEach(c),p=i(u,"path",{id:!0,d:!0,style:!0},1),s(p).forEach(c),f=i(u,"path",{id:!0,d:!0,style:!0},1),s(f).forEach(c),y=i(u,"path",{id:!0,d:!0,style:!0},1),s(y).forEach(c),u.forEach(c),l.forEach(c),v=h(r),b&&b.l(r),r.forEach(c),this.h()},h(){l(o,"id","path4544"),l(o,"d","m 122.99401,114.18985 c -4.32897,-0.9404 -7.58044,-3.47848 -8.71251,-6.80095 -0.78921,-2.31618 -0.67682,-6.07238 0.33363,-11.150598 0.48507,-2.437836 0.88169,-5.347843 0.88139,-6.466688 -9.8e-4,-3.718098 -1.71106,-5.735418 -5.1001,-6.016462 l -1.9549,-0.162116 v -2.392655 -2.392657 l 1.85208,-0.250855 c 2.70243,-0.366031 3.74441,-1.02838 4.57629,-2.908984 0.61121,-1.381726 0.68884,-2.068648 0.50552,-4.472869 -0.11913,-1.562244 -0.53527,-4.348568 -0.92477,-6.191832 -0.98954,-4.682868 -0.94822,-8.485471 0.11707,-10.773163 1.56862,-3.368589 5.43705,-5.854553 9.93248,-6.382903 l 1.93299,-0.227185 v 2.518015 2.518015 h -1.29973 c -1.77186,0 -4.2497,1.262413 -4.8835,2.488054 -0.60797,1.175674 -0.65405,2.864146 -0.15834,5.802223 0.78343,4.643508 1.04707,9.098344 0.67592,11.421636 -0.42464,2.658142 -1.97477,5.796328 -3.6791,7.448236 l -1.18012,1.143813 1.61497,1.982752 c 1.99051,2.443801 2.76458,4.148744 3.24284,7.142561 0.37835,2.368341 0.0844,7.282673 -0.67072,11.213982 -1.05359,5.48514 0.1623,7.65141 4.66209,8.30613 l 1.67569,0.24382 v 2.44782 c 0,2.79211 0.17086,2.69708 -3.43917,1.91286 z"),D(o,"fill","stroke-width:0.35277775"),l(p,"id","path4546"),l(p,"d","m 152.2304,112.24932 v -2.42987 l 2.04969,-0.42336 c 2.26276,-0.46736 4.054,-1.8634 4.45842,-3.47475 0.1274,-0.50758 -0.11267,-3.16398 -0.53347,-5.90311 -1.37183,-8.929552 -0.6114,-13.537042 2.85482,-17.297452 l 1.48237,-1.60818 -1.1108,-1.26512 c -3.97855,-4.53132 -4.66885,-8.552208 -3.15364,-18.369547 0.76342,-4.946305 0.76409,-4.994322 0.087,-6.173611 -0.79713,-1.388278 -3.28385,-2.776033 -4.97438,-2.776033 h -1.15997 v -2.469445 c 0,-2.811057 -0.0583,-2.773846 3.24583,-2.072788 3.9645,0.841179 6.80448,2.853272 8.27787,5.864775 0.84544,1.728026 0.97275,2.400136 0.94911,5.010889 -0.015,1.658349 -0.35758,4.682054 -0.76125,6.719346 -1.49867,7.563594 -1.3651,9.576204 0.7654,11.532814 0.98915,0.90842 1.64012,1.17274 3.37032,1.36849 l 2.14439,0.24261 v 2.42387 2.42388 l -1.6757,7.1e-4 c -2.1517,7e-4 -3.9323,0.90924 -4.83869,2.46889 -0.95194,1.63803 -0.89239,5.20675 0.17364,10.40695 0.90648,4.421902 1.05253,8.458452 0.3882,10.728752 -0.70059,2.39406 -3.81995,5.29609 -6.74745,6.27718 -1.26118,0.42266 -2.96775,0.87096 -3.79236,0.99623 l -1.49931,0.22775 z"),D(p,"stroke-width","0.35277778"),l(f,"id","path4548"),l(f,"d","m 131.74239,108.26592 c -1.02163,-1.2988 -0.87294,-3.53652 0.38087,-5.73185 0.92776,-1.62446 4.80862,-6.948549 7.61066,-10.440949 l 1.13094,-1.40958 -1.80213,-5.22523 c -2.02147,-5.86123 -2.0098,-5.97467 0.65581,-6.37225 l 1.46834,-0.219 1.64076,3.3506 c 0.90242,1.84283 1.76982,3.35061 1.92755,3.35061 0.15774,0 1.77489,-1.75542 3.59368,-3.90092 3.15918,-3.72667 3.35688,-3.89165 4.42591,-3.69334 0.64552,0.11974 1.21858,0.0465 1.35432,-0.17316 0.31818,-0.51481 1.23083,0.24704 1.23083,1.02746 0,0.32009 -0.45438,1.13409 -1.00972,1.80888 -2.26771,2.75549 -7.10417,9.27155 -7.10417,9.5713 0,0.17685 0.97502,2.45302 2.16671,5.05816 l 2.1667,4.736609 -0.65823,0.98459 c -0.36203,0.54152 -0.66236,1.12603 -0.6674,1.29891 -0.005,0.17288 -0.27769,0.48371 -0.60588,0.69073 -0.83174,0.52464 -1.44656,-0.11541 -3.9894,-4.153119 -1.16417,-1.84856 -2.23163,-3.36491 -2.37215,-3.36967 -0.31309,-0.0106 -3.7911,5.131969 -6.47955,9.580639 -2.37093,3.92324 -1.93885,3.4204 -3.26614,3.80106 -0.95533,0.27398 -1.19348,0.19843 -1.79831,-0.57048 z"),D(f,"stroke-width","0.35277775"),l(y,"id","path4550"),l(y,"d","m 131.98567,83.677091 c -2.15148,-3.8472 -6.0183,-9.42829 -7.57842,-10.93815 -0.79252,-0.76698 -1.44094,-1.57494 -1.44094,-1.79546 0,-0.6016 1.61695,-1.21975 3.19058,-1.21975 1.69822,0 3.49597,1.47777 5.0997,4.19203 0.58208,0.98515 1.15641,1.79434 1.27629,1.79819 0.11988,0.004 0.80873,-1.65116 1.53078,-3.67779 1.5464,-4.34039 5.62351,-12.777999 7.22453,-14.951229 1.3726,-1.86316 3.42936,-2.865165 5.90274,-2.875676 3.23375,-0.01374 3.24268,0.130067 0.20474,3.296663 -4.63599,4.832327 -6.76321,8.809632 -11.25155,21.037252 -1.24637,3.39549 -2.39032,6.47895 -2.54212,6.85214 -0.23022,0.56597 -0.49833,0.28096 -1.61633,-1.71822 z"),D(y,"stroke-width","0.35277775"),l(a,"transform","translate(-104.22785,-45.507923)"),l(a,"id","layer1"),l(t,"version","1.1"),l(t,"viewBox","0 0 70.423268 70.42326"),l(t,"height","1.25em"),l(t,"class","svelte-27u907"),l(n,"href",e[0]),l(n,"class","svelte-27u907")},m(e,r){u(e,n,r),m(n,t),m(t,a),m(a,o),m(a,p),m(a,f),m(a,y),m(n,v),b&&b.m(n,null),g=!0},p(e,[t]){b&&b.p&&2&t&&M(b,$,e,e[1],t,null,null),(!g||1&t)&&l(n,"href",e[0])},i(e){g||(A(b,e),g=!0)},o(e){k(b,e),g=!1},d(e){e&&c(n),b&&b.d(e)}}}function Ui(e,n,t){let{href:r=""}=n,{$$slots:a={},$$scope:i}=n;return e.$set=(e=>{"href"in e&&t(0,r=e.href),"$$scope"in e&&t(1,i=e.$$scope)}),[r,i,a]}class Hi extends e{constructor(e){super(),n(this,e,Ui,Ki,t,{href:0})}}function Wi(e){let n;return{c(){n=a("hyperjump-io/json-schema.hyperjump.io")},l(e){n=o(e,"hyperjump-io/json-schema.hyperjump.io")},m(e,t){u(e,n,t)},d(e){e&&c(n)}}}function Zi(e){let n;return{c(){n=a("hyperjump-io/json-schema-validator")},l(e){n=o(e,"hyperjump-io/json-schema-validator")},m(e,t){u(e,n,t)},d(e){e&&c(n)}}}function Qi(e){let n;return{c(){n=a("@hyperjump/json-schema")},l(e){n=o(e,"@hyperjump/json-schema")},m(e,t){u(e,n,t)},d(e){e&&c(n)}}}function Yi(e){let n;return{c(){n=a("@hyperjump/json-schema-core")},l(e){n=o(e,"@hyperjump/json-schema-core")},m(e,t){u(e,n,t)},d(e){e&&c(n)}}}function es(e){let n;return{c(){n=a("JSON Schema")},l(e){n=o(e,"JSON Schema")},m(e,t){u(e,n,t)},d(e){e&&c(n)}}}function ns(e){let n,t,a,o,p,f,y,v,g,$,b,x,O,I,w,P,T;return o=new _i({props:{href:"https://github.com/hyperjump-io/json-schema.hyperjump.io",$$slots:{default:[Wi]},$$scope:{ctx:e}}}),y=new _i({props:{href:"https://github.com/hyperjump-io/json-schema-validator",$$slots:{default:[Zi]},$$scope:{ctx:e}}}),$=new Gi({props:{href:"https://www.npmjs.com/package/@hyperjump/json-schema",$$slots:{default:[Qi]},$$scope:{ctx:e}}}),O=new Gi({props:{href:"https://www.npmjs.com/package/@hyperjump/json-schema-core",$$slots:{default:[Yi]},$$scope:{ctx:e}}}),P=new Hi({props:{href:"https://json-schema.org",$$slots:{default:[es]},$$scope:{ctx:e}}}),{c(){n=r("footer"),t=r("ul"),a=r("li"),j(o.$$.fragment),p=d(),f=r("li"),j(y.$$.fragment),v=d(),g=r("li"),j($.$$.fragment),b=d(),x=r("li"),j(O.$$.fragment),I=d(),w=r("li"),j(P.$$.fragment),this.h()},l(e){n=i(e,"FOOTER",{class:!0});var r=s(n);t=i(r,"UL",{class:!0});var l=s(t);a=i(l,"LI",{class:!0});var u=s(a);E(o.$$.fragment,u),u.forEach(c),p=h(l),f=i(l,"LI",{class:!0});var m=s(f);E(y.$$.fragment,m),m.forEach(c),v=h(l),g=i(l,"LI",{class:!0});var d=s(g);E($.$$.fragment,d),d.forEach(c),b=h(l),x=i(l,"LI",{class:!0});var j=s(x);E(O.$$.fragment,j),j.forEach(c),I=h(l),w=i(l,"LI",{class:!0});var S=s(w);E(P.$$.fragment,S),S.forEach(c),l.forEach(c),r.forEach(c),this.h()},h(){l(a,"class","svelte-17tbtsq"),l(f,"class","svelte-17tbtsq"),l(g,"class","svelte-17tbtsq"),l(x,"class","svelte-17tbtsq"),l(w,"class","svelte-17tbtsq"),l(t,"class","links svelte-17tbtsq"),l(n,"class","svelte-17tbtsq")},m(e,r){u(e,n,r),m(n,t),m(t,a),S(o,a,null),m(t,p),m(t,f),S(y,f,null),m(t,v),m(t,g),S($,g,null),m(t,b),m(t,x),S(O,x,null),m(t,I),m(t,w),S(P,w,null),T=!0},p(e,[n]){const t={};1&n&&(t.$$scope={dirty:n,ctx:e}),o.$set(t);const r={};1&n&&(r.$$scope={dirty:n,ctx:e}),y.$set(r);const a={};1&n&&(a.$$scope={dirty:n,ctx:e}),$.$set(a);const i={};1&n&&(i.$$scope={dirty:n,ctx:e}),O.$set(i);const s={};1&n&&(s.$$scope={dirty:n,ctx:e}),P.$set(s)},i(e){T||(A(o.$$.fragment,e),A(y.$$.fragment,e),A($.$$.fragment,e),A(O.$$.fragment,e),A(P.$$.fragment,e),T=!0)},o(e){k(o.$$.fragment,e),k(y.$$.fragment,e),k($.$$.fragment,e),k(O.$$.fragment,e),k(P.$$.fragment,e),T=!1},d(e){e&&c(n),N(o),N(y),N($),N(O),N(P)}}}class ts extends e{constructor(e){super(),n(this,e,null,ns,t,{})}}const rs="https://json-schema.org/draft/2020-XX/schema";function as(e){return{c:p,l:p,m:p,p:p,i:p,o:p,d:p}}function is(e){let n,t;return n=new Xi({props:{results:e[4]}}),{c(){j(n.$$.fragment)},l(e){E(n.$$.fragment,e)},m(e,r){S(n,e,r),t=!0},p(e,t){const r={};16&t&&(r.results=e[4]),n.$set(r)},i(e){t||(A(n.$$.fragment,e),t=!0)},o(e){k(n.$$.fragment,e),t=!1},d(e){N(n,e)}}}function ss(e){return{c:p,l:p,m:p,p:p,i:p,o:p,d:p}}function os(e){let n,t,p,f,y,v,g,$,b,x,O,T,R,C,M,D,L,X,J,z,_,B,F;function G(n){e[9].call(null,n)}function K(n){e[10].call(null,n)}(g=new Ai({props:{tabs:e[0],newTab:e[5],active:0}})).$on("input",e[7]);let U={tabs:e[1],newTab:e[6]};void 0!==e[2]&&(U.selected=e[2]),void 0!==e[2]&&(U.active=e[2]),x=new Ai({props:U}),I.push(()=>w(x,"selected",G)),I.push(()=>w(x,"active",K)),x.$on("input",e[8]),M=new Xi({props:{results:e[3]}});let H={ctx:e,current:null,token:null,pending:ss,then:is,catch:as,value:12,blocks:[,,,]};return q(J=e[3],H),B=new ts({}),{c(){n=d(),t=r("main"),p=r("h1"),f=a("Hyperjump - JSON Schema Validator"),y=d(),v=r("div"),j(g.$$.fragment),$=d(),b=r("div"),j(x.$$.fragment),R=d(),C=r("div"),j(M.$$.fragment),L=d(),X=r("div"),H.block.c(),_=d(),j(B.$$.fragment),this.h()},l(e){V('[data-svelte="svelte-14138tz"]',document.head).forEach(c),n=h(e),t=i(e,"MAIN",{class:!0});var r=s(t);p=i(r,"H1",{class:!0});var a=s(p);f=o(a,"Hyperjump - JSON Schema Validator"),a.forEach(c),y=h(r),v=i(r,"DIV",{class:!0});var l=s(v);E(g.$$.fragment,l),l.forEach(c),$=h(r),b=i(r,"DIV",{class:!0});var u=s(b);E(x.$$.fragment,u),u.forEach(c),R=h(r),C=i(r,"DIV",{class:!0});var m=s(C);E(M.$$.fragment,m),m.forEach(c),L=h(r),X=i(r,"DIV",{class:!0});var d=s(X);H.block.l(d),d.forEach(c),_=h(r),E(B.$$.fragment,r),r.forEach(c),this.h()},h(){document.title="Hyperjump - JSON Schema Validator",l(p,"class","svelte-1fbysc"),l(v,"class","editor-section svelte-1fbysc"),l(b,"class","editor-section svelte-1fbysc"),l(C,"class",D="results "+ms+" svelte-1fbysc"),l(X,"class",z="results "+ms+" svelte-1fbysc"),l(t,"class","svelte-1fbysc")},m(e,r){u(e,n,r),u(e,t,r),m(t,p),m(p,f),m(t,y),m(t,v),S(g,v,null),m(t,$),m(t,b),S(x,b,null),m(t,R),m(t,C),S(M,C,null),m(t,L),m(t,X),H.block.m(X,H.anchor=null),H.mount=(()=>X),H.anchor=null,m(t,_),S(B,t,null),F=!0},p(n,[t]){e=n;const r={};1&t&&(r.tabs=e[0]),g.$set(r);const a={};2&t&&(a.tabs=e[1]),!O&&4&t&&(O=!0,a.selected=e[2],P(()=>O=!1)),!T&&4&t&&(T=!0,a.active=e[2],P(()=>T=!1)),x.$set(a);const i={};if(8&t&&(i.results=e[3]),M.$set(i),H.ctx=e,8&t&&J!==(J=e[3])&&q(J,H));else{const n=e.slice();n[12]=H.resolved,H.block.p(n,t)}},i(e){F||(A(g.$$.fragment,e),A(x.$$.fragment,e),A(M.$$.fragment,e),A(H.block),A(B.$$.fragment,e),F=!0)},o(e){k(g.$$.fragment,e),k(x.$$.fragment,e),k(M.$$.fragment,e);for(let e=0;e<3;e+=1){const n=H.blocks[e];k(n)}k(B.$$.fragment,e),F=!1},d(e){e&&c(n),e&&c(t),N(g),N(x),N(M),H.block.d(),H.token=null,H=null,N(B)}}}Rn.setConfig(rs,"idToken","$id"),Rn.setConfig(rs,"anchorToken","$anchor"),Rn.setConfig(rs,"jsrefToken","$ref"),Rn.setConfig(rs,"dynamicJsrefToken","$recursiveRef"),Rn.setConfig(rs,"dynamicAnchorToken","$dynamcicAnchor"),Rn.setConfig(rs,"commentToken","$comment"),Rn.setConfig(rs,"vocabulary",!0),Rn.setConfig(rs,"mandatoryVocabularies",["https://json-schema.org/draft/2020-XX/vocab/core"]),Rn.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2020-XX/schema",\n    "$id": "https://json-schema.org/draft/2020-XX/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-XX/vocab/core": true,\n        "https://json-schema.org/draft/2020-XX/vocab/applicator": true,\n        "https://json-schema.org/draft/2020-XX/vocab/validation": true,\n        "https://json-schema.org/draft/2020-XX/vocab/meta-data": true,\n        "https://json-schema.org/draft/2020-XX/vocab/format": false,\n        "https://json-schema.org/draft/2020-XX/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$recursiveRef": "#" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),Rn.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-XX/meta/core",\n    "$schema": "https://json-schema.org/draft/2020-XX/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2020-XX/vocab/core": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z][-A-Za-z0-9.:_]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveAnchor": {\n            "type": "boolean",\n            "const": true,\n            "default": false\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        }\n    }\n}')),qn.defineVocabulary("https://json-schema.org/draft/2020-XX/vocab/core",{validate:Xa.validate,$comment:Xa.metaData,$defs:Xa.definitions,$recursiveRef:Xa.$recursiveRef,$ref:Xa.$ref}),Rn.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-XX/meta/applicator",\n    "$schema": "https://json-schema.org/draft/2020-XX/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2020-XX/vocab/applicator": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Applicator vocabulary meta-schema",\n    "properties": {\n        "additionalItems": { "$recursiveRef": "#" },\n        "unevaluatedItems": { "$recursiveRef": "#" },\n        "items": {\n            "anyOf": [\n                { "$recursiveRef": "#" },\n                { "$ref": "#/$defs/schemaArray" }\n            ]\n        },\n        "contains": { "$recursiveRef": "#" },\n        "additionalProperties": { "$recursiveRef": "#" },\n        "unevaluatedProperties": { "$recursiveRef": "#" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$recursiveRef": "#"\n            }\n        },\n        "propertyNames": { "$recursiveRef": "#" },\n        "if": { "$recursiveRef": "#" },\n        "then": { "$recursiveRef": "#" },\n        "else": { "$recursiveRef": "#" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$recursiveRef": "#" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$recursiveRef": "#" }\n        }\n    }\n}')),qn.defineVocabulary("https://json-schema.org/draft/2020-XX/vocab/applicator",{additionalItems:Xa.additionalItems6,additionalProperties:Xa.additionalProperties6,allOf:Xa.allOf,anyOf:Xa.anyOf,contains:Xa.containsMinContainsMaxContains,dependentSchemas:Xa.dependentSchemas,if:Xa.ifThenElse,items:Xa.items,not:Xa.not,oneOf:Xa.oneOf,patternProperties:Xa.patternProperties,properties:Xa.properties,propertyNames:Xa.propertyNames,unevaluatedItems:Xa.unevaluatedItems,unevaluatedProperties:Xa.unevaluatedProperties}),Rn.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-XX/meta/validation",\n    "$schema": "https://json-schema.org/draft/2020-XX/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2020-XX/vocab/validation": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": ["number", "boolean"]\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": ["number", "boolean"]\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "allOf": [\n        {\n            "if": {\n                "properties": {\n                    "exclusiveMinimum": { "type": "boolean" }\n                },\n                "required": ["exclusiveMinimum"]\n            },\n            "then": {\n                "required": ["minimum"]\n            }\n        },\n        {\n            "if": {\n                "properties": {\n                    "exclusiveMaximum": { "type": "boolean" }\n                },\n                "required": ["exclusiveMaximum"]\n            },\n            "then": {\n                "required": ["maximum"]\n            }\n        }\n    ],\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),qn.defineVocabulary("https://json-schema.org/draft/2020-XX/vocab/validation",{const:Xa.const,dependentRequired:Xa.dependentRequired,enum:Xa.enum,exclusiveMaximum:Xa.exclusiveMaximum,exclusiveMinimum:Xa.exclusiveMinimum,maxItems:Xa.maxItems,maxLength:Xa.maxLength6,maxProperties:Xa.maxProperties,maximum:Xa.maximum,minItems:Xa.minItems,minLength:Xa.minLength6,minProperties:Xa.minProperties,minimum:Xa.minimum,multipleOf:Xa.multipleOf,pattern:Xa.pattern,required:Xa.required,type:Xa.type,uniqueItems:Xa.uniqueItems}),Rn.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-XX/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/2020-XX/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2020-XX/vocab/meta-data": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),qn.defineVocabulary("https://json-schema.org/draft/2020-XX/vocab/meta-data",{default:Xa.metaData,deprecated:Xa.metaData,description:Xa.metaData,examples:Xa.metaData,readOnly:Xa.metaData,title:Xa.metaData,writeOnly:Xa.metaData}),Rn.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-XX/meta/format",\n    "$schema": "https://json-schema.org/draft/2020-XX/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2020-XX/vocab/format": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Format vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),Rn.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-XX/meta/content",\n    "$schema": "https://json-schema.org/draft/2020-XX/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2020-XX/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$recursiveRef": "#" }\n    }\n}')),qn.defineVocabulary("https://json-schema.org/draft/2020-XX/vocab/content",{contentEncoding:Xa.metaData,contentMediaType:Xa.metaData,contentSchema:Xa.metaData});const cs=750,ls="https://json-schema.org/draft/2019-09/schema",us="https://json-schema.hyperjump.io/schema",ms="solarized-dark";function ps(e,n,t){const r=function(){let e=1;return(n,t,r=!1)=>{const a=t||`${us}${++e}`;return{label:n||`Schema ${e}`,text:`{\n  "$id": "${a}",\n  "$schema": "${ls}"\n}`,persistent:r}}}(),a=function(){let e=1;return()=>({label:`Instance ${e++}`,text:""})}();let i=[r("Schema",us,!0)],s=[a("Instance")],o=0;const c=function(e,n){let t;return({detail:r})=>{clearTimeout(t),t=setTimeout(()=>e(r),n)}},l=c(e=>t(0,i=e),cs),u=c(e=>t(1,s=e),cs);let m,p;return ai.setMetaOutputFormat(ai.BASIC),e.$$.update=(()=>{1&e.$$.dirty&&t(3,m=async function(){i.forEach((e,n)=>{const t=0===n?us:"";ai.add(JSON.parse(e.text||"true"),t,ls)});const e=await ai.get(us);return ai.validate(e)}()),14&e.$$.dirty&&t(4,p=async function(){if(""!==s[o].text){let e;try{e=await m}catch(e){}if(e){const n=e(JSON.parse(s[o].text),ai.BASIC);if(n.valid)return n;throw n}}}())}),[i,s,o,m,p,r,a,l,u,function(e){t(2,o=e)},function(e){t(2,o=e)}]}export default class extends e{constructor(e){super(),n(this,e,ps,os,t,{})}}
