import{S as e,i as t,s as n,e as a,t as r,c as i,a as s,b as o,d as c,f as l,g as m,h as p,n as u,j as f,k as d,l as h,m as y,o as v,p as g,r as $,q as b,u as S,v as w,w as O,x,y as j,z as I,A as E,B as P,C as A,D as k,E as R,F as C,G as N,H as T,I as D,J as q,K as M,L as V,M as L,N as J}from"./client.6fa74151.js";var U=Object.freeze({__proto__:null,get default(){return U}}),_=function(e,t){return function n(){null==t&&(t=e.length);var a=[].slice.call(arguments);return a.length>=t?e.apply(this,a):function(){return n.apply(this,a.concat([].slice.call(arguments)))}}};var B="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function F(e,t,n){return e(n={path:t,exports:{},require:function(e,t){return function(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}(null==t&&n.path)}},n.exports),n.exports}var z=F((function(e,t){var n;n={},("object"==typeof window&&window||B).PubSub=n,function(e){var t={},n=-1,a="*";function r(e){var t;for(t in e)if(Object.prototype.hasOwnProperty.call(e,t))return!0;return!1}function i(e){return function(){throw e}}function s(e,t,n){try{e(t,n)}catch(e){setTimeout(i(e),0)}}function o(e,t,n){e(t,n)}function c(e,n,a,r){var i,c=t[n],l=r?o:s;if(Object.prototype.hasOwnProperty.call(t,n))for(i in c)Object.prototype.hasOwnProperty.call(c,i)&&l(c[i],e,a)}function l(e,t,n){return function(){var r=String(e),i=r.lastIndexOf(".");for(c(e,e,t,n);-1!==i;)i=(r=r.substr(0,i)).lastIndexOf("."),c(e,r,t,n);c(e,a,t,n)}}function m(e){var n=String(e);return Boolean(Object.prototype.hasOwnProperty.call(t,n)&&r(t[n]))}function p(e){for(var t=String(e),n=m(t)||m(a),r=t.lastIndexOf(".");!n&&-1!==r;)r=(t=t.substr(0,r)).lastIndexOf("."),n=m(t);return n}function u(e,t,n,a){var r=l(e="symbol"==typeof e?e.toString():e,t,a);return!!p(e)&&(!0===n?r():setTimeout(r,0),!0)}e.publish=function(t,n){return u(t,n,!1,e.immediateExceptions)},e.publishSync=function(t,n){return u(t,n,!0,e.immediateExceptions)},e.subscribe=function(e,a){if("function"!=typeof a)return!1;e="symbol"==typeof e?e.toString():e,Object.prototype.hasOwnProperty.call(t,e)||(t[e]={});var r="uid_"+String(++n);return t[e][r]=a,r},e.subscribeAll=function(t){return e.subscribe(a,t)},e.subscribeOnce=function(t,n){var a=e.subscribe(t,(function(){e.unsubscribe(a),n.apply(this,arguments)}));return e},e.clearAllSubscriptions=function(){t={}},e.clearSubscriptions=function(e){var n;for(n in t)Object.prototype.hasOwnProperty.call(t,n)&&0===n.indexOf(e)&&delete t[n]},e.countSubscriptions=function(e){var n,a,r=0;for(n in t)if(Object.prototype.hasOwnProperty.call(t,n)&&0===n.indexOf(e)){for(a in t[n])r++;break}return r},e.getSubscriptions=function(e){var n,a=[];for(n in t)Object.prototype.hasOwnProperty.call(t,n)&&0===n.indexOf(e)&&a.push(n);return a},e.unsubscribe=function(n){var a,r,i,s=function(e){var n;for(n in t)if(Object.prototype.hasOwnProperty.call(t,n)&&0===n.indexOf(e))return!0;return!1},o="string"==typeof n&&(Object.prototype.hasOwnProperty.call(t,n)||s(n)),c=!o&&"string"==typeof n,l="function"==typeof n,m=!1;if(!o){for(a in t)if(Object.prototype.hasOwnProperty.call(t,a)){if(r=t[a],c&&r[n]){delete r[n],m=n;break}if(l)for(i in r)Object.prototype.hasOwnProperty.call(r,i)&&r[i]===n&&(delete r[i],m=!0)}return m}e.clearSubscriptions(n)}}(n),void 0!==e&&e.exports&&(t=e.exports=n),t.PubSub=n,e.exports=t=n}));z.PubSub;var K=function(e,t){if(e=e.trim(),(t=t.trim()).startsWith("about:"))return t;const n=function(e){const t={host:"",path:"",query:"",protocol:""};let n=e,a=e.indexOf("//");t.protocol=n.substring(0,a),a+=2;const r=e.indexOf("/",a),i=e.indexOf("?"),s=e.indexOf("#");-1!==s&&(n=n.substring(0,s));if(-1!==i){const e=n.substring(i);t.query=e,n=n.substring(0,i)}if(-1!==r){const e=n.substring(0,r);t.host=e,n=n.substring(r),t.path=n}else t.host=n;return t}(e),a=function(e){const t={href:e,hash:"",query:"",netPath:!1,absolutePath:!1,relativePath:!1};if(W.test(e))return t.netPath=!0,t;"/"===e[0]?t.absolutePath=!0:""!==e&&(t.relativePath=!0);let n=e;const a=e.indexOf("?"),r=e.indexOf("#");if(-1!==r){const e=n.substring(r);t.hash=e,n=n.substring(0,r)}if(-1!==a){const e=n.substring(a);t.query=e,n=n.substring(0,a)}return t.path=n,t}(t);if(!n.protocol&&!a.netPath)throw new Error("Error, protocol is not specified");if(a.netPath)return a.href.startsWith("//")&&(a.href=n.protocol+a.href),function(e){const t=e.indexOf("//")+2,n=!e.includes("/",t),a=!e.includes("?",t),r=!e.includes("#",t);return n&&a&&r}(a.href)?G(a.href):a.href;if(a.absolutePath){const{path:e,query:t,hash:r}=a;return n.host+Z(e)+t+r}if(a.relativePath){const{path:e,query:t,hash:r}=a;let i,s=n.path,o=n.host;return 0===e.length?i=s:(s=s.substring(0,s.lastIndexOf("/")),i=Z(s+"/"+e)),o+=""!==i||t||r?i+t+r:"/",o}{const{host:e,path:t,query:r}=n;return t||r?e+t+r+a.hash:G(e)}};function G(e){return e+("/"===e[e.length-1]?"":"/")}function Z(e){let t=e.split("/");""===t[0]&&(t=t.slice(1));let n=[];return t.forEach(((e,a)=>{"."!==e&&(".."===e?n.pop():""===e&&a!==t.length-1||n.push(e))})),"/"+n.join("/")}const W=new RegExp("^([a-z][a-z0-9+.-]*:)?//","i");const H={null:e=>null===e,boolean:e=>"boolean"==typeof e,object:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,array:e=>Array.isArray(e),number:e=>"number"==typeof e,integer:e=>Number.isInteger(e),string:e=>"string"==typeof e},X=e=>{const t=e.indexOf("#"),n=-1===t?e.length:t,a=e.slice(0,n),r=e.slice(n+1);return[decodeURI(a),decodeURI(r)]},Y=e=>{const t=e.match(/^(.+):\/\//);return t?t[1]:""};var Q={jsonTypeOf:(e,t)=>H[t](e),splitUrl:X,safeResolveUrl:(e,t)=>{const n=K(e,t),a=X(e)[0];if(a&&"file"===Y(n)&&"file"!==Y(a))throw Error(`Can't access file '${n}' resource from network context '${e}'`);return n}};const ee=e=>{if(e.length>0&&"/"!==e[0])throw Error("Invalid JSON Pointer");return e.split("/").slice(1).map(oe)},te=(e,t,n,a)=>{if(0===e.length)return n;if(e.length>1){const r=e.shift();return{...t,[r]:te(e,le(t,r,a),n,ie(r,a))}}if(Array.isArray(t)){const a=[...t];return a[ce(t,e[0])]=n,a}return"object"==typeof t&&null!==t?{...t,[e[0]]:n}:le(t,e[0],a)},ne=(e,t,n,a)=>{if(0!==e.length)if(1!==e.length||me(t)){const r=e.shift();ne(e,le(t,r,a),n,ie(r,a))}else{t[ce(t,e[0])]=n}},ae=(e,t,n)=>{if(0!=e.length){if(e.length>1){const a=e.shift(),r=le(t,a,n);return{...t,[a]:ae(e,r,ie(a,n))}}if(Array.isArray(t))return t.filter(((t,n)=>n!=e[0]));if("object"==typeof t&&null!==t){const{[e[0]]:n,...a}=t;return a}return le(t,e[0],n)}},re=(e,t,n)=>{if(0!==e.length)if(e.length>1){const a=e.shift(),r=le(t,a,n);re(e,r,ie(a,n))}else Array.isArray(t)?t.splice(e[0],1):"object"==typeof t&&null!==t?delete t[e[0]]:le(t,e[0],n)},ie=_(((e,t)=>t+"/"+se(e))),se=e=>e.toString().replace(/~/g,"~0").replace(/\//g,"~1"),oe=e=>e.toString().replace(/~1/g,"/").replace(/~0/g,"~"),ce=(e,t)=>Array.isArray(e)&&"-"===t?e.length:t,le=(e,t,n="")=>{if(void 0===e)throw TypeError(`Value at '${n}' is undefined and does not have property '${t}'`);if(null===e)throw TypeError(`Value at '${n}' is null and does not have property '${t}'`);if(me(e))throw TypeError(`Value at '${n}' is a ${typeof e} and does not have property '${t}'`);return e[ce(e,t)]},me=e=>null===e||"object"!=typeof e;var pe={nil:"",append:ie,get:(e,t)=>{const n=ee(e),a=e=>n.reduce((([e,t],n)=>[le(e,n,t),ie(n,t)]),[e,""])[0];return void 0===t?a:a(t)},set:(e,t,n)=>{const a=ee(e),r=_(((e,t)=>te(a,e,t,"")));return void 0===t?r:r(t,n)},assign:(e,t,n)=>{const a=ee(e),r=_(((e,t)=>ne(a,e,t,"")));return void 0===t?r:r(t,n)},unset:(e,t)=>{const n=ee(e),a=e=>ae(n,e,"");return void 0===t?a:a(t)},delete:(e,t)=>{const n=ee(e),a=e=>re(n,e,"");return void 0===t?a:a(t)}};pe.nil,pe.append,pe.get,pe.set,pe.assign,pe.unset;const ue=Symbol("$__value"),fe=Symbol("$__href");var de=(e,t)=>Object.freeze({[fe]:e,[ue]:t}),he=e=>e&&void 0!==e[fe],ye=e=>e[fe],ve=e=>e[ue];const{jsonTypeOf:ge}=Q,$e=Object.freeze({id:"",pointer:"",instance:void 0,value:void 0}),be=e=>he(e.value)?ve(e.value):e.value,Se=_(((e,t)=>ge(be(e),t))),we=(e,t)=>Object.freeze({...t,pointer:pe.append(e,t.pointer),value:be(t)[e]}),Oe=_(((e,t)=>be(t).map(((n,a,r,i)=>e(we(a,t),a,r,i))))),xe=_(((e,t)=>be(t).map(((e,n,a,r)=>we(n,t))).filter(((t,n,a,r)=>e(t,n,a,r))))),je=_(((e,t,n)=>be(n).reduce(((t,a,r)=>e(t,we(r,n),r)),t))),Ie=_(((e,t)=>be(t).every(((n,a,r,i)=>e(we(a,t),a,r,i))))),Ee=_(((e,t)=>be(t).some(((n,a,r,i)=>e(we(a,t),a,r,i)))));var Pe={cons:(e,t="")=>Object.freeze({...$e,id:t,instance:e,value:e}),uri:e=>`${e.id}#${encodeURI(e.pointer)}`,value:be,has:(e,t)=>e in be(t),typeOf:Se,step:we,entries:e=>Object.keys(be(e)).map((t=>[t,we(t,e)])),keys:e=>Object.keys(be(e)),map:Oe,filter:xe,reduce:je,every:Ie,some:Ee,length:e=>be(e).length},Ae=/; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g,ke=/^[\u000b\u0020-\u007e\u0080-\u00ff]+$/,Re=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/,Ce=/\\([\u000b\u0020-\u00ff])/g,Ne=/([\\"])/g,Te=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;function De(e){var t=String(e);if(Re.test(t))return t;if(t.length>0&&!ke.test(t))throw new TypeError("invalid parameter value");return'"'+t.replace(Ne,"\\$1")+'"'}function qe(e){this.parameters=Object.create(null),this.type=e}var Me={format:function(e){if(!e||"object"!=typeof e)throw new TypeError("argument obj is required");var t=e.parameters,n=e.type;if(!n||!Te.test(n))throw new TypeError("invalid type");var a=n;if(t&&"object"==typeof t)for(var r,i=Object.keys(t).sort(),s=0;s<i.length;s++){if(r=i[s],!Re.test(r))throw new TypeError("invalid parameter name");a+="; "+r+"="+De(t[r])}return a},parse:function(e){if(!e)throw new TypeError("argument string is required");var t="object"==typeof e?function(e){var t;"function"==typeof e.getHeader?t=e.getHeader("content-type"):"object"==typeof e.headers&&(t=e.headers&&e.headers["content-type"]);if("string"!=typeof t)throw new TypeError("content-type header is missing from object");return t}(e):e;if("string"!=typeof t)throw new TypeError("argument string is required to be a string");var n=t.indexOf(";"),a=-1!==n?t.substr(0,n).trim():t.trim();if(!Te.test(a))throw new TypeError("invalid media type");var r=new qe(a.toLowerCase());if(-1!==n){var i,s,o;for(Ae.lastIndex=n;s=Ae.exec(t);){if(s.index!==n)throw new TypeError("invalid parameter format");n+=s[0].length,i=s[1].toLowerCase(),'"'===(o=s[2])[0]&&(o=o.substr(1,o.length-2).replace(Ce,"$1")),r.parameters[i]=o}if(n!==t.length)throw new TypeError("invalid parameter format")}return r}},Ve=async e=>Object.entries(await e),Le=_((async(e,t)=>(await t).map(e))),Je=_((async(e,t,n)=>(await n).reduce((async(t,n)=>e(await t,n)),t))),Ue=_((async(e,t,n={})=>Je((async(t,n)=>await e(n)?t.concat([n]):t),[],t,n))),_e=_((async(e,t)=>{const n=await Le(e,t);return(await Promise.all(n)).some((e=>e))})),Be=_((async(e,t)=>{const n=await Le(e,t);return(await Promise.all(n)).every((e=>e))})),Fe=_(((e,t)=>e.reduce((async(e,t)=>t(await e)),t))),ze={entries:Ve,map:Le,filter:Ue,reduce:Je,some:_e,every:Be,pipeline:Fe,all:e=>Promise.all(e),allValues:e=>Fe([Ve,Je((async(e,[t,n])=>(e[t]=await n,e)),{})],e)};ze.entries,ze.map,ze.filter,ze.reduce,ze.some,ze.every,ze.pipeline,ze.all,ze.allValues;var Ke=fetch;const{jsonTypeOf:Ge,splitUrl:Ze,safeResolveUrl:We}=Q,He={},Xe={},Ye=(e,t)=>{const n=e in Xe?Xe[e]:e;if(n in He)return He[n][t]},Qe={},et={},tt=(e,t="",n="")=>{e=JSON.parse(JSON.stringify(e));const a=Ze(e.$schema||n)[0];if(!a)throw Error("Couldn't determine schema version");delete e.$schema;const r=Ye(a,"baseToken"),i=Ye(a,"anchorToken"),s=Ze(t)[0];if(!s&&!Ze(e[r]||"")[0])throw Error("Couldn't determine an identifier for the schema");const o=We(s,e[r]||""),[c,l]=Ze(o);delete e[r],l&&r===i&&(e[i]=i!==r?encodeURI(l):`#${encodeURI(l)}`),s&&(et[s]=c);const m={},p=Ye(a,"recursiveAnchorToken");let u;!0===e[p]&&(m[""]=c,e[i]="",delete e[p]);const f=Ye(a,"vocabularyToken");Ge(e[f],"object")?(Xe[c]=a,u=e[f],delete e[f]):(Xe[c]=a,u={[a]:!0});const d={"":""};return Qe[c]={id:c,schemaVersion:a,schema:nt(e,c,a,pe.nil,d,m),anchors:d,dynamicAnchors:m,vocabulary:u,validated:!1},Qe[c]},nt=(e,t,n,a,r,i)=>{if(Ge(e,"object")){const s="string"==typeof e.$schema?Ze(e.$schema)[0]:n,o=Ye(s,"embeddedToken"),c=Ye(s,"anchorToken");if("string"==typeof e[o]&&(o!==c||"#"!==e[o][0])){const a=We(t,e[o]);return e[o]=a,tt(e,a,n),de(e[o],e)}const l=Ye(n,"anchorToken"),m=Ye(n,"dynamicAnchorToken");"string"==typeof e[m]&&(i[e[m]]=t,r[e[m]]=a,delete e[m]);const p=Ye(n,"embeddedToken");if("string"==typeof e[l]){const t=l!==p?e[l]:e[l].slice(1);r[t]=a,delete e[l]}const u=Ye(n,"jrefToken");if("string"==typeof e[u])return de(e[u],e);for(let s in e)e[s]=nt(e[s],t,n,pe.append(s,a),r,i);return e}return Array.isArray(e)?e.map(((e,s)=>nt(e,t,n,pe.append(s,a),r,i))):e},at=e=>Qe[et[e]]||Qe[e],rt=Object.freeze({id:"",schemaVersion:void 0,vocabulary:{},pointer:pe.nil,schema:void 0,value:void 0,anchors:{},dynamicAnchors:{},validated:!0}),it=async(e,t=rt)=>{const n=We(ct(t),e),[a,r]=Ze(n);if(!(e=>e in Qe||e in et)(a)){const e=await Ke(a,{headers:{Accept:"application/schema+json"}});if(e.status>=400)throw await e.text(),Error(`Failed to retrieve schema with id: ${a}`);if(e.headers.has("content-type")){const t=Me.parse(e.headers.get("content-type")).type;if("application/schema+json"!==t)throw Error(`${a} is not a schema. Found a document with media type: ${t}`)}tt(await e.json(),a)}const i=at(a),s="/"!==r[0]?ot(i,r):r,o=Object.freeze({...i,pointer:s,value:pe.get(s,i.schema)});return st(o)},st=e=>he(e.value)?it(ye(e.value),e):e,ot=(e,t)=>{if(!(t in e.anchors))throw Error(`No such anchor '${encodeURI(e.id)}#${encodeURI(t)}'`);return e.anchors[t]},ct=e=>`${e.id}#${encodeURI(e.pointer)}`,lt=e=>he(e.value)?ve(e.value):e.value,mt=(e,t)=>{const n=at(t.id),a=Object.freeze({...t,pointer:pe.append(e,t.pointer),value:lt(t)[e],validated:n.validated});return st(a)},pt=_(((e,t)=>ze.pipeline([lt,ze.map((async(n,a)=>e(await mt(a,t),a))),ze.all],t)));var ut={setConfig:(e,t,n)=>{He[e]||(He[e]={}),He[e][t]=n},getConfig:Ye,add:tt,get:it,markValidated:e=>{Qe[e].validated=!0},uri:ct,value:lt,getAnchorPointer:ot,typeOf:(e,t)=>Ge(lt(e),t),has:(e,t)=>e in lt(t),step:mt,keys:e=>Object.keys(lt(e)),entries:e=>ze.pipeline([lt,Object.keys,ze.map((async t=>[t,await mt(t,e)])),ze.all],e),map:pt,length:e=>lt(e).length};ut.setConfig,ut.getConfig,ut.add,ut.get,ut.markValidated,ut.uri,ut.value,ut.getAnchorPointer,ut.typeOf,ut.has,ut.step,ut.keys,ut.entries,ut.map,ut.length;class ft extends Error{constructor(e){super("Invalid Schema"),this.name=this.constructor.name,this.output=e}}var dt=ft;const{splitUrl:ht}=Q,yt="FLAG",vt="BASIC",gt="DETAILED",$t="VERBOSE";let bt=gt,St=!0;const wt=async e=>{const t={metaData:{}};return{ast:t,schemaUri:await kt(e,t)}},Ot=_((({ast:e,schemaUri:t},n,a=yt)=>{if(![yt,vt,gt,$t].includes(a))throw Error(`The '${a}' error format is not supported`);let r=[];const i=z.subscribe("result",xt(a,r));return Rt(t,n,e,{}),z.unsubscribe(i),r[0]})),xt=(e,t)=>{const n=[];return(a,r)=>{if("result"===a){const{keyword:e,absoluteKeywordLocation:t,instanceLocation:a,valid:i}=r,s={keyword:e,absoluteKeywordLocation:t,instanceLocation:a,valid:i,errors:[]};n.push(s)}else if("result.start"===a)n.push(a);else if("result.end"===a){const a=n.pop();for(;"result.start"!==n[n.length-1];){const t=n.pop(),r=[t];e===vt&&(r.push(...t.errors),delete t.errors),(e===$t||e!==yt&&!t.valid)&&a.errors.unshift(...r)}n[n.length-1]=a,t[0]=a}}},jt={},It=e=>jt[e],Et=e=>e in jt,Pt={},At={},kt=async(e,t)=>{if(!Et(`${e.schemaVersion}#validate`)){const t=await ut.get(e.schemaVersion);(ut.getConfig(t.id,"mandatoryVocabularies")||[]).forEach((e=>{if(!t.vocabulary[e])throw Error(`Vocabulary '${e}' must be explicitly declared and required`)})),Object.entries(t.vocabulary).forEach((([e,n])=>{if(e in Pt)Object.entries(Pt[e]).forEach((([e,n])=>{((e,t)=>{jt[e]={collectEvaluatedItems:(e,n,a)=>t.interpret(e,n,a)&&new Set,collectEvaluatedProperties:(e,n,a)=>t.interpret(e,n,a)&&[],...t}})(`${t.id}#${e}`,n)}));else if(n)throw Error(`Missing required vocabulary: ${e}`)}))}if(St&&!e.validated){if(ut.markValidated(e.id),!(e.schemaVersion in At)){const t=await ut.get(e.schemaVersion),n={metaData:{}},a=await kt(t,n);At[t.id]=Ot({ast:n,schemaUri:a})}const t=Pe.cons(e.schema,e.id),n=At[e.schemaVersion](t,bt);if(!n.valid)throw new dt(n)}return e.id in t.metaData||(t.metaData[e.id]={id:e.id,dynamicAnchors:e.dynamicAnchors,anchors:e.anchors}),await It(`${e.schemaVersion}#validate`).compile(e,t),ut.uri(e)},Rt=(e,t,n,a)=>{const r=Ct(e,n),i=ht(e)[0];return It(r).interpret(e,t,n,{...n.metaData[i].dynamicAnchors,...a})},Ct=(e,t)=>{if(!(e in t))throw Error(`No schema found at ${e}`);return t[e][0]};var Nt={validate:async(e,t,n)=>{const a=await wt(e),r=(e,t=yt)=>Ot(a,Pe.cons(e),t);return void 0===t?r:r(t,n)},compile:wt,interpret:Ot,setMetaOutputFormat:e=>{bt=e},setShouldMetaValidate:e=>{St=e},FLAG:yt,BASIC:vt,DETAILED:gt,VERBOSE:$t,add:(e,t="",n="")=>{const{id:a}=ut.add(e,t,n);delete At[a]},getKeyword:It,hasKeyword:Et,defineVocabulary:(e,t)=>{Pt[e]=t},compileSchema:kt,interpretSchema:Rt,collectEvaluatedProperties:(e,t,n,a,r)=>{const i=Ct(e,n);return It(i).collectEvaluatedProperties(e,t,n,a,r)},collectEvaluatedItems:(e,t,n,a,r)=>{const i=Ct(e,n);return It(i).collectEvaluatedItems(e,t,n,a,r)}};var Tt={compile:e=>ut.value(e),interpret:()=>!0};var Dt={compile:async(e,t)=>{const n=ut.uri(e);if(!(n in t)){t[n]=!1;const a=ut.value(e);if(!["object","boolean"].includes(typeof a))throw Error(`No schema found at '${ut.uri(e)}'`);t[n]=[`${e.schemaVersion}#validate`,ut.uri(e),"boolean"==typeof a?a:await ze.pipeline([ut.entries,ze.map((([t,n])=>[`${e.schemaVersion}#${t}`,n])),ze.filter((([t])=>Nt.hasKeyword(t)&&t!==`${e.schemaVersion}#validate`)),ze.map((async([n,a])=>{const r=await Nt.getKeyword(n).compile(a,t,e);return[n,ut.uri(a),r]})),ze.all],e)]}return n},interpret:(e,t,n,a)=>{const[r,i,s]=n[e];z.publishSync("result.start");const o="boolean"==typeof s?s:s.every((([e,r,i])=>{z.publishSync("result.start");const s=Nt.getKeyword(e).interpret(i,t,n,a);return z.publishSync("result",{keyword:e,absoluteKeywordLocation:r,instanceLocation:Pe.uri(t),valid:s,ast:i}),z.publishSync("result.end"),s}));return z.publishSync("result",{keyword:r,absoluteKeywordLocation:i,instanceLocation:Pe.uri(t),valid:o,ast:e}),z.publishSync("result.end"),o},collectEvaluatedProperties:(e,t,n,a,r=!1)=>{const i=n[e][2];return"boolean"==typeof i?!!i&&[]:i.filter((([e])=>!r||!e.endsWith("#unevaluatedProperties"))).reduce(((e,[r,,i])=>{const s=e&&Nt.getKeyword(r).collectEvaluatedProperties(i,t,n,a);return!1!==s&&[...e,...s]}),[])},collectEvaluatedItems:(e,t,n,a,r=!1)=>{const i=n[e][2];return"boolean"==typeof i?!!i&&new Set:i.filter((([e])=>!r||!e.endsWith("#unevaluatedItems"))).reduce(((e,[r,,i])=>{const s=!1!==e&&Nt.getKeyword(r).collectEvaluatedItems(i,t,n,a);return!1!==s&&new Set([...e,...s])}),new Set)}},qt={metaData:Tt,validate:Dt},Mt={Core:Nt,Schema:ut,Instance:Pe,Keywords:qt};const{Core:Vt,Schema:Lt,Instance:Jt}=Mt;var Ut={compile:async(e,t,n)=>{const a=await Lt.step("items",n),r=Lt.typeOf(a,"array")?Lt.length(a):Number.MAX_SAFE_INTEGER;return Lt.typeOf(e,"boolean")?[r,Lt.value(e)]:[r,await Vt.compileSchema(e,t)]},interpret:([e,t],n,a,r)=>!Jt.typeOf(n,"array")||("string"==typeof t?Jt.every(((n,i)=>i<e||Vt.interpretSchema(t,n,a,r)),n):Jt.every(((n,a)=>a<e||t),n))};const{Core:_t,Schema:Bt,Instance:Ft}=Mt,zt=([e,t],n,a,r)=>!Ft.typeOf(n,"array")||Ft.every(((n,i)=>i<e||_t.interpretSchema(t,n,a,r)),n);var Kt={compile:async(e,t,n)=>{const a=await Bt.step("items",n);return[Bt.typeOf(a,"array")?Bt.length(a):Number.MAX_SAFE_INTEGER,await _t.compileSchema(e,t)]},interpret:zt,collectEvaluatedItems:(e,t,n,a)=>zt(e,t,n,a)&&new Set(Ft.map(((e,t)=>t),t))};const{Core:Gt,Schema:Zt,Instance:Wt}=Mt;var Ht={compile:async(e,t,n)=>{const a=await Zt.step("properties",n),r=Zt.typeOf(a,"object")?Zt.keys(a):[],i=await Zt.step("patternProperties",n),s=Zt.typeOf(i,"object")?Zt.keys(i).map((e=>new RegExp(e))):[];return Zt.typeOf(e,"boolean")?[r,s,Zt.value(e)]:[r,s,await Gt.compileSchema(e,t)]},interpret:([e,t,n],a,r,i)=>{if(!Wt.typeOf(a,"object"))return!0;const s=Wt.entries(a).filter((([n])=>!e.includes(n)&&!t.some((e=>e.test(n)))));return"string"==typeof n?s.every((([,e])=>Gt.interpretSchema(n,e,r,i))):0===s.length||n}};const{Core:Xt,Schema:Yt,Instance:Qt}=Mt,en=([e,t,n],a,r,i)=>!Qt.typeOf(a,"object")||Qt.entries(a).filter((([n])=>!e.includes(n)&&!t.some((e=>e.test(n))))).every((([,e])=>Xt.interpretSchema(n,e,r,i)));var tn={compile:async(e,t,n)=>{const a=await Yt.step("properties",n),r=Yt.typeOf(a,"object")?Yt.keys(a):[],i=await Yt.step("patternProperties",n);return[r,Yt.typeOf(i,"object")?Yt.keys(i).map((e=>new RegExp(e))):[],await Xt.compileSchema(e,t)]},interpret:en,collectEvaluatedProperties:(e,t,n,a)=>en(e,t,n,a)&&[new RegExp("")]};const{Core:nn,Schema:an}=Mt;var rn={compile:(e,t)=>ze.pipeline([an.map((async e=>nn.compileSchema(await e,t))),ze.all],e),interpret:(e,t,n,a)=>e.every((e=>nn.interpretSchema(e,t,n,a))),collectEvaluatedProperties:(e,t,n,a)=>e.reduce(((e,r)=>{const i=e&&nn.collectEvaluatedProperties(r,t,n,a);return!1!==i&&[...e,...i]}),[]),collectEvaluatedItems:(e,t,n,a)=>e.reduce(((e,r)=>{const i=!1!==e&&nn.collectEvaluatedItems(r,t,n,a);return!1!==i&&new Set([...e,...i])}),new Set)};const{Core:sn,Schema:on}=Mt;var cn={compile:(e,t)=>ze.pipeline([on.map((async e=>sn.compileSchema(await e,t))),ze.all],e),interpret:(e,t,n,a)=>e.filter((e=>sn.interpretSchema(e,t,n,a))).length>0,collectEvaluatedProperties:(e,t,n,a)=>e.reduce(((e,r)=>{const i=sn.collectEvaluatedProperties(r,t,n,a);return!1!==i?[...e||[],...i]:e}),!1),collectEvaluatedItems:(e,t,n,a)=>e.reduce(((e,r)=>{const i=sn.collectEvaluatedItems(r,t,n,a);return!1!==i?new Set([...e||[],...i]):e}),!1)},ln=Object.keys,mn=JSON.stringify;function pn(e,t){var n,a,r,i,s,o,c;if("string"===(c=typeof e))return mn(e);if(!0===e)return"true";if(!1===e)return"false";if(null===e)return"null";if(e instanceof Array){for(r="[",a=e.length-1,n=0;n<a;n++)r+=pn(e[n],!1)+",";return a>-1&&(r+=pn(e[n],!1)),r+"]"}if(e instanceof Object){if("function"==typeof e.toJSON)return pn(e.toJSON(),t);for(a=(i=ln(e).sort()).length,r="",n=0;n<a;)void 0!==(o=pn(e[s=i[n]],!0))&&(n&&""!==r&&(r+=","),r+=mn(s)+":"+o),n++;return"{"+r+"}"}switch(c){case"function":case"undefined":return t?void 0:null;default:return isFinite(e)?e:null}}var un=function(e){return""+pn(e,!1)};const{Schema:fn,Instance:dn}=Mt;var hn={compile:e=>un(fn.value(e)),interpret:(e,t)=>un(dn.value(t))===e};const{Core:yn,Instance:vn}=Mt;var gn={compile:(e,t)=>yn.compileSchema(e,t),interpret:(e,t,n,a)=>!vn.typeOf(t,"array")||vn.some((t=>yn.interpretSchema(e,t,n,a)),t)};const{Core:$n,Schema:bn,Instance:Sn}=Mt,wn=({contains:e,minContains:t,maxContains:n},a,r,i)=>{if(!Sn.typeOf(a,"array"))return!0;const s=Sn.reduce(((t,n)=>$n.interpretSchema(e,n,r,i)?t+1:t),0,a);return s>=t&&s<=n};var On={compile:async(e,t,n)=>{const a=await $n.compileSchema(e,t),r=await bn.step("minContains",n),i=bn.typeOf(r,"number")?bn.value(r):1,s=await bn.step("maxContains",n);return{contains:a,minContains:i,maxContains:bn.typeOf(s,"number")?bn.value(s):Number.MAX_SAFE_INTEGER}},interpret:wn,collectEvaluatedItems:(e,t,n,a)=>wn(e,t,n,a)&&Sn.reduce(((t,r,i)=>$n.interpretSchema(e.contains,r,n,a)?t.add(i):t),new Set,t)};const{Core:xn,Schema:jn}=Mt;var In={compile:async(e,t)=>{await ze.pipeline([jn.entries,ze.map((([,e])=>xn.compileSchema(e,t))),ze.all],e)},interpret:()=>!0};const{Core:En,Schema:Pn,Instance:An}=Mt;var kn={compile:(e,t)=>ze.pipeline([Pn.entries,ze.map((async([e,n])=>[e,Pn.typeOf(n,"array")?Pn.value(n):await En.compileSchema(n,t)])),ze.all],e),interpret:(e,t,n,a)=>{const r=An.value(t);return!An.typeOf(t,"object")||e.every((([e,i])=>!(e in r)||(Array.isArray(i)?i.every((e=>e in r)):En.interpretSchema(i,t,n,a))))}};const{Schema:Rn,Instance:Cn}=Mt;var Nn={compile:e=>ze.pipeline([Rn.entries,ze.map((([e,t])=>[e,Rn.value(t)])),ze.all],e),interpret:(e,t)=>{const n=Cn.value(t);return!Cn.typeOf(t,"object")||e.every((([e,t])=>!(e in n)||t.every((e=>e in n))))}};const{Core:Tn,Schema:Dn,Instance:qn}=Mt;var Mn={compile:(e,t)=>ze.pipeline([Dn.entries,ze.map((async([e,n])=>[e,await Tn.compileSchema(n,t)])),ze.all],e),interpret:(e,t,n,a)=>{const r=qn.value(t);return!qn.typeOf(t,"object")||e.every((([e,i])=>!(e in r)||Tn.interpretSchema(i,t,n,a)))},collectEvaluatedProperties:(e,t,n,a)=>e.reduce(((e,[r,i])=>{if(!e||!qn.has(r,t))return e;const s=Tn.collectEvaluatedProperties(i,t,n,a);return!1!==s&&e.concat(s)}),[])};const{Schema:Vn,Instance:Ln}=Mt;var Jn={compile:e=>Vn.value(e).map(un),interpret:(e,t)=>e.some((e=>un(Ln.value(t))===e))};const{Schema:Un,Instance:_n}=Mt;var Bn={compile:async e=>Un.value(e),interpret:(e,t)=>!_n.typeOf(t,"number")||_n.value(t)<e};const{Schema:Fn,Instance:zn}=Mt;var Kn={compile:async e=>Fn.value(e),interpret:(e,t)=>!zn.typeOf(t,"number")||zn.value(t)>e};const{Core:Gn}=Mt;var Zn={compile:(e,t)=>Gn.compileSchema(e,t),interpret:(e,t,n,a)=>(Gn.interpretSchema(e,t,n,a),!0),collectEvaluatedProperties:(e,t,n,a)=>Gn.collectEvaluatedProperties(e,t,n,a)||[],collectEvaluatedItems:(e,t,n,a)=>Gn.collectEvaluatedItems(e,t,n,a)||new Set};const{Core:Wn,Schema:Hn}=Mt,Xn=(e,t,n,a)=>{const r=n[e][2];return"boolean"==typeof r?r:r.every((([e,,r])=>Wn.getKeyword(e).interpret(r,t,n,a)))};var Yn={compile:async(e,t,n)=>{if(Hn.has("if",n)){const a=await Hn.step("if",n);return[await Wn.compileSchema(a,t),await Wn.compileSchema(e,t)]}return[]},interpret:([e,t],n,a,r)=>void 0===e||!Xn(e,n,a,r)||Wn.interpretSchema(t,n,a,r),collectEvaluatedProperties:([e,t],n,a,r)=>void 0!==e&&Xn(e,n,a,r)?Wn.collectEvaluatedProperties(t,n,a,r):[],collectEvaluatedItems:([e,t],n,a,r)=>void 0!==e&&Xn(e,n,a,r)?Wn.collectEvaluatedItems(t,n,a,r):new Set};const{Core:Qn,Schema:ea}=Mt,ta=(e,t,n,a)=>{const r=n[e][2];return"boolean"==typeof r?r:r.every((([e,,r])=>Qn.getKeyword(e).interpret(r,t,n,a)))};var na={compile:async(e,t,n)=>{if(ea.has("if",n)){const a=await ea.step("if",n);return[await Qn.compileSchema(a,t),await Qn.compileSchema(e,t)]}return[]},interpret:([e,t],n,a,r)=>void 0===e||ta(e,n,a,r)||Qn.interpretSchema(t,n,a,r),collectEvaluatedProperties:([e,t],n,a,r)=>void 0===e||ta(e,n,a,r)?[]:Qn.collectEvaluatedProperties(t,n,a,r),collectEvaluatedItems:([e,t],n,a,r)=>void 0===e||ta(e,n,a,r)?new Set:Qn.collectEvaluatedItems(t,n,a,r)};const{Core:aa,Schema:ra,Instance:ia}=Mt,sa=(e,t,n,a)=>!ia.typeOf(t,"array")||("string"==typeof e?ia.every((t=>aa.interpretSchema(e,t,n,a)),t):ia.every(((t,r)=>!(r in e)||aa.interpretSchema(e[r],t,n,a)),t));var oa={compile:(e,t)=>ra.typeOf(e,"array")?ze.pipeline([ra.map((e=>aa.compileSchema(e,t))),ze.all],e):aa.compileSchema(e,t),interpret:sa,collectEvaluatedItems:(e,t,n,a)=>sa(e,t,n,a)&&("string"==typeof e?new Set(ia.map(((e,t)=>t),t)):new Set(e.map(((e,t)=>t))))};const{Core:ca,Schema:la,Instance:ma}=Mt,pa=([e,t],n,a,r)=>!ma.typeOf(n,"array")||ma.every(((n,i)=>i<e||ca.interpretSchema(t,n,a,r)),n);var ua={compile:async(e,t,n)=>{const a=await la.step("prefixItems",n);return[la.typeOf(a,"array")?la.length(a):0,await ca.compileSchema(e,t)]},interpret:pa,collectEvaluatedItems:(e,t,n,a)=>pa(e,t,n,a)&&new Set(ma.map(((e,t)=>t),t))};const{Schema:fa,Instance:da}=Mt;var ha={compile:e=>fa.value(e),interpret:(e,t)=>!da.typeOf(t,"array")||da.length(t)<=e};const{Schema:ya,Instance:va}=Mt;var ga={compile:e=>ya.value(e),interpret:(e,t)=>!va.typeOf(t,"string")||va.length(t)<=e};const{Schema:$a,Instance:ba}=Mt;var Sa={compile:e=>$a.value(e),interpret:(e,t)=>!ba.typeOf(t,"string")||[...ba.value(t)].length<=e};const{Schema:wa,Instance:Oa}=Mt;var xa={compile:e=>wa.value(e),interpret:(e,t)=>!Oa.typeOf(t,"object")||Oa.keys(t).length<=e};const{Schema:ja,Instance:Ia}=Mt;var Ea={compile:async(e,t,n)=>{const a=await ja.step("exclusiveMaximum",n),r=ja.value(a);return[ja.value(e),r]},interpret:([e,t],n)=>{if(!Ia.typeOf(n,"number"))return!0;const a=Ia.value(n);return t?a<e:a<=e}};const{Schema:Pa,Instance:Aa}=Mt;var ka={compile:async e=>Pa.value(e),interpret:(e,t)=>!Aa.typeOf(t,"number")||Aa.value(t)<=e};const{Schema:Ra,Instance:Ca}=Mt;var Na={compile:e=>Ra.value(e),interpret:(e,t)=>!Ca.typeOf(t,"array")||Ca.length(t)>=e};const{Schema:Ta,Instance:Da}=Mt;var qa={compile:e=>Ta.value(e),interpret:(e,t)=>!Da.typeOf(t,"string")||Da.value(t).length>=e};const{Schema:Ma,Instance:Va}=Mt;var La={compile:e=>Ma.value(e),interpret:(e,t)=>!Va.typeOf(t,"string")||[...Va.value(t)].length>=e};const{Schema:Ja,Instance:Ua}=Mt;var _a={compile:e=>Ja.value(e),interpret:(e,t)=>{const n=Ua.value(t);return!Ua.typeOf(t,"object")||Object.keys(n).length>=e}};const{Schema:Ba,Instance:Fa}=Mt;var za={compile:async(e,t,n)=>{const a=await Ba.step("exclusiveMinimum",n),r=Ba.value(a);return[Ba.value(e),r]},interpret:([e,t],n)=>{if(!Fa.typeOf(n,"number"))return!0;const a=Fa.value(n);return t?a>e:a>=e}};const{Schema:Ka,Instance:Ga}=Mt;var Za={compile:async e=>Ka.value(e),interpret:(e,t)=>!Ga.typeOf(t,"number")||Ga.value(t)>=e};const{Schema:Wa,Instance:Ha}=Mt,Xa=(e,t)=>Math.abs(e-t)<1.1920929e-7;var Ya={compile:e=>Wa.value(e),interpret:(e,t)=>{if(!Ha.typeOf(t,"number"))return!0;const n=Ha.value(t)%e;return Xa(0,n)||Xa(e,n)}};const{Core:Qa}=Mt;var er={compile:Qa.compileSchema,interpret:(e,t,n,a)=>!Qa.interpretSchema(e,t,n,a)};const{Core:tr,Schema:nr}=Mt;var ar={compile:(e,t)=>ze.pipeline([nr.map((async e=>tr.compileSchema(await e,t))),ze.all],e),interpret:(e,t,n,a)=>{let r=0;for(const i of e)if(tr.interpretSchema(i,t,n,a)&&r++,r>1)break;return 1===r},collectEvaluatedProperties:(e,t,n,a)=>{let r=0;return e.reduce(((e,i)=>{if(r>1)return!1;const s=tr.collectEvaluatedProperties(i,t,n,a);return s?0==r++&&s:e}),!1)},collectEvaluatedItems:(e,t,n,a)=>{let r=0;return e.reduce(((e,i)=>{if(r>1)return!1;const s=tr.collectEvaluatedItems(i,t,n,a);return s?0==r++&&s:e}),!1)}};const{Schema:rr,Instance:ir}=Mt;var sr={compile:e=>new RegExp(rr.value(e),"u"),interpret:(e,t)=>!ir.typeOf(t,"string")||e.test(ir.value(t))};const{Core:or,Schema:cr,Instance:lr}=Mt,mr=(e,t,n,a)=>!lr.typeOf(t,"object")||e.every((([e,r])=>lr.entries(t).filter((([t])=>e.test(t))).every((([,e])=>or.interpretSchema(r,e,n,a)))));var pr={compile:(e,t)=>ze.pipeline([cr.entries,ze.map((async([e,n])=>[new RegExp(e,"u"),await or.compileSchema(n,t)])),ze.all],e),interpret:mr,collectEvaluatedProperties:(e,t,n,a)=>mr(e,t,n,a)&&e.map((([e])=>e))};var ur={isObject:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,escapeRegExp:e=>e.replace(/[.*+\-?^${}()|[\]\\]/g,"\\$&")};const{Core:fr,Schema:dr,Instance:hr}=Mt,{escapeRegExp:yr}=ur,vr=(e,t,n,a)=>!hr.typeOf(t,"object")||hr.entries(t).filter((([t])=>t in e)).every((([t,r])=>fr.interpretSchema(e[t],r,n,a)));var gr={compile:(e,t)=>ze.pipeline([dr.entries,ze.reduce((async(e,[n,a])=>(e[n]=await fr.compileSchema(a,t),e)),Object.create(null))],e),interpret:vr,collectEvaluatedProperties:(e,t,n,a)=>vr(e,t,n,a)&&Object.keys(e).map((e=>new RegExp(`^${yr(e)}$`)))};const{Core:$r,Instance:br}=Mt;var Sr={compile:(e,t)=>$r.compileSchema(e,t),interpret:(e,t,n,a)=>!br.typeOf(t,"object")||br.keys(t).every((t=>$r.interpretSchema(e,br.cons(t),n,a)))};const{Core:wr,Schema:Or}=Mt,{safeResolveUrl:xr,splitUrl:jr}=Q;var Ir={compile:e=>{const t=xr(e.id,Or.value(e));return jr(t)},interpret:([e,t],n,a,r)=>{const i=t in a.metaData[e].dynamicAnchors?r[t]:e,s=Or.getAnchorPointer(a.metaData[i],t);return wr.interpretSchema(`${i}#${s}`,n,a,r)},collectEvaluatedProperties:wr.collectEvaluatedProperties,collectEvaluatedItems:wr.collectEvaluatedItems};const{Core:Er,Schema:Pr}=Mt;var Ar={compile:async(e,t)=>{const n=await Pr.get(Pr.value(e),e);return Er.compileSchema(n,t)},interpret:Er.interpretSchema,collectEvaluatedProperties:Er.collectEvaluatedProperties,collectEvaluatedItems:Er.collectEvaluatedItems};const{Schema:kr,Instance:Rr}=Mt;var Cr={compile:e=>kr.value(e),interpret:(e,t)=>!Rr.typeOf(t,"object")||e.every((e=>Rr.value(t).hasOwnProperty(e)))};const{Core:Nr,Schema:Tr,Instance:Dr}=Mt,qr=(e,t,n,a)=>!Dr.typeOf(t,"array")||Dr.every(((t,r)=>!(r in e)||Nr.interpretSchema(e[r],t,n,a)),t);var Mr={compile:(e,t)=>ze.pipeline([Tr.map((e=>Nr.compileSchema(e,t))),ze.all],e),interpret:qr,collectEvaluatedItems:(e,t,n,a)=>qr(e,t,n,a)&&new Set(e.map(((e,t)=>t)))};const{Schema:Vr,Instance:Lr}=Mt;var Jr={compile:e=>Vr.value(e),interpret:(e,t)=>"string"==typeof e?Lr.typeOf(t,e):e.some(Lr.typeOf(t))};const{Core:Ur,Schema:_r,Instance:Br}=Mt,Fr=([e,t],n,a,r)=>{if(!Br.typeOf(n,"array"))return!0;const i=Ur.collectEvaluatedItems(e,n,a,r,!0);return!1===i||Br.every(((e,s)=>i.has(s)||Ur.interpretSchema(t,Br.step(s,n),a,r)),n)};var zr={compile:async(e,t,n)=>[_r.uri(n),await Ur.compileSchema(e,t)],interpret:Fr,collectEvaluatedItems:(e,t,n,a)=>Fr(e,t,n,a)&&new Set(Br.map(((e,t)=>t),t))};const{Core:Kr,Schema:Gr,Instance:Zr}=Mt,Wr=([e,t],n,a,r)=>{if(!Zr.typeOf(n,"object"))return!0;const i=Kr.collectEvaluatedProperties(e,n,a,r,!0);return!i||Zr.entries(n).filter((([e])=>!i.some((t=>e.match(t))))).every((([,e])=>Kr.interpretSchema(t,e,a,r)))};var Hr={compile:async(e,t,n)=>[Gr.uri(n),await Kr.compileSchema(e,t)],interpret:Wr,collectEvaluatedProperties:(e,t,n,a)=>Wr(e,t,n,a)&&[new RegExp("")]};const{Schema:Xr,Instance:Yr}=Mt;var Qr={compile:e=>Xr.value(e),interpret:(e,t)=>{if(!Yr.typeOf(t,"array")||!1===e)return!0;const n=Yr.map((e=>un(Yr.value(e))),t);return new Set(n).size===n.length}};const{Keywords:ei}=Mt;var ti={additionalItems:Ut,additionalItems6:Kt,additionalProperties:Ht,additionalProperties6:tn,allOf:rn,anyOf:cn,const:hn,contains:gn,containsMinContainsMaxContains:On,definitions:In,dependencies:kn,dependentRequired:Nn,dependentSchemas:Mn,enum:Jn,exclusiveMaximum:Bn,exclusiveMinimum:Kn,if:Zn,then:Yn,else:na,items:oa,items202012:ua,maxItems:ha,maxLength:ga,maxLength6:Sa,maxProperties:xa,maximumExclusiveMaximum:Ea,maximum:ka,metaData:ei.metaData,minItems:Na,minLength:qa,minLength6:La,minProperties:_a,minimumExclusiveMinimum:za,minimum:Za,multipleOf:Ya,not:er,oneOf:ar,pattern:sr,patternProperties:pr,properties:gr,propertyNames:Sr,dynamicRef:Ir,ref:Ar,required:Cr,tupleItems:Mr,type:Jr,unevaluatedItems:zr,unevaluatedProperties:Hr,uniqueItems:Qr,validate:ei.validate};const{Core:ni,Schema:ai}=Mt,ri="http://json-schema.org/draft-04/schema";ai.setConfig(ri,"baseToken","id"),ai.setConfig(ri,"embeddedToken","id"),ai.setConfig(ri,"anchorToken","id"),ai.setConfig(ri,"jrefToken","$ref"),ai.add(JSON.parse('{\n    "id": "http://json-schema.org/draft-04/schema#",\n    "$schema": "http://json-schema.org/draft-04/schema#",\n    "description": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "positiveInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "positiveIntegerDefault0": {\n            "allOf": [ { "$ref": "#/definitions/positiveInteger" }, { "default": 0 } ]\n        },\n        "simpleTypes": {\n            "enum": [ "array", "boolean", "integer", "null", "number", "object", "string" ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "minItems": 1,\n            "uniqueItems": true\n        }\n    },\n    "type": "object",\n    "properties": {\n        "id": {\n            "type": "string"\n        },\n        "$schema": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "multipleOf": {\n            "type": "number",\n            "minimum": 0,\n            "exclusiveMinimum": true\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "boolean",\n            "default": false\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxLength": { "$ref": "#/definitions/positiveInteger" },\n        "minLength": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/positiveInteger" },\n        "minItems": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxProperties": { "$ref": "#/definitions/positiveInteger" },\n        "minProperties": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "dependencies": {\n        "exclusiveMaximum": [ "maximum" ],\n        "exclusiveMinimum": [ "minimum" ]\n    },\n    "default": {}\n}')),ni.defineVocabulary(ri,{validate:ti.validate,additionalItems:ti.additionalItems,additionalProperties:ti.additionalProperties,allOf:ti.allOf,anyOf:ti.anyOf,default:ti.metaData,definitions:ti.definitions,dependencies:ti.dependencies,description:ti.metaData,enum:ti.enum,format:ti.metaData,items:ti.items,maxItems:ti.maxItems,maxLength:ti.maxLength,maxProperties:ti.maxProperties,maximum:ti.maximumExclusiveMaximum,minItems:ti.minItems,minLength:ti.minLength,minProperties:ti.minProperties,minimum:ti.minimumExclusiveMinimum,multipleOf:ti.multipleOf,not:ti.not,oneOf:ti.oneOf,pattern:ti.pattern,patternProperties:ti.patternProperties,properties:ti.properties,required:ti.required,title:ti.metaData,type:ti.type,uniqueItems:ti.uniqueItems});const ii="http://json-schema.org/draft-04/hyper-schema";ai.setConfig(ii,"baseToken","id"),ai.setConfig(ii,"embeddedToken","id"),ai.setConfig(ii,"anchorToken","id"),ai.setConfig(ii,"jrefToken","$ref"),ai.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-04/hyper-schema#",\n    "id": "http://json-schema.org/draft-04/hyper-schema#",\n    "title": "JSON Hyper-Schema",\n    "allOf": [\n        {"$ref": "http://json-schema.org/draft-04/schema#"}\n    ],\n    "properties": {\n        "additionalItems": {\n            "anyOf": [\n                {"type": "boolean"},\n                {"$ref": "#"}\n            ]\n        },\n        "additionalProperties": {\n            "anyOf": [\n                {"type": "boolean"},\n                {"$ref": "#"}\n            ]\n        },\n        "dependencies": {\n            "additionalProperties": {\n                "anyOf": [\n                    {"$ref": "#"},\n                    {"type": "array"}\n                ]\n            }\n        },\n        "items": {\n            "anyOf": [\n                {"$ref": "#"},\n                {"$ref": "#/definitions/schemaArray"}\n            ]\n        },\n        "definitions": {\n            "additionalProperties": {"$ref": "#"}\n        },\n        "patternProperties": {\n            "additionalProperties": {"$ref": "#"}\n        },\n        "properties": {\n            "additionalProperties": {"$ref": "#"}\n        },\n        "allOf": {"$ref": "#/definitions/schemaArray"},\n        "anyOf": {"$ref": "#/definitions/schemaArray"},\n        "oneOf": {"$ref": "#/definitions/schemaArray"},\n        "not": { "$ref": "#" },\n\n        "links": {\n            "type": "array",\n            "items": {"$ref": "#/definitions/linkDescription"}\n        },\n        "fragmentResolution": {\n            "type": "string"\n        },\n        "media": {\n            "type": "object",\n            "properties": {\n                "type": {\n                    "description": "A media type, as described in RFC 2046",\n                    "type": "string"\n                },\n                "binaryEncoding": {\n                    "description": "A content encoding scheme, as described in RFC 2045",\n                    "type": "string"\n                }\n            }\n        },\n        "pathStart": {\n            "description": "Instances\' URIs must start with this value for this schema to apply to them",\n            "type": "string",\n            "format": "uri"\n        }\n    },\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "items": {"$ref": "#"}\n        },\n        "linkDescription": {\n            "title": "Link Description Object",\n            "type": "object",\n            "required": ["href", "rel"],\n            "properties": {\n                "href": {\n                    "description": "a URI template, as defined by RFC 6570, with the addition of the $, ( and ) characters for pre-processing",\n                    "type": "string"\n                },\n                "rel": {\n                    "description": "relation to the target resource of the link",\n                    "type": "string"\n                },\n                "title": {\n                    "description": "a title for the link",\n                    "type": "string"\n                },\n                "targetSchema": {\n                    "description": "JSON Schema describing the link target",\n                    "$ref": "#"\n                },\n                "mediaType": {\n                    "description": "media type (as defined by RFC 2046) describing the link target",\n                    "type": "string"\n                },\n                "method": {\n                    "description": "method for requesting the target of the link (e.g. for HTTP this might be \\"GET\\" or \\"DELETE\\")",\n                    "type": "string"\n                },\n                "encType": {\n                    "description": "The media type in which to submit data along with the request",\n                    "type": "string",\n                    "default": "application/json"\n                },\n                "schema": {\n                    "description": "Schema describing the data to submit along with the request",\n                    "$ref": "#"\n                }\n            }\n        },\n        "readOnly": {\n            "description": "If true, indicates that the value of this property is controlled by the server.",\n            "type": "boolean",\n            "default": false\n        }\n    },\n    "links": [\n        {\n            "rel": "self",\n            "href": "{+id}"\n        },\n        {\n            "rel": "full",\n            "href": "{+($ref)}"\n        }\n    ]\n}')),ni.defineVocabulary(ii,{validate:ti.validate,additionalItems:ti.additionalItems,additionalProperties:ti.additionalProperties,allOf:ti.allOf,anyOf:ti.anyOf,default:ti.metaData,definitions:ti.definitions,dependencies:ti.dependencies,description:ti.metaData,enum:ti.enum,format:ti.metaData,fragmentResolution:ti.metaData,items:ti.items,maxItems:ti.maxItems,minProperties:ti.minProperties,maxProperties:ti.maxProperties,maximum:ti.maximumExclusiveMaximum,media:ti.metaData,minItems:ti.minItems,minLength:ti.minLength,maxLength:ti.maxLength,minimum:ti.minimumExclusiveMinimum,multipleOf:ti.multipleOf,links:ti.metaData,not:ti.not,oneOf:ti.oneOf,pathStart:ti.metaData,pattern:ti.pattern,patternProperties:ti.patternProperties,properties:ti.properties,readOnly:ti.metaData,required:ti.required,title:ti.metaData,type:ti.type,uniqueItems:ti.uniqueItems});const{Core:si,Schema:oi}=Mt,ci="http://json-schema.org/draft-06/schema";oi.setConfig(ci,"baseToken","$id"),oi.setConfig(ci,"embeddedToken","$id"),oi.setConfig(ci,"anchorToken","$id"),oi.setConfig(ci,"jrefToken","$ref"),oi.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-06/schema#",\n    "$id": "http://json-schema.org/draft-06/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "examples": {\n            "type": "array",\n            "items": {}\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": {},\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": {}\n}')),si.defineVocabulary(ci,{validate:ti.validate,additionalItems:ti.additionalItems6,additionalProperties:ti.additionalProperties6,allOf:ti.allOf,anyOf:ti.anyOf,const:ti.const,contains:ti.contains,default:ti.metaData,definitions:ti.definitions,dependencies:ti.dependencies,description:ti.metaData,enum:ti.enum,examples:ti.metaData,exclusiveMaximum:ti.exclusiveMaximum,exclusiveMinimum:ti.exclusiveMinimum,format:ti.metaData,items:ti.items,maxItems:ti.maxItems,maxLength:ti.maxLength6,maxProperties:ti.maxProperties,maximum:ti.maximum,minItems:ti.minItems,minLength:ti.minLength6,minProperties:ti.minProperties,minimum:ti.minimum,multipleOf:ti.multipleOf,not:ti.not,oneOf:ti.oneOf,pattern:ti.pattern,patternProperties:ti.patternProperties,properties:ti.properties,propertyNames:ti.propertyNames,required:ti.required,title:ti.metaData,type:ti.type,uniqueItems:ti.uniqueItems});const{Core:li,Schema:mi}=Mt,pi="http://json-schema.org/draft-07/schema";mi.setConfig(pi,"baseToken","$id"),mi.setConfig(pi,"embeddedToken","$id"),mi.setConfig(pi,"anchorToken","$id"),mi.setConfig(pi,"jrefToken","$ref"),mi.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-07/schema#",\n    "$id": "http://json-schema.org/draft-07/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": true\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true,\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "if": { "$ref": "#" },\n        "then": { "$ref": "#" },\n        "else": { "$ref": "#" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": true\n}')),li.defineVocabulary(pi,{validate:ti.validate,additionalItems:ti.additionalItems6,additionalProperties:ti.additionalProperties6,allOf:ti.allOf,anyOf:ti.anyOf,const:ti.const,contains:ti.contains,default:ti.metaData,definitions:ti.definitions,dependencies:ti.dependencies,description:ti.metaData,enum:ti.enum,exclusiveMaximum:ti.exclusiveMaximum,exclusiveMinimum:ti.exclusiveMinimum,format:ti.metaData,if:ti.if,then:ti.then,else:ti.else,items:ti.items,maxItems:ti.maxItems,maxLength:ti.maxLength6,maxProperties:ti.maxProperties,maximum:ti.maximum,minItems:ti.minItems,minLength:ti.minLength6,minProperties:ti.minProperties,minimum:ti.minimum,multipleOf:ti.multipleOf,not:ti.not,oneOf:ti.oneOf,pattern:ti.pattern,patternProperties:ti.patternProperties,properties:ti.properties,propertyNames:ti.propertyNames,readOnly:ti.metaData,required:ti.required,title:ti.metaData,type:ti.type,uniqueItems:ti.uniqueItems,writeOnly:ti.metaData});const{Core:ui,Schema:fi}=Mt,di="https://json-schema.org/draft/2019-09/schema";fi.setConfig(di,"baseToken","$id"),fi.setConfig(di,"embeddedToken","$id"),fi.setConfig(di,"anchorToken","$anchor"),fi.setConfig(di,"recursiveAnchorToken","$recursiveAnchor"),fi.setConfig(di,"vocabularyToken","$vocabulary"),fi.setConfig(di,"mandatoryVocabularies",["https://json-schema.org/draft/2019-09/vocab/core"]),fi.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$id": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/core": true,\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true,\n        "https://json-schema.org/draft/2019-09/vocab/validation": true,\n        "https://json-schema.org/draft/2019-09/vocab/meta-data": true,\n        "https://json-schema.org/draft/2019-09/vocab/format": false,\n        "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$recursiveRef": "#" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),fi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/core",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/core": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z][-A-Za-z0-9.:_]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveAnchor": {\n            "type": "boolean",\n            "default": false\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        }\n    }\n}')),ui.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/core",{validate:ti.validate,$defs:ti.definitions,$recursiveRef:ti.dynamicRef,$ref:ti.ref}),fi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/applicator",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Applicator vocabulary meta-schema",\n    "properties": {\n        "additionalItems": { "$recursiveRef": "#" },\n        "unevaluatedItems": { "$recursiveRef": "#" },\n        "items": {\n            "anyOf": [\n                { "$recursiveRef": "#" },\n                { "$ref": "#/$defs/schemaArray" }\n            ]\n        },\n        "contains": { "$recursiveRef": "#" },\n        "additionalProperties": { "$recursiveRef": "#" },\n        "unevaluatedProperties": { "$recursiveRef": "#" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$recursiveRef": "#"\n            }\n        },\n        "propertyNames": { "$recursiveRef": "#" },\n        "if": { "$recursiveRef": "#" },\n        "then": { "$recursiveRef": "#" },\n        "else": { "$recursiveRef": "#" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$recursiveRef": "#" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$recursiveRef": "#" }\n        }\n    }\n}')),ui.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/applicator",{additionalItems:ti.additionalItems6,additionalProperties:ti.additionalProperties6,allOf:ti.allOf,anyOf:ti.anyOf,contains:ti.containsMinContainsMaxContains,dependentSchemas:ti.dependentSchemas,if:ti.if,then:ti.then,else:ti.else,items:ti.items,not:ti.not,oneOf:ti.oneOf,patternProperties:ti.patternProperties,properties:ti.properties,propertyNames:ti.propertyNames,unevaluatedItems:ti.unevaluatedItems,unevaluatedProperties:ti.unevaluatedProperties}),fi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/validation",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/validation": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),ui.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/validation",{const:ti.const,dependentRequired:ti.dependentRequired,enum:ti.enum,exclusiveMaximum:ti.exclusiveMaximum,exclusiveMinimum:ti.exclusiveMinimum,maxItems:ti.maxItems,maxLength:ti.maxLength6,maxProperties:ti.maxProperties,maximum:ti.maximum,minItems:ti.minItems,minLength:ti.minLength6,minProperties:ti.minProperties,minimum:ti.minimum,multipleOf:ti.multipleOf,pattern:ti.pattern,required:ti.required,type:ti.type,uniqueItems:ti.uniqueItems}),fi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/meta-data": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),ui.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/meta-data",{default:ti.metaData,deprecated:ti.metaData,description:ti.metaData,examples:ti.metaData,readOnly:ti.metaData,title:ti.metaData,writeOnly:ti.metaData}),fi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/format",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/format": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Format vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),fi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/content",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$recursiveRef": "#" }\n    }\n}')),ui.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/content",{contentEncoding:ti.metaData,contentMediaType:ti.metaData,contentSchema:ti.metaData});const{Core:hi,Schema:yi}=Mt,vi="https://json-schema.org/draft/2020-12/schema";yi.setConfig(vi,"baseToken","$id"),yi.setConfig(vi,"embeddedToken","$id"),yi.setConfig(vi,"anchorToken","$anchor"),yi.setConfig(vi,"dynamicAnchorToken","$dynamicAnchor"),yi.setConfig(vi,"vocabularyToken","$vocabulary"),yi.setConfig(vi,"mandatoryVocabularies",["https://json-schema.org/draft/2020-12/vocab/core"]),yi.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$id": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/core": true,\n        "https://json-schema.org/draft/2020-12/vocab/applicator": true,\n        "https://json-schema.org/draft/2020-12/vocab/unevaluated": true,\n        "https://json-schema.org/draft/2020-12/vocab/validation": true,\n        "https://json-schema.org/draft/2020-12/vocab/meta-data": true,\n        "https://json-schema.org/draft/2020-12/vocab/format-annotation": true,\n        "https://json-schema.org/draft/2020-12/vocab/content": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/unevaluated"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format-annotation"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$dynamicRef": "#meta" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),yi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/core",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/core": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z_][-A-Za-z0-9._]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$dynamicRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$dynamicAnchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z_][-A-Za-z0-9._]*$"\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        }\n    }\n}')),hi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/core",{validate:ti.validate,$defs:ti.definitions,$dynamicRef:ti.dynamicRef,$ref:ti.ref}),yi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/applicator",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/applicator": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Applicator vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "prefixItems": { "$ref": "#/$defs/schemaArray" },\n        "items": { "$dynamicRef": "#meta" },\n        "contains": { "$dynamicRef": "#meta" },\n        "additionalProperties": { "$dynamicRef": "#meta" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$dynamicRef": "#meta"\n            }\n        },\n        "propertyNames": { "$dynamicRef": "#meta" },\n        "if": { "$dynamicRef": "#meta" },\n        "then": { "$dynamicRef": "#meta" },\n        "else": { "$dynamicRef": "#meta" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$dynamicRef": "#meta" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$dynamicRef": "#meta" }\n        }\n    }\n}')),hi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/applicator",{additionalProperties:ti.additionalProperties6,allOf:ti.allOf,anyOf:ti.anyOf,contains:ti.containsMinContainsMaxContains,dependentSchemas:ti.dependentSchemas,if:ti.if,then:ti.then,else:ti.else,items:ti.items202012,not:ti.not,oneOf:ti.oneOf,patternProperties:ti.patternProperties,prefixItems:ti.tupleItems,properties:ti.properties,propertyNames:ti.propertyNames}),yi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/validation",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/validation": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),hi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/validation",{const:ti.const,dependentRequired:ti.dependentRequired,enum:ti.enum,exclusiveMaximum:ti.exclusiveMaximum,exclusiveMinimum:ti.exclusiveMinimum,maxItems:ti.maxItems,maxLength:ti.maxLength6,maxProperties:ti.maxProperties,maximum:ti.maximum,minItems:ti.minItems,minLength:ti.minLength6,minProperties:ti.minProperties,minimum:ti.minimum,multipleOf:ti.multipleOf,pattern:ti.pattern,required:ti.required,type:ti.type,uniqueItems:ti.uniqueItems}),yi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/meta-data": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),hi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/meta-data",{default:ti.metaData,deprecated:ti.metaData,description:ti.metaData,examples:ti.metaData,readOnly:ti.metaData,title:ti.metaData,writeOnly:ti.metaData}),yi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/format-annotation",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/format-annotation": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Format vocabulary meta-schema for annotation results",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),hi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/format-annotation",{format:ti.metaData}),yi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/format-assertion",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/format-assertion": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Format vocabulary meta-schema for assertion results",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),yi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/content",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/content": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$dynamicRef": "#meta" }\n    }\n}')),hi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/content",{contentEncoding:ti.metaData,contentMediaType:ti.metaData,contentSchema:ti.metaData}),yi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/unevaluated",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/unevaluated": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Unevaluated applicator vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "unevaluatedItems": { "$dynamicRef": "#meta" },\n        "unevaluatedProperties": { "$dynamicRef": "#meta" }\n    }\n}')),hi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/unevaluated",{unevaluatedItems:ti.unevaluatedItems,unevaluatedProperties:ti.unevaluatedProperties});const{Core:gi,Schema:$i}=Mt;var bi={add:gi.add,get:$i.get,validate:gi.validate,compile:gi.compile,interpret:gi.interpret,setMetaOutputFormat:gi.setMetaOutputFormat,setShouldMetaValidate:gi.setShouldMetaValidate,FLAG:gi.FLAG,BASIC:gi.BASIC,DETAILED:gi.DETAILED,VERBOSE:gi.VERBOSE,Keywords:ti};bi.add,bi.get,bi.validate,bi.compile,bi.interpret,bi.setMetaOutputFormat,bi.setShouldMetaValidate,bi.FLAG,bi.BASIC,bi.DETAILED,bi.VERBOSE,bi.Keywords;var Si=F((function(e){var t,n;t=B,n=function(){var e=Object.prototype.hasOwnProperty,t=Object.prototype.toString,n="boolean"==typeof(new RegExp).sticky;function a(e){return e&&"[object RegExp]"===t.call(e)}function r(e){return e&&"object"==typeof e&&!a(e)&&!Array.isArray(e)}function i(e){return"("+e+")"}function s(e){return e.length?"(?:"+e.map((function(e){return"(?:"+e+")"})).join("|")+")":"(?!)"}function o(e){if("string"==typeof e)return"(?:"+e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")+")";if(a(e)){if(e.ignoreCase)throw new Error("RegExp /i flag not allowed");if(e.global)throw new Error("RegExp /g flag is implied");if(e.sticky)throw new Error("RegExp /y flag is implied");if(e.multiline)throw new Error("RegExp /m flag is implied");return e.source}throw new Error("Not a pattern: "+e)}function c(t,n){if(r(n)||(n={match:n}),n.include)throw new Error("Matching rules cannot also include states");var i={defaultType:t,lineBreaks:!!n.error||!!n.fallback,pop:!1,next:null,push:null,error:!1,fallback:!1,value:null,type:null,shouldThrow:!1};for(var s in n)e.call(n,s)&&(i[s]=n[s]);if("string"==typeof i.type&&t!==i.type)throw new Error("Type transform cannot be a string (type '"+i.type+"' for token '"+t+"')");var o=i.match;return i.match=Array.isArray(o)?o:o?[o]:[],i.match.sort((function(e,t){return a(e)&&a(t)?0:a(t)?-1:a(e)?1:t.length-e.length})),i}function l(e){return Array.isArray(e)?function(e){for(var t=[],n=0;n<e.length;n++){var a=e[n];if(a.include)for(var r=[].concat(a.include),i=0;i<r.length;i++)t.push({include:r[i]});else{if(!a.type)throw new Error("Rule has no type: "+JSON.stringify(a));t.push(c(a.type,a))}}return t}(e):function(e){for(var t=Object.getOwnPropertyNames(e),n=[],a=0;a<t.length;a++){var i=t[a],s=e[i],o=[].concat(s);if("include"!==i){var l=[];o.forEach((function(e){r(e)?(l.length&&n.push(c(i,l)),n.push(c(i,e)),l=[]):l.push(e)})),l.length&&n.push(c(i,l))}else for(var m=0;m<o.length;m++)n.push({include:o[m]})}return n}(e)}var m=c("error",{lineBreaks:!0,shouldThrow:!0});function p(e,t){for(var r=null,c=Object.create(null),l=!0,p=null,u=[],f=[],d=0;d<e.length;d++)e[d].fallback&&(l=!1);for(d=0;d<e.length;d++){var h=e[d];if(h.include)throw new Error("Inheritance is not allowed in stateless lexers");if(h.error||h.fallback){if(r)throw!h.fallback==!r.fallback?new Error("Multiple "+(h.fallback?"fallback":"error")+" rules not allowed (for token '"+h.defaultType+"')"):new Error("fallback and error are mutually exclusive (for token '"+h.defaultType+"')");r=h}var y=h.match.slice();if(l)for(;y.length&&"string"==typeof y[0]&&1===y[0].length;)c[y.shift().charCodeAt(0)]=h;if(h.pop||h.push||h.next){if(!t)throw new Error("State-switching options are not allowed in stateless lexers (for token '"+h.defaultType+"')");if(h.fallback)throw new Error("State-switching options are not allowed on fallback tokens (for token '"+h.defaultType+"')")}if(0!==y.length){l=!1,u.push(h);for(var v=0;v<y.length;v++){var g=y[v];if(a(g))if(null===p)p=g.unicode;else if(p!==g.unicode&&!1===h.fallback)throw new Error("If one rule is /u then all must be")}var $=s(y.map(o)),b=new RegExp($);if(b.test(""))throw new Error("RegExp matches empty string: "+b);if(new RegExp("|"+$).exec("").length-1>0)throw new Error("RegExp has capture groups: "+b+"\nUse (?: … ) instead");if(!h.lineBreaks&&b.test("\n"))throw new Error("Rule should declare lineBreaks: "+b);f.push(i($))}}var S=r&&r.fallback,w=n&&!S?"ym":"gm",O=n||S?"":"|";return!0===p&&(w+="u"),{regexp:new RegExp(s(f)+O,w),groups:u,fast:c,error:r||m}}function u(e,t,n){var a=e&&(e.push||e.next);if(a&&!n[a])throw new Error("Missing state '"+a+"' (in token '"+e.defaultType+"' of state '"+t+"')");if(e&&e.pop&&1!=+e.pop)throw new Error("pop must be 1 (in token '"+e.defaultType+"' of state '"+t+"')")}var f=function(e,t){this.startState=t,this.states=e,this.buffer="",this.stack=[],this.reset()};f.prototype.reset=function(e,t){return this.buffer=e||"",this.index=0,this.line=t?t.line:1,this.col=t?t.col:1,this.queuedToken=t?t.queuedToken:null,this.queuedThrow=t?t.queuedThrow:null,this.setState(t?t.state:this.startState),this.stack=t&&t.stack?t.stack.slice():[],this},f.prototype.save=function(){return{line:this.line,col:this.col,state:this.state,stack:this.stack.slice(),queuedToken:this.queuedToken,queuedThrow:this.queuedThrow}},f.prototype.setState=function(e){if(e&&this.state!==e){this.state=e;var t=this.states[e];this.groups=t.groups,this.error=t.error,this.re=t.regexp,this.fast=t.fast}},f.prototype.popState=function(){this.setState(this.stack.pop())},f.prototype.pushState=function(e){this.stack.push(this.state),this.setState(e)};var d=n?function(e,t){return e.exec(t)}:function(e,t){var n=e.exec(t);return 0===n[0].length?null:n};function h(){return this.value}if(f.prototype._getGroup=function(e){for(var t=this.groups.length,n=0;n<t;n++)if(void 0!==e[n+1])return this.groups[n];throw new Error("Cannot find token type for matched text")},f.prototype.next=function(){var e=this.index;if(this.queuedGroup){var t=this._token(this.queuedGroup,this.queuedText,e);return this.queuedGroup=null,this.queuedText="",t}var n=this.buffer;if(e!==n.length){if(s=this.fast[n.charCodeAt(e)])return this._token(s,n.charAt(e),e);var a=this.re;a.lastIndex=e;var r=d(a,n),i=this.error;if(null==r)return this._token(i,n.slice(e,n.length),e);var s=this._getGroup(r),o=r[0];return i.fallback&&r.index!==e?(this.queuedGroup=s,this.queuedText=o,this._token(i,n.slice(e,r.index),e)):this._token(s,o,e)}},f.prototype._token=function(e,t,n){var a=0;if(e.lineBreaks){var r=/\n/g,i=1;if("\n"===t)a=1;else for(;r.exec(t);)a++,i=r.lastIndex}var s={type:"function"==typeof e.type&&e.type(t)||e.defaultType,value:"function"==typeof e.value?e.value(t):t,text:t,toString:h,offset:n,lineBreaks:a,line:this.line,col:this.col},o=t.length;if(this.index+=o,this.line+=a,0!==a?this.col=o-i+1:this.col+=o,e.shouldThrow)throw new Error(this.formatError(s,"invalid syntax"));return e.pop?this.popState():e.push?this.pushState(e.push):e.next&&this.setState(e.next),s},"undefined"!=typeof Symbol&&Symbol.iterator){var y=function(e){this.lexer=e};y.prototype.next=function(){var e=this.lexer.next();return{value:e,done:!e}},y.prototype[Symbol.iterator]=function(){return this},f.prototype[Symbol.iterator]=function(){return new y(this)}}return f.prototype.formatError=function(e,t){if(null==e){var n=this.buffer.slice(this.index);e={text:n,offset:this.index,lineBreaks:-1===n.indexOf("\n")?0:1,line:this.line,col:this.col}}var a=Math.max(0,e.offset-e.col+1),r=e.lineBreaks?e.text.indexOf("\n"):e.text.length,i=this.buffer.substring(a,e.offset+r);return t+=" at line "+e.line+" col "+e.col+":\n\n",t+="  "+i+"\n",t+="  "+Array(e.col).join(" ")+"^"},f.prototype.clone=function(){return new f(this.states,this.state)},f.prototype.has=function(e){return!0},{compile:function(e){var t=p(l(e));return new f({start:t},"start")},states:function(e,t){var n=e.$all?l(e.$all):[];delete e.$all;var a=Object.getOwnPropertyNames(e);t||(t=a[0]);for(var r=Object.create(null),i=0;i<a.length;i++)r[$=a[i]]=l(e[$]).concat(n);for(i=0;i<a.length;i++)for(var s=r[$=a[i]],o=Object.create(null),c=0;c<s.length;c++){var m=s[c];if(m.include){var d=[c,1];if(m.include!==$&&!o[m.include]){o[m.include]=!0;var h=r[m.include];if(!h)throw new Error("Cannot include nonexistent state '"+m.include+"' (in state '"+$+"')");for(var y=0;y<h.length;y++){var v=h[y];-1===s.indexOf(v)&&d.push(v)}}s.splice.apply(s,d),c--}}var g=Object.create(null);for(i=0;i<a.length;i++){var $;g[$=a[i]]=p(r[$],!0)}for(i=0;i<a.length;i++){var b=a[i],S=g[b],w=S.groups;for(c=0;c<w.length;c++)u(w[c],b,g);var O=Object.getOwnPropertyNames(S.fast);for(c=0;c<O.length;c++)u(S.fast[O[c]],b,g)}return new f(g,t)},error:Object.freeze({error:!0}),fallback:Object.freeze({fallback:!0}),keywords:function(e){for(var t=Object.create(null),n=Object.create(null),a=Object.getOwnPropertyNames(e),r=0;r<a.length;r++){var i=a[r],s=e[i];(Array.isArray(s)?s:[s]).forEach((function(e){if((n[e.length]=n[e.length]||[]).push(e),"string"!=typeof e)throw new Error("keyword must be string (in keyword '"+i+"')");t[e]=i}))}function o(e){return JSON.stringify(e)}var c="";for(var l in c+="switch (value.length) {\n",n){var m=n[l];c+="case "+l+":\n",c+="switch (value) {\n",m.forEach((function(e){var n=t[e];c+="case "+o(e)+": return "+o(n)+"\n"})),c+="}\n"}return c+="}\n",Function("value",c)}}},e.exports?e.exports=n():t.moo=n()}));const wi='(?:\\\\["\\/\\\\brfnt]|\\\\u[0-9a-fA-F]{4}|[^"\\\\])';var Oi=Si.states({main:{WS:{match:new RegExp("(?:(?:\r?\n)|[ \t])+"),lineBreaks:!0},accent7:new RegExp("true|false|-?(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][-+]?[0-9]+)?"),accent3:["{","}","[","]"],accent6:"null",stringProperty:{match:new RegExp('"(?=[^"]*"\\s*:)'),push:"property"},stringStart:{match:'"',push:"string"},other:/./},string:{accent7:{match:new RegExp(`${wi}+`),lineBreaks:!0},stringEnd:{match:'"',pop:!0},other:/./},property:{accent1:{match:new RegExp(`${wi}+`),lineBreaks:!0},propertyEnd:{match:'"',pop:!0},other:/./}});const xi="(?:\"(?:\\\\[\"\\/\\\\brfnt]|\\\\u[0-9a-fA-F]{4}|[^\"\\\\])*\"|'(?:\\\\['\\/\\\\brfnt]|\\\\u[0-9a-fA-F]{4}|[^'\\\\])*')",ji="-?(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][-+]?[0-9]+)?";var Ii=Si.states({main:{WS:{match:new RegExp("(?:\r?\n)+"),lineBreaks:!0},indent:new RegExp("^[ \\t]+"),comment:new RegExp("#[^\n]*"),inlineArray:{match:"[",type:Si.keywords({accent3:"["}),push:"inlineArray"},inlineObject:{match:["{"],type:Si.keywords({accent3:"{"}),push:"inlineObject"},accent1:new RegExp("-[ \\t]+"),accent7:["true","false","null",new RegExp(xi),new RegExp(ji)],accent6:new RegExp("[^\\s]+(?=[ \\t]*:(?:[ \\t]+|$))"),accent3:{match:new RegExp("[ \\t]*:(?:[ \\t]+|$)"),lineBreaks:!0,push:"property"},other:/[^#\n]+/},property:{WS:{match:new RegExp("(?:\r?\n)+"),lineBreaks:!0,pop:1},comment:new RegExp("#[^\n]*"),accent7:{match:["true","false","null",new RegExp(xi),new RegExp(ji)],pop:1},other:/[^#\n]+/},inlineArray:{WS:new RegExp("[ \\t]+"),comment:new RegExp("#[^\n]*"),inlineArray:{match:"[",type:Si.keywords({accent3:"["}),push:"inlineArray"},inlineObject:{match:["{"],type:Si.keywords({accent3:"{"}),push:"inlineObject"},close:{match:"]",type:Si.keywords({accent3:"]"}),pop:1},comma:",",accent7:["true","false","null",new RegExp(xi),new RegExp(ji)],accent6:new RegExp("[^\\s]+(?=[ \\t]*:)"),accent3:{match:new RegExp("[ \\t]*:"),lineBreaks:!0},other:/[^\]\n,#]+/},inlineObject:{WS:new RegExp("[ \\t]+"),comment:new RegExp("#[^\n]*"),inlineArray:{match:"[",type:Si.keywords({accent3:"["}),push:"inlineArray"},inlineObject:{match:["{"],type:Si.keywords({accent3:"{"}),push:"inlineObject"},close:{match:"}",type:Si.keywords({accent3:"}"}),pop:1},comma:",",accent7:["true","false","null",new RegExp(xi),new RegExp(ji)],accent6:new RegExp("[^\\s]+(?=[ \\t]*:)"),accent3:{match:new RegExp("[ \\t]*:"),lineBreaks:!0},other:/[^}\n,#]+/}});function Ei(e,t,n){const a=e.slice();return a[10]=t[n],a}function Pi(e,t,n){const a=e.slice();return a[13]=t[n],a[15]=n,a}function Ai(e){let t,n,f=e[15]+1+"";return{c(){t=a("div"),n=r(f),this.h()},l(e){t=i(e,"DIV",{class:!0});var a=s(t);n=o(a,f),a.forEach(c),this.h()},h(){l(t,"class","svelte-564293")},m(e,a){m(e,t,a),p(t,n)},p:u,d(e){e&&c(t)}}}function ki(e){let t,n=e[10].value+"";return{c(){t=r(n)},l(e){t=o(e,n)},m(e,n){m(e,t,n)},p(e,a){16&a&&n!==(n=e[10].value+"")&&w(t,n)},d(e){e&&c(t)}}}function Ri(e){let t,n,u=e[10].value+"";return{c(){t=a("span"),n=r(u),this.h()},l(e){t=i(e,"SPAN",{class:!0});var a=s(t);n=o(a,u),a.forEach(c),this.h()},h(){l(t,"class","accent8 svelte-564293")},m(e,a){m(e,t,a),p(t,n)},p(e,t){16&t&&u!==(u=e[10].value+"")&&w(n,u)},d(e){e&&c(t)}}}function Ci(e){let t,n,u=e[10].value+"";return{c(){t=a("span"),n=r(u),this.h()},l(e){t=i(e,"SPAN",{class:!0});var a=s(t);n=o(a,u),a.forEach(c),this.h()},h(){l(t,"class","accent7 svelte-564293")},m(e,a){m(e,t,a),p(t,n)},p(e,t){16&t&&u!==(u=e[10].value+"")&&w(n,u)},d(e){e&&c(t)}}}function Ni(e){let t,n,u=e[10].value+"";return{c(){t=a("span"),n=r(u),this.h()},l(e){t=i(e,"SPAN",{class:!0});var a=s(t);n=o(a,u),a.forEach(c),this.h()},h(){l(t,"class","accent6 svelte-564293")},m(e,a){m(e,t,a),p(t,n)},p(e,t){16&t&&u!==(u=e[10].value+"")&&w(n,u)},d(e){e&&c(t)}}}function Ti(e){let t,n,u=e[10].value+"";return{c(){t=a("span"),n=r(u),this.h()},l(e){t=i(e,"SPAN",{class:!0});var a=s(t);n=o(a,u),a.forEach(c),this.h()},h(){l(t,"class","accent5 svelte-564293")},m(e,a){m(e,t,a),p(t,n)},p(e,t){16&t&&u!==(u=e[10].value+"")&&w(n,u)},d(e){e&&c(t)}}}function Di(e){let t,n,u=e[10].value+"";return{c(){t=a("span"),n=r(u),this.h()},l(e){t=i(e,"SPAN",{class:!0});var a=s(t);n=o(a,u),a.forEach(c),this.h()},h(){l(t,"class","accent4 svelte-564293")},m(e,a){m(e,t,a),p(t,n)},p(e,t){16&t&&u!==(u=e[10].value+"")&&w(n,u)},d(e){e&&c(t)}}}function qi(e){let t,n,u=e[10].value+"";return{c(){t=a("span"),n=r(u),this.h()},l(e){t=i(e,"SPAN",{class:!0});var a=s(t);n=o(a,u),a.forEach(c),this.h()},h(){l(t,"class","accent3 svelte-564293")},m(e,a){m(e,t,a),p(t,n)},p(e,t){16&t&&u!==(u=e[10].value+"")&&w(n,u)},d(e){e&&c(t)}}}function Mi(e){let t,n,u=e[10].value+"";return{c(){t=a("span"),n=r(u),this.h()},l(e){t=i(e,"SPAN",{class:!0});var a=s(t);n=o(a,u),a.forEach(c),this.h()},h(){l(t,"class","accent2 svelte-564293")},m(e,a){m(e,t,a),p(t,n)},p(e,t){16&t&&u!==(u=e[10].value+"")&&w(n,u)},d(e){e&&c(t)}}}function Vi(e){let t,n,u=e[10].value+"";return{c(){t=a("span"),n=r(u),this.h()},l(e){t=i(e,"SPAN",{class:!0});var a=s(t);n=o(a,u),a.forEach(c),this.h()},h(){l(t,"class","accent1 svelte-564293")},m(e,a){m(e,t,a),p(t,n)},p(e,t){16&t&&u!==(u=e[10].value+"")&&w(n,u)},d(e){e&&c(t)}}}function Li(e){let t,n,u=e[10].value+"";return{c(){t=a("span"),n=r(u),this.h()},l(e){t=i(e,"SPAN",{class:!0});var a=s(t);n=o(a,u),a.forEach(c),this.h()},h(){l(t,"class","comment svelte-564293")},m(e,a){m(e,t,a),p(t,n)},p(e,t){16&t&&u!==(u=e[10].value+"")&&w(n,u)},d(e){e&&c(t)}}}function Ji(e){let t;function n(e,t){return"comment"===e[10].type?Li:"accent1"===e[10].type?Vi:"accent2"===e[10].type?Mi:"accent3"===e[10].type?qi:"accent4"===e[10].type?Di:"accent5"===e[10].type?Ti:"accent6"===e[10].type?Ni:"accent7"===e[10].type?Ci:"accent8"===e[10].type?Ri:ki}let a=n(e),r=a(e);return{c(){r.c(),t=f()},l(e){r.l(e),t=f()},m(e,n){r.m(e,n),m(e,t,n)},p(e,i){a===(a=n(e))&&r?r.p(e,i):(r.d(1),r=a(e),r&&(r.c(),r.m(t.parentNode,t)))},d(e){r.d(e),e&&c(t)}}}function Ui(e){let t,n,r,o,f,b,S,w,O,x,j=[...Array(e[3])],I=[];for(let t=0;t<j.length;t+=1)I[t]=Ai(Pi(e,j,t));let E=e[4],P=[];for(let t=0;t<E.length;t+=1)P[t]=Ji(Ei(e,E,t));return{c(){t=a("div"),n=a("div");for(let e=0;e<I.length;e+=1)I[e].c();r=d(),o=a("div"),f=a("pre");for(let e=0;e<P.length;e+=1)P[e].c();b=d(),S=a("textarea"),this.h()},l(e){t=i(e,"DIV",{class:!0});var a=s(t);n=i(a,"DIV",{class:!0});var l=s(n);for(let e=0;e<I.length;e+=1)I[e].l(l);l.forEach(c),r=h(a),o=i(a,"DIV",{class:!0});var m=s(o);f=i(m,"PRE",{class:!0});var p=s(f);for(let e=0;e<P.length;e+=1)P[e].l(p);p.forEach(c),b=h(m),S=i(m,"TEXTAREA",{class:!0,"aria-label":!0}),s(S).forEach(c),m.forEach(c),a.forEach(c),this.h()},h(){l(n,"class","line-numbers svelte-564293"),l(f,"class","highlighted svelte-564293"),l(S,"class","src svelte-564293"),l(S,"aria-label","Code Editor"),l(o,"class","editable svelte-564293"),l(t,"class",w="Editor "+e[1]+" svelte-564293")},m(a,i){m(a,t,i),p(t,n);for(let e=0;e<I.length;e+=1)I[e].m(n,null);p(t,r),p(t,o),p(o,f);for(let e=0;e<P.length;e+=1)P[e].m(f,null);p(o,b),p(o,S),e[8](S),y(S,e[0]),O||(x=[v(S,"input",e[9]),v(S,"input",e[7])],O=!0)},p(e,[a]){if(8&a){let t;for(j=[...Array(e[3])],t=0;t<j.length;t+=1){const r=Pi(e,j,t);I[t]?I[t].p(r,a):(I[t]=Ai(r),I[t].c(),I[t].m(n,null))}for(;t<I.length;t+=1)I[t].d(1);I.length=j.length}if(16&a){let t;for(E=e[4],t=0;t<E.length;t+=1){const n=Ei(e,E,t);P[t]?P[t].p(n,a):(P[t]=Ji(n),P[t].c(),P[t].m(f,null))}for(;t<P.length;t+=1)P[t].d(1);P.length=E.length}1&a&&y(S,e[0]),2&a&&w!==(w="Editor "+e[1]+" svelte-564293")&&l(t,"class",w)},i:u,o:u,d(n){n&&c(t),g(I,n),g(P,n),e[8](null),O=!1,$(x)}}}function _i(e,t,n){let a,r,i,{theme:s="solarized-dark"}=t,{value:o=""}=t,{format:c="json"}=t;return e.$$set=e=>{"theme"in e&&n(1,s=e.theme),"value"in e&&n(0,o=e.value),"format"in e&&n(5,c=e.format)},e.$$.update=()=>{1&e.$$.dirty&&n(3,a=(o.match(/\n/g)||[]).length+1),33&e.$$.dirty&&n(4,r="json"===c?(Oi.reset(o),Array.from(Oi)):(Ii.reset(o),Array.from(Ii)))},[o,s,i,a,r,c,()=>{i.focus()},function(t){b(e,t)},function(e){S[e?"unshift":"push"]((()=>{i=e,n(2,i)}))},function(){o=this.value,n(0,o)}]}class Bi extends e{constructor(e){super(),t(this,e,_i,Ui,n,{theme:1,value:0,format:5,focus:6})}get focus(){return this.$$.ctx[6]}}function Fi(e,t,n){const a=e.slice();return a[18]=t[n],a[20]=n,a}function zi(e){let t,n,u,f;function d(){return e[12](e[20])}return{c(){t=a("button"),n=r("×"),this.h()},l(e){t=i(e,"BUTTON",{class:!0});var a=s(t);n=o(a,"×"),a.forEach(c),this.h()},h(){l(t,"class","tab-close svelte-1ylgy73")},m(e,a){m(e,t,a),p(t,n),u||(f=v(t,"click",d),u=!0)},p(t,n){e=t},d(e){e&&c(t),u=!1,f()}}}function Ki(e){let t,n,u,f,y,g,$,b,S=e[18].label+"",x=!e[18].persistent&&e[0].length>e[6]&&zi(e);function j(){return e[13](e[20])}return{c(){t=a("button"),n=a("span"),u=r(S),f=d(),x&&x.c(),this.h()},l(e){t=i(e,"BUTTON",{role:!0,id:!0,"aria-selected":!0,"aria-controls":!0,class:!0});var a=s(t);n=i(a,"SPAN",{class:!0});var r=s(n);u=o(r,S),r.forEach(c),f=h(a),x&&x.l(a),a.forEach(c),this.h()},h(){l(n,"class","tab-label svelte-1ylgy73"),l(t,"role","tab"),l(t,"id",y=`${e[3]}-tab-${e[20]}`),l(t,"aria-selected",g=e[20]===e[1]),l(t,"aria-controls","tabpanel"),l(t,"class","svelte-1ylgy73"),O(t,"active",e[20]===e[5])},m(e,a){m(e,t,a),p(t,n),p(n,u),p(t,f),x&&x.m(t,null),$||(b=v(t,"click",j),$=!0)},p(n,a){e=n,1&a&&S!==(S=e[18].label+"")&&w(u,S),!e[18].persistent&&e[0].length>e[6]?x?x.p(e,a):(x=zi(e),x.c(),x.m(t,null)):x&&(x.d(1),x=null),8&a&&y!==(y=`${e[3]}-tab-${e[20]}`)&&l(t,"id",y),2&a&&g!==(g=e[20]===e[1])&&l(t,"aria-selected",g),32&a&&O(t,"active",e[20]===e[5])},d(e){e&&c(t),x&&x.d(),$=!1,b()}}}function Gi(e){let t,n,u,f,d,h;return{c(){t=a("button"),n=a("span"),u=r("+"),this.h()},l(e){t=i(e,"BUTTON",{role:!0,id:!0,class:!0});var a=s(t);n=i(a,"SPAN",{class:!0});var r=s(n);u=o(r,"+"),r.forEach(c),a.forEach(c),this.h()},h(){l(n,"class","tab-label svelte-1ylgy73"),l(t,"role","tab"),l(t,"id",f=`${e[3]}-tab-${e[0].length}`),l(t,"class","svelte-1ylgy73")},m(a,r){m(a,t,r),p(t,n),p(n,u),d||(h=v(t,"click",e[10]),d=!0)},p(e,n){9&n&&f!==(f=`${e[3]}-tab-${e[0].length}`)&&l(t,"id",f)},d(e){e&&c(t),d=!1,h()}}}function Zi(e){let t,n,r,o,u,f,y,v,$,b=e[0],w=[];for(let t=0;t<b.length;t+=1)w[t]=Ki(Fi(e,b,t));let O=e[4]&&Gi(e);function C(t){e[15](t)}function N(t){e[16](t)}let T={};return void 0!==e[0][e[1]].text&&(T.value=e[0][e[1]].text),void 0!==e[2]&&(T.format=e[2]),u=new Bi({props:T}),e[14](u),S.push((()=>x(u,"value",C))),S.push((()=>x(u,"format",N))),u.$on("input",e[17]),{c(){t=a("div");for(let e=0;e<w.length;e+=1)w[e].c();n=d(),O&&O.c(),r=d(),o=a("div"),j(u.$$.fragment),this.h()},l(e){t=i(e,"DIV",{role:!0,class:!0});var a=s(t);for(let e=0;e<w.length;e+=1)w[e].l(a);n=h(a),O&&O.l(a),a.forEach(c),r=h(e),o=i(e,"DIV",{role:!0,id:!0,"aria-labelledby":!0,class:!0});var l=s(o);I(u.$$.fragment,l),l.forEach(c),this.h()},h(){l(t,"role","tablist"),l(t,"class","svelte-1ylgy73"),l(o,"role","tabpanel"),l(o,"id","tabpanel"),l(o,"aria-labelledby",v=`${e[3]}-tab-${e[1]}`),l(o,"class","svelte-1ylgy73")},m(e,a){m(e,t,a);for(let e=0;e<w.length;e+=1)w[e].m(t,null);p(t,n),O&&O.m(t,null),m(e,r,a),m(e,o,a),E(u,o,null),$=!0},p(e,[a]){if(2667&a){let r;for(b=e[0],r=0;r<b.length;r+=1){const i=Fi(e,b,r);w[r]?w[r].p(i,a):(w[r]=Ki(i),w[r].c(),w[r].m(t,n))}for(;r<w.length;r+=1)w[r].d(1);w.length=b.length}e[4]?O?O.p(e,a):(O=Gi(e),O.c(),O.m(t,null)):O&&(O.d(1),O=null);const r={};!f&&3&a&&(f=!0,r.value=e[0][e[1]].text,P((()=>f=!1))),!y&&4&a&&(y=!0,r.format=e[2],P((()=>y=!1))),u.$set(r),(!$||10&a&&v!==(v=`${e[3]}-tab-${e[1]}`))&&l(o,"aria-labelledby",v)},i(e){$||(A(u.$$.fragment,e),$=!0)},o(e){k(u.$$.fragment,e),$=!1},d(n){n&&c(t),g(w,n),O&&O.d(),n&&c(r),n&&c(o),e[14](null),R(u)}}}function Wi(e,t,n){let a,{ns:r=""}=t,{tabs:i=[]}=t,{newTab:s}=t,{active:o=0}=t,{selected:c=0}=t,{minTabs:l=1}=t,{format:m="json"}=t;const p=C();function u(e){n(1,c=e),a.focus()}function f(e){c>=e&&c>0&&n(1,c-=1),i.splice(e,1),n(0,i),a.focus()}return e.$$set=e=>{"ns"in e&&n(3,r=e.ns),"tabs"in e&&n(0,i=e.tabs),"newTab"in e&&n(4,s=e.newTab),"active"in e&&n(5,o=e.active),"selected"in e&&n(1,c=e.selected),"minTabs"in e&&n(6,l=e.minTabs),"format"in e&&n(2,m=e.format)},[i,c,m,r,s,o,l,a,p,u,function(){n(0,i[i.length]=s(),i),n(1,c=i.length-1),a.focus()},f,e=>f(e),e=>u(e),function(e){S[e?"unshift":"push"]((()=>{a=e,n(7,a)}))},function(t){e.$$.not_equal(i[c].text,t)&&(i[c].text=t,n(0,i))},function(e){m=e,n(2,m)},e=>p("input",i)]}class Hi extends e{constructor(e){super(),t(this,e,Wi,Zi,n,{ns:3,tabs:0,newTab:4,active:5,selected:1,minTabs:6,format:2})}}function Xi(e,t,n){const a=e.slice();return a[2]=t[n],a}function Yi(e){let t;function n(e,t){return e[1].output?es:Qi}let a=n(e),r=a(e);return{c(){r.c(),t=f()},l(e){r.l(e),t=f()},m(e,n){r.m(e,n),m(e,t,n)},p(e,i){a===(a=n(e))&&r?r.p(e,i):(r.d(1),r=a(e),r&&(r.c(),r.m(t.parentNode,t)))},d(e){r.d(e),e&&c(t)}}}function Qi(e){let t,n=e[1]+"";return{c(){t=r(n)},l(e){t=o(e,n)},m(e,n){m(e,t,n)},p(e,a){1&a&&n!==(n=e[1]+"")&&w(t,n)},d(e){e&&c(t)}}}function es(e){let t,n,l=e[1].output.errors,p=[];for(let t=0;t<l.length;t+=1)p[t]=ns(Xi(e,l,t));return{c(){t=r("Invalid\n    "),n=a("ul");for(let e=0;e<p.length;e+=1)p[e].c()},l(e){t=o(e,"Invalid\n    "),n=i(e,"UL",{});var a=s(n);for(let e=0;e<p.length;e+=1)p[e].l(a);a.forEach(c)},m(e,a){m(e,t,a),m(e,n,a);for(let e=0;e<p.length;e+=1)p[e].m(n,null)},p(e,t){if(1&t){let a;for(l=e[1].output.errors,a=0;a<l.length;a+=1){const r=Xi(e,l,a);p[a]?p[a].p(r,t):(p[a]=ns(r),p[a].c(),p[a].m(n,null))}for(;a<p.length;a+=1)p[a].d(1);p.length=l.length}},d(e){e&&c(t),e&&c(n),g(p,e)}}}function ts(e){let t,n,u,f,d,h,y=e[2].instanceLocation+"",v=e[2].absoluteKeywordLocation+"";return{c(){t=a("li"),n=a("code"),u=r(y),f=r(" fails schema constraint "),d=a("code"),h=r(v),this.h()},l(e){t=i(e,"LI",{class:!0});var a=s(t);n=i(a,"CODE",{class:!0});var r=s(n);u=o(r,y),r.forEach(c),f=o(a," fails schema constraint "),d=i(a,"CODE",{class:!0});var l=s(d);h=o(l,v),l.forEach(c),a.forEach(c),this.h()},h(){l(n,"class","svelte-1sdf2dp"),l(d,"class","svelte-1sdf2dp"),l(t,"class","svelte-1sdf2dp")},m(e,a){m(e,t,a),p(t,n),p(n,u),p(t,f),p(t,d),p(d,h)},p(e,t){1&t&&y!==(y=e[2].instanceLocation+"")&&w(u,y),1&t&&v!==(v=e[2].absoluteKeywordLocation+"")&&w(h,v)},d(e){e&&c(t)}}}function ns(e){let t,n=!e[2].valid&&!e[2].keyword.endsWith("#validate"),a=n&&ts(e);return{c(){a&&a.c(),t=f()},l(e){a&&a.l(e),t=f()},m(e,n){a&&a.m(e,n),m(e,t,n)},p(e,r){1&r&&(n=!e[2].valid&&!e[2].keyword.endsWith("#validate")),n?a?a.p(e,r):(a=ts(e),a.c(),a.m(t.parentNode,t)):a&&(a.d(1),a=null)},d(e){a&&a.d(e),e&&c(t)}}}function as(e){let t,n=e[0]?"Valid":"";return{c(){t=r(n)},l(e){t=o(e,n)},m(e,n){m(e,t,n)},p(e,a){1&a&&n!==(n=e[0]?"Valid":"")&&w(t,n)},d(e){e&&c(t)}}}function rs(e){let t;return{c(){t=r("Validating ...")},l(e){t=o(e,"Validating ...")},m(e,n){m(e,t,n)},p:u,d(e){e&&c(t)}}}function is(e){let t,n,a={ctx:e,current:null,token:null,hasCatch:!0,pending:rs,then:as,catch:Yi,value:0,error:1};return N(n=e[0],a),{c(){t=f(),a.block.c()},l(e){t=f(),a.block.l(e)},m(e,n){m(e,t,n),a.block.m(e,a.anchor=n),a.mount=()=>t.parentNode,a.anchor=t},p(t,[r]){e=t,a.ctx=e,1&r&&n!==(n=e[0])&&N(n,a)||T(a,e,r)},i:u,o:u,d(e){e&&c(t),a.block.d(e),a.token=null,a=null}}}function ss(e,t,n){let{results:a}=t;return e.$$set=e=>{"results"in e&&n(0,a=e.results)},[a]}class os extends e{constructor(e){super(),t(this,e,ss,is,n,{results:0})}}function cs(e){let t,n,r,o,u;const f=e[2].default,y=D(f,e,e[1],null);return{c(){t=a("a"),n=q("svg"),r=q("path"),o=d(),y&&y.c(),this.h()},l(e){t=i(e,"A",{href:!0,class:!0});var a=s(t);n=i(a,"svg",{height:!0,viewBox:!0,version:!0,"aria-hidden":!0,class:!0},1);var l=s(n);r=i(l,"path",{"fill-rule":!0,d:!0},1),s(r).forEach(c),l.forEach(c),o=h(a),y&&y.l(a),a.forEach(c),this.h()},h(){l(r,"fill-rule","evenodd"),l(r,"d","M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"),l(n,"height","1.5em"),l(n,"viewBox","0 0 16 16"),l(n,"version","1.1"),l(n,"aria-hidden","true"),l(n,"class","svelte-i8toq"),l(t,"href",e[0]),l(t,"class","svelte-i8toq")},m(e,a){m(e,t,a),p(t,n),p(n,r),p(t,o),y&&y.m(t,null),u=!0},p(e,[n]){y&&y.p&&(!u||2&n)&&M(y,f,e,e[1],n,null,null),(!u||1&n)&&l(t,"href",e[0])},i(e){u||(A(y,e),u=!0)},o(e){k(y,e),u=!1},d(e){e&&c(t),y&&y.d(e)}}}function ls(e,t,n){let{$$slots:a={},$$scope:r}=t,{href:i=""}=t;return e.$$set=e=>{"href"in e&&n(0,i=e.href),"$$scope"in e&&n(1,r=e.$$scope)},[i,r,a]}class ms extends e{constructor(e){super(),t(this,e,ls,cs,n,{href:0})}}function ps(e){let t,n,r,o,u;const f=e[2].default,y=D(f,e,e[1],null);return{c(){t=a("a"),n=q("svg"),r=q("path"),o=d(),y&&y.c(),this.h()},l(e){t=i(e,"A",{href:!0,class:!0});var a=s(t);n=i(a,"svg",{height:!0,viewBox:!0,version:!0,"aria-hidden":!0,class:!0},1);var l=s(n);r=i(l,"path",{d:!0},1),s(r).forEach(c),l.forEach(c),o=h(a),y&&y.l(a),a.forEach(c),this.h()},h(){l(r,"d","M240,250h100v-50h100V0H240V250z M340,50h50v100h-50V50z M480,0v200h100V50h50v150h50V50h50v150h50V0H480z M0,200h100V50h50v150h50V0H0V200z"),l(n,"height","1em"),l(n,"viewBox","0 0 780 250"),l(n,"version","1.1"),l(n,"aria-hidden","true"),l(n,"class","svelte-wj8h0n"),l(t,"href",e[0]),l(t,"class","svelte-wj8h0n")},m(e,a){m(e,t,a),p(t,n),p(n,r),p(t,o),y&&y.m(t,null),u=!0},p(e,[n]){y&&y.p&&(!u||2&n)&&M(y,f,e,e[1],n,null,null),(!u||1&n)&&l(t,"href",e[0])},i(e){u||(A(y,e),u=!0)},o(e){k(y,e),u=!1},d(e){e&&c(t),y&&y.d(e)}}}function us(e,t,n){let{$$slots:a={},$$scope:r}=t,{href:i=""}=t;return e.$$set=e=>{"href"in e&&n(0,i=e.href),"$$scope"in e&&n(1,r=e.$$scope)},[i,r,a]}class fs extends e{constructor(e){super(),t(this,e,us,ps,n,{href:0})}}function ds(e){let t,n,r,o,u,f,y,v,g;const $=e[2].default,b=D($,e,e[1],null);return{c(){t=a("a"),n=q("svg"),r=q("g"),o=q("path"),u=q("path"),f=q("path"),y=q("path"),v=d(),b&&b.c(),this.h()},l(e){t=i(e,"A",{href:!0,class:!0});var a=s(t);n=i(a,"svg",{version:!0,viewBox:!0,height:!0,class:!0},1);var l=s(n);r=i(l,"g",{transform:!0,id:!0},1);var m=s(r);o=i(m,"path",{id:!0,d:!0,style:!0},1),s(o).forEach(c),u=i(m,"path",{id:!0,d:!0,style:!0},1),s(u).forEach(c),f=i(m,"path",{id:!0,d:!0,style:!0},1),s(f).forEach(c),y=i(m,"path",{id:!0,d:!0,style:!0},1),s(y).forEach(c),m.forEach(c),l.forEach(c),v=h(a),b&&b.l(a),a.forEach(c),this.h()},h(){l(o,"id","path4544"),l(o,"d","m 122.99401,114.18985 c -4.32897,-0.9404 -7.58044,-3.47848 -8.71251,-6.80095 -0.78921,-2.31618 -0.67682,-6.07238 0.33363,-11.150598 0.48507,-2.437836 0.88169,-5.347843 0.88139,-6.466688 -9.8e-4,-3.718098 -1.71106,-5.735418 -5.1001,-6.016462 l -1.9549,-0.162116 v -2.392655 -2.392657 l 1.85208,-0.250855 c 2.70243,-0.366031 3.74441,-1.02838 4.57629,-2.908984 0.61121,-1.381726 0.68884,-2.068648 0.50552,-4.472869 -0.11913,-1.562244 -0.53527,-4.348568 -0.92477,-6.191832 -0.98954,-4.682868 -0.94822,-8.485471 0.11707,-10.773163 1.56862,-3.368589 5.43705,-5.854553 9.93248,-6.382903 l 1.93299,-0.227185 v 2.518015 2.518015 h -1.29973 c -1.77186,0 -4.2497,1.262413 -4.8835,2.488054 -0.60797,1.175674 -0.65405,2.864146 -0.15834,5.802223 0.78343,4.643508 1.04707,9.098344 0.67592,11.421636 -0.42464,2.658142 -1.97477,5.796328 -3.6791,7.448236 l -1.18012,1.143813 1.61497,1.982752 c 1.99051,2.443801 2.76458,4.148744 3.24284,7.142561 0.37835,2.368341 0.0844,7.282673 -0.67072,11.213982 -1.05359,5.48514 0.1623,7.65141 4.66209,8.30613 l 1.67569,0.24382 v 2.44782 c 0,2.79211 0.17086,2.69708 -3.43917,1.91286 z"),V(o,"fill","stroke-width:0.35277775"),l(u,"id","path4546"),l(u,"d","m 152.2304,112.24932 v -2.42987 l 2.04969,-0.42336 c 2.26276,-0.46736 4.054,-1.8634 4.45842,-3.47475 0.1274,-0.50758 -0.11267,-3.16398 -0.53347,-5.90311 -1.37183,-8.929552 -0.6114,-13.537042 2.85482,-17.297452 l 1.48237,-1.60818 -1.1108,-1.26512 c -3.97855,-4.53132 -4.66885,-8.552208 -3.15364,-18.369547 0.76342,-4.946305 0.76409,-4.994322 0.087,-6.173611 -0.79713,-1.388278 -3.28385,-2.776033 -4.97438,-2.776033 h -1.15997 v -2.469445 c 0,-2.811057 -0.0583,-2.773846 3.24583,-2.072788 3.9645,0.841179 6.80448,2.853272 8.27787,5.864775 0.84544,1.728026 0.97275,2.400136 0.94911,5.010889 -0.015,1.658349 -0.35758,4.682054 -0.76125,6.719346 -1.49867,7.563594 -1.3651,9.576204 0.7654,11.532814 0.98915,0.90842 1.64012,1.17274 3.37032,1.36849 l 2.14439,0.24261 v 2.42387 2.42388 l -1.6757,7.1e-4 c -2.1517,7e-4 -3.9323,0.90924 -4.83869,2.46889 -0.95194,1.63803 -0.89239,5.20675 0.17364,10.40695 0.90648,4.421902 1.05253,8.458452 0.3882,10.728752 -0.70059,2.39406 -3.81995,5.29609 -6.74745,6.27718 -1.26118,0.42266 -2.96775,0.87096 -3.79236,0.99623 l -1.49931,0.22775 z"),V(u,"stroke-width","0.35277778"),l(f,"id","path4548"),l(f,"d","m 131.74239,108.26592 c -1.02163,-1.2988 -0.87294,-3.53652 0.38087,-5.73185 0.92776,-1.62446 4.80862,-6.948549 7.61066,-10.440949 l 1.13094,-1.40958 -1.80213,-5.22523 c -2.02147,-5.86123 -2.0098,-5.97467 0.65581,-6.37225 l 1.46834,-0.219 1.64076,3.3506 c 0.90242,1.84283 1.76982,3.35061 1.92755,3.35061 0.15774,0 1.77489,-1.75542 3.59368,-3.90092 3.15918,-3.72667 3.35688,-3.89165 4.42591,-3.69334 0.64552,0.11974 1.21858,0.0465 1.35432,-0.17316 0.31818,-0.51481 1.23083,0.24704 1.23083,1.02746 0,0.32009 -0.45438,1.13409 -1.00972,1.80888 -2.26771,2.75549 -7.10417,9.27155 -7.10417,9.5713 0,0.17685 0.97502,2.45302 2.16671,5.05816 l 2.1667,4.736609 -0.65823,0.98459 c -0.36203,0.54152 -0.66236,1.12603 -0.6674,1.29891 -0.005,0.17288 -0.27769,0.48371 -0.60588,0.69073 -0.83174,0.52464 -1.44656,-0.11541 -3.9894,-4.153119 -1.16417,-1.84856 -2.23163,-3.36491 -2.37215,-3.36967 -0.31309,-0.0106 -3.7911,5.131969 -6.47955,9.580639 -2.37093,3.92324 -1.93885,3.4204 -3.26614,3.80106 -0.95533,0.27398 -1.19348,0.19843 -1.79831,-0.57048 z"),V(f,"stroke-width","0.35277775"),l(y,"id","path4550"),l(y,"d","m 131.98567,83.677091 c -2.15148,-3.8472 -6.0183,-9.42829 -7.57842,-10.93815 -0.79252,-0.76698 -1.44094,-1.57494 -1.44094,-1.79546 0,-0.6016 1.61695,-1.21975 3.19058,-1.21975 1.69822,0 3.49597,1.47777 5.0997,4.19203 0.58208,0.98515 1.15641,1.79434 1.27629,1.79819 0.11988,0.004 0.80873,-1.65116 1.53078,-3.67779 1.5464,-4.34039 5.62351,-12.777999 7.22453,-14.951229 1.3726,-1.86316 3.42936,-2.865165 5.90274,-2.875676 3.23375,-0.01374 3.24268,0.130067 0.20474,3.296663 -4.63599,4.832327 -6.76321,8.809632 -11.25155,21.037252 -1.24637,3.39549 -2.39032,6.47895 -2.54212,6.85214 -0.23022,0.56597 -0.49833,0.28096 -1.61633,-1.71822 z"),V(y,"stroke-width","0.35277775"),l(r,"transform","translate(-104.22785,-45.507923)"),l(r,"id","layer1"),l(n,"version","1.1"),l(n,"viewBox","0 0 70.423268 70.42326"),l(n,"height","1.25em"),l(n,"class","svelte-27u907"),l(t,"href",e[0]),l(t,"class","svelte-27u907")},m(e,a){m(e,t,a),p(t,n),p(n,r),p(r,o),p(r,u),p(r,f),p(r,y),p(t,v),b&&b.m(t,null),g=!0},p(e,[n]){b&&b.p&&(!g||2&n)&&M(b,$,e,e[1],n,null,null),(!g||1&n)&&l(t,"href",e[0])},i(e){g||(A(b,e),g=!0)},o(e){k(b,e),g=!1},d(e){e&&c(t),b&&b.d(e)}}}function hs(e,t,n){let{$$slots:a={},$$scope:r}=t,{href:i=""}=t;return e.$$set=e=>{"href"in e&&n(0,i=e.href),"$$scope"in e&&n(1,r=e.$$scope)},[i,r,a]}class ys extends e{constructor(e){super(),t(this,e,hs,ds,n,{href:0})}}function vs(e){let t;return{c(){t=r("hyperjump-io/json-schema.hyperjump.io")},l(e){t=o(e,"hyperjump-io/json-schema.hyperjump.io")},m(e,n){m(e,t,n)},d(e){e&&c(t)}}}function gs(e){let t;return{c(){t=r("hyperjump-io/json-schema-validator")},l(e){t=o(e,"hyperjump-io/json-schema-validator")},m(e,n){m(e,t,n)},d(e){e&&c(t)}}}function $s(e){let t;return{c(){t=r("@hyperjump/json-schema")},l(e){t=o(e,"@hyperjump/json-schema")},m(e,n){m(e,t,n)},d(e){e&&c(t)}}}function bs(e){let t;return{c(){t=r("@hyperjump/json-schema-core")},l(e){t=o(e,"@hyperjump/json-schema-core")},m(e,n){m(e,t,n)},d(e){e&&c(t)}}}function Ss(e){let t;return{c(){t=r("JSON Schema")},l(e){t=o(e,"JSON Schema")},m(e,n){m(e,t,n)},d(e){e&&c(t)}}}function ws(e){let t,n,r,o,u,f,y,v,g,$,b,S,w,O,x,P,C;return o=new ms({props:{href:"https://github.com/hyperjump-io/json-schema.hyperjump.io",$$slots:{default:[vs]},$$scope:{ctx:e}}}),y=new ms({props:{href:"https://github.com/hyperjump-io/json-schema-validator",$$slots:{default:[gs]},$$scope:{ctx:e}}}),$=new fs({props:{href:"https://www.npmjs.com/package/@hyperjump/json-schema",$$slots:{default:[$s]},$$scope:{ctx:e}}}),w=new fs({props:{href:"https://www.npmjs.com/package/@hyperjump/json-schema-core",$$slots:{default:[bs]},$$scope:{ctx:e}}}),P=new ys({props:{href:"https://json-schema.org",$$slots:{default:[Ss]},$$scope:{ctx:e}}}),{c(){t=a("footer"),n=a("ul"),r=a("li"),j(o.$$.fragment),u=d(),f=a("li"),j(y.$$.fragment),v=d(),g=a("li"),j($.$$.fragment),b=d(),S=a("li"),j(w.$$.fragment),O=d(),x=a("li"),j(P.$$.fragment),this.h()},l(e){t=i(e,"FOOTER",{class:!0});var a=s(t);n=i(a,"UL",{class:!0});var l=s(n);r=i(l,"LI",{class:!0});var m=s(r);I(o.$$.fragment,m),m.forEach(c),u=h(l),f=i(l,"LI",{class:!0});var p=s(f);I(y.$$.fragment,p),p.forEach(c),v=h(l),g=i(l,"LI",{class:!0});var d=s(g);I($.$$.fragment,d),d.forEach(c),b=h(l),S=i(l,"LI",{class:!0});var j=s(S);I(w.$$.fragment,j),j.forEach(c),O=h(l),x=i(l,"LI",{class:!0});var E=s(x);I(P.$$.fragment,E),E.forEach(c),l.forEach(c),a.forEach(c),this.h()},h(){l(r,"class","svelte-17tbtsq"),l(f,"class","svelte-17tbtsq"),l(g,"class","svelte-17tbtsq"),l(S,"class","svelte-17tbtsq"),l(x,"class","svelte-17tbtsq"),l(n,"class","links svelte-17tbtsq"),l(t,"class","svelte-17tbtsq")},m(e,a){m(e,t,a),p(t,n),p(n,r),E(o,r,null),p(n,u),p(n,f),E(y,f,null),p(n,v),p(n,g),E($,g,null),p(n,b),p(n,S),E(w,S,null),p(n,O),p(n,x),E(P,x,null),C=!0},p(e,[t]){const n={};1&t&&(n.$$scope={dirty:t,ctx:e}),o.$set(n);const a={};1&t&&(a.$$scope={dirty:t,ctx:e}),y.$set(a);const r={};1&t&&(r.$$scope={dirty:t,ctx:e}),$.$set(r);const i={};1&t&&(i.$$scope={dirty:t,ctx:e}),w.$set(i);const s={};1&t&&(s.$$scope={dirty:t,ctx:e}),P.$set(s)},i(e){C||(A(o.$$.fragment,e),A(y.$$.fragment,e),A($.$$.fragment,e),A(w.$$.fragment,e),A(P.$$.fragment,e),C=!0)},o(e){k(o.$$.fragment,e),k(y.$$.fragment,e),k($.$$.fragment,e),k(w.$$.fragment,e),k(P.$$.fragment,e),C=!1},d(e){e&&c(t),R(o),R(y),R($),R(w),R(P)}}}class Os extends e{constructor(e){super(),t(this,e,null,ws,n,{})}}const{Core:xs,Keywords:js,Schema:Is}=Mt;Is.add(JSON.parse('{\n    "$id": "https://spec.openapis.org/oas/3.1/dialect/base",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/core": true,\n        "https://json-schema.org/draft/2020-12/vocab/applicator": true,\n        "https://json-schema.org/draft/2020-12/vocab/unevaluated": true,\n        "https://json-schema.org/draft/2020-12/vocab/validation": true,\n        "https://json-schema.org/draft/2020-12/vocab/meta-data": true,\n        "https://json-schema.org/draft/2020-12/vocab/format-annotation": true,\n        "https://json-schema.org/draft/2020-12/vocab/content": true,\n        "https://spec.openapis.org/oas/3.1/vocab/base": false\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "OpenAPI 3.1 Schema Object Dialect",\n    "allOf": [\n        { "$ref": "https://json-schema.org/draft/2020-12/schema" },\n        { "$ref": "https://spec.openapis.org/oas/3.1/meta/base" }\n    ]\n}')),Is.add(JSON.parse('{\n    "$id": "https://spec.openapis.org/oas/3.1/meta/base",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://spec.openapis.org/oas/3.1/vocab/base": true\n    },\n    "$dynamicAnchor": "meta",\n    "title": "OAS Base vocabulary",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "example": true,\n        "discriminator": { "$ref": "#/$defs/discriminator" },\n        "externalDocs": { "$ref": "#/$defs/external-docs" },\n        "xml": { "$ref": "#/$defs/xml" }\n    },\n    "$defs": {\n        "extensible": {\n            "patternProperties": {\n                "^x-": true\n            }\n        },\n        "discriminator": {\n            "$ref": "#/$defs/extensible",\n            "type": "object",\n            "properties": {\n                "propertyName": {\n                    "type": "string"\n                },\n                "mapping": {\n                    "type": "object",\n                    "additionalProperties": {\n                        "type": "string"\n                    }\n                }\n            },\n            "required": ["propertyName"],\n            "unevaluatedProperties": false\n        },\n        "external-docs": {\n            "$ref": "#/$defs/extensible",\n            "type": "object",\n            "properties": {\n                "url": {\n                    "type": "string",\n                    "format": "uri-reference"\n                },\n                "description": {\n                    "type": "string"\n                }\n            },\n            "required": ["url"],\n            "unevaluatedProperties": false\n        },\n        "xml": {\n            "$ref": "#/$defs/extensible",\n            "type": "object",\n            "properties": {\n                "name": {\n                    "type": "string"\n                },\n                "namespace": {\n                    "type": "string",\n                    "format": "uri"\n                },\n                "prefix": {\n                    "type": "string"\n                },\n                "attribute": {\n                    "type": "boolean"\n                },\n                "wrapped": {\n                    "type": "boolean"\n                }\n            },\n            "unevaluatedProperties": false\n        }\n    }\n}')),xs.defineVocabulary("https://spec.openapis.org/oas/3.1/vocab/extensions",{example:js.metaData,discriminator:js.metaData,externalDocs:js.metaData,xml:js.metaData});const{Core:Es,Schema:Ps}=Mt;Es.add,Ps.get,Es.validate,Es.setMetaOutputFormat,Es.setShouldMetaValidate,Es.FLAG,Es.BASIC,Es.DETAILED,Es.VERBOSE;const{Core:As,Schema:ks,Instance:Rs}=Mt;var Cs={compile:async(e,t,n)=>{const a=await ks.step("items",n),r=ks.typeOf(a,"array")?ks.length(a):Number.MAX_SAFE_INTEGER;return ks.typeOf(e,"boolean")?[r,ks.value(e)]:[r,await As.compileSchema(e,t)]},interpret:([e,t],n,a,r)=>!Rs.typeOf(n,"array")||("string"==typeof t?Rs.every(((n,i)=>i<e||As.interpretSchema(t,n,a,r)),n):Rs.every(((n,a)=>a<e||t),n))};const{Core:Ns,Schema:Ts,Instance:Ds}=Mt,qs=([e,t],n,a,r)=>!Ds.typeOf(n,"array")||Ds.every(((n,i)=>i<e||Ns.interpretSchema(t,n,a,r)),n);var Ms={compile:async(e,t,n)=>{const a=await Ts.step("items",n);return[Ts.typeOf(a,"array")?Ts.length(a):Number.MAX_SAFE_INTEGER,await Ns.compileSchema(e,t)]},interpret:qs,collectEvaluatedItems:(e,t,n,a)=>qs(e,t,n,a)&&new Set(Ds.map(((e,t)=>t),t))};const{Core:Vs,Schema:Ls,Instance:Js}=Mt;var Us={compile:async(e,t,n)=>{const a=await Ls.step("properties",n),r=Ls.typeOf(a,"object")?Ls.keys(a):[],i=await Ls.step("patternProperties",n),s=Ls.typeOf(i,"object")?Ls.keys(i).map((e=>new RegExp(e))):[];return Ls.typeOf(e,"boolean")?[r,s,Ls.value(e)]:[r,s,await Vs.compileSchema(e,t)]},interpret:([e,t,n],a,r,i)=>{if(!Js.typeOf(a,"object"))return!0;const s=Js.entries(a).filter((([n])=>!e.includes(n)&&!t.some((e=>e.test(n)))));return"string"==typeof n?s.every((([,e])=>Vs.interpretSchema(n,e,r,i))):0===s.length||n}};const{Core:_s,Schema:Bs,Instance:Fs}=Mt,zs=([e,t,n],a,r,i)=>!Fs.typeOf(a,"object")||Fs.entries(a).filter((([n])=>!e.includes(n)&&!t.some((e=>e.test(n))))).every((([,e])=>_s.interpretSchema(n,e,r,i)));var Ks={compile:async(e,t,n)=>{const a=await Bs.step("properties",n),r=Bs.typeOf(a,"object")?Bs.keys(a):[],i=await Bs.step("patternProperties",n);return[r,Bs.typeOf(i,"object")?Bs.keys(i).map((e=>new RegExp(e))):[],await _s.compileSchema(e,t)]},interpret:zs,collectEvaluatedProperties:(e,t,n,a)=>zs(e,t,n,a)&&[new RegExp("")]};const{Core:Gs,Schema:Zs}=Mt;var Ws={compile:(e,t)=>ze.pipeline([Zs.map((async e=>Gs.compileSchema(await e,t))),ze.all],e),interpret:(e,t,n,a)=>e.every((e=>Gs.interpretSchema(e,t,n,a))),collectEvaluatedProperties:(e,t,n,a)=>e.reduce(((e,r)=>{const i=e&&Gs.collectEvaluatedProperties(r,t,n,a);return!1!==i&&[...e,...i]}),[]),collectEvaluatedItems:(e,t,n,a)=>e.reduce(((e,r)=>{const i=!1!==e&&Gs.collectEvaluatedItems(r,t,n,a);return!1!==i&&new Set([...e,...i])}),new Set)};const{Core:Hs,Schema:Xs}=Mt;var Ys={compile:(e,t)=>ze.pipeline([Xs.map((async e=>Hs.compileSchema(await e,t))),ze.all],e),interpret:(e,t,n,a)=>e.filter((e=>Hs.interpretSchema(e,t,n,a))).length>0,collectEvaluatedProperties:(e,t,n,a)=>e.reduce(((e,r)=>{const i=Hs.collectEvaluatedProperties(r,t,n,a);return!1!==i?[...e||[],...i]:e}),!1),collectEvaluatedItems:(e,t,n,a)=>e.reduce(((e,r)=>{const i=Hs.collectEvaluatedItems(r,t,n,a);return!1!==i?new Set([...e||[],...i]):e}),!1)};const{Schema:Qs,Instance:eo}=Mt;var to={compile:e=>un(Qs.value(e)),interpret:(e,t)=>un(eo.value(t))===e};const{Core:no,Instance:ao}=Mt;var ro={compile:(e,t)=>no.compileSchema(e,t),interpret:(e,t,n,a)=>!ao.typeOf(t,"array")||ao.some((t=>no.interpretSchema(e,t,n,a)),t)};const{Core:io,Schema:so,Instance:oo}=Mt,co=({contains:e,minContains:t,maxContains:n},a,r,i)=>{if(!oo.typeOf(a,"array"))return!0;const s=oo.reduce(((t,n)=>io.interpretSchema(e,n,r,i)?t+1:t),0,a);return s>=t&&s<=n};var lo={compile:async(e,t,n)=>{const a=await io.compileSchema(e,t),r=await so.step("minContains",n),i=so.typeOf(r,"number")?so.value(r):1,s=await so.step("maxContains",n);return{contains:a,minContains:i,maxContains:so.typeOf(s,"number")?so.value(s):Number.MAX_SAFE_INTEGER}},interpret:co,collectEvaluatedItems:(e,t,n,a)=>co(e,t,n,a)&&oo.reduce(((t,r,i)=>io.interpretSchema(e.contains,r,n,a)?t.add(i):t),new Set,t)};const{Core:mo,Schema:po,Instance:uo}=Mt,fo=({contains:e,minContains:t,maxContains:n},a,r,i)=>{if(!uo.typeOf(a,"array")&&!uo.typeOf(a,"object"))return!0;const s=uo.entries(a).reduce(((t,[,n])=>mo.interpretSchema(e,n,r,i)?t+1:t),0);return s>=t&&s<=n};var ho={compile:async(e,t,n)=>{const a=await mo.compileSchema(e,t),r=await po.step("minContains",n),i=po.typeOf(r,"number")?po.value(r):1,s=await po.step("maxContains",n);return{contains:a,minContains:i,maxContains:po.typeOf(s,"number")?po.value(s):Number.MAX_SAFE_INTEGER}},interpret:fo,collectEvaluatedItems:(e,t,n,a)=>fo(e,t,n,a)&&uo.typeOf(t,"array")&&uo.reduce(((t,r,i)=>mo.interpretSchema(e.contains,r,n,a)?t.add(i):t),new Set,t),collectEvaluatedProperties:(e,t,n,a)=>fo(e,t,n,a)&&uo.typeOf(t,"object")&&uo.entries(t).reduce(((t,[r,i])=>(mo.interpretSchema(e.contains,i,n,a)&&t.push(r),t)),[],t)};const{Core:yo,Schema:vo}=Mt;var go={compile:async(e,t)=>{await ze.pipeline([vo.entries,ze.map((([,e])=>yo.compileSchema(e,t))),ze.all],e)},interpret:()=>!0};const{Core:$o,Schema:bo,Instance:So}=Mt;var wo={compile:(e,t)=>ze.pipeline([bo.entries,ze.map((async([e,n])=>[e,bo.typeOf(n,"array")?bo.value(n):await $o.compileSchema(n,t)])),ze.all],e),interpret:(e,t,n,a)=>{const r=So.value(t);return!So.typeOf(t,"object")||e.every((([e,i])=>!(e in r)||(Array.isArray(i)?i.every((e=>e in r)):$o.interpretSchema(i,t,n,a))))}};const{Schema:Oo,Instance:xo}=Mt;var jo={compile:e=>ze.pipeline([Oo.entries,ze.map((([e,t])=>[e,Oo.value(t)])),ze.all],e),interpret:(e,t)=>{const n=xo.value(t);return!xo.typeOf(t,"object")||e.every((([e,t])=>!(e in n)||t.every((e=>e in n))))}};const{Core:Io,Schema:Eo,Instance:Po}=Mt;var Ao={compile:(e,t)=>ze.pipeline([Eo.entries,ze.map((async([e,n])=>[e,await Io.compileSchema(n,t)])),ze.all],e),interpret:(e,t,n,a)=>{const r=Po.value(t);return!Po.typeOf(t,"object")||e.every((([e,i])=>!(e in r)||Io.interpretSchema(i,t,n,a)))},collectEvaluatedProperties:(e,t,n,a)=>e.reduce(((e,[r,i])=>{if(!e||!Po.has(r,t))return e;const s=Io.collectEvaluatedProperties(i,t,n,a);return!1!==s&&e.concat(s)}),[])};var ko={isObject:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,escapeRegExp:e=>e.replace(/[.*+\-?^${}()|[\]\\]/g,"\\$&"),splitUrl:e=>{const t=e.indexOf("#"),n=-1===t?e.length:t,a=e.slice(0,n),r=e.slice(n+1);return[decodeURI(a),decodeURI(r)]}};const{Core:Ro,Schema:Co}=Mt,{splitUrl:No}=ko;var To={compile:async(e,t)=>{const[,n]=No(Co.value(e)),a=await Co.get(Co.value(e),e);return await Ro.compileSchema(a,t),[a.id,n]},interpret:([e,t],n,a,r)=>{if(t in a.metaData[e].dynamicAnchors)return Ro.interpretSchema(r[t],n,a,r);{const i=Co.getAnchorPointer(a.metaData[e],t);return Ro.interpretSchema(`${e}#${encodeURI(i)}`,n,a,r)}},collectEvaluatedProperties:Ro.collectEvaluatedProperties,collectEvaluatedItems:Ro.collectEvaluatedItems};const{Core:Do,Schema:qo}=Mt;var Mo={compile:qo.value,interpret:(e,t,n,a)=>{if(!(e in a))throw Error(`No dynamic anchor found for "${e}"`);return Do.interpretSchema(a[e],t,n,a)},collectEvaluatedProperties:Do.collectEvaluatedProperties,collectEvaluatedItems:Do.collectEvaluatedItems};const{Core:Vo,Schema:Lo}=Mt,{splitUrl:Jo}=Q;var Uo={compile:async(e,t)=>{const[,n]=Jo(Lo.value(e)),a=await Lo.get(Lo.value(e),e);return await Vo.compileSchema(a,t),n},interpret:(e,t,n,a)=>{if(!(e in a))throw Error(`No dynamic anchor found for "${e}"`);return Vo.interpretSchema(a[e],t,n,a)},collectEvaluatedProperties:Vo.collectEvaluatedProperties,collectEvaluatedItems:Vo.collectEvaluatedItems};const{Schema:_o,Instance:Bo}=Mt;var Fo={compile:e=>_o.value(e).map(un),interpret:(e,t)=>e.some((e=>un(Bo.value(t))===e))};const{Schema:zo,Instance:Ko}=Mt;var Go={compile:async e=>zo.value(e),interpret:(e,t)=>!Ko.typeOf(t,"number")||Ko.value(t)<e};const{Schema:Zo,Instance:Wo}=Mt;var Ho={compile:async e=>Zo.value(e),interpret:(e,t)=>!Wo.typeOf(t,"number")||Wo.value(t)>e};const{Core:Xo}=Mt;var Yo={compile:(e,t)=>Xo.compileSchema(e,t),interpret:(e,t,n,a)=>(Xo.interpretSchema(e,t,n,a),!0),collectEvaluatedProperties:(e,t,n,a)=>Xo.collectEvaluatedProperties(e,t,n,a)||[],collectEvaluatedItems:(e,t,n,a)=>Xo.collectEvaluatedItems(e,t,n,a)||new Set};const{Core:Qo,Schema:ec}=Mt,tc=(e,t,n,a)=>{const r=n[e][2];return"boolean"==typeof r?r:r.every((([e,,r])=>Qo.getKeyword(e).interpret(r,t,n,a)))};var nc={compile:async(e,t,n)=>{if(ec.has("if",n)){const a=await ec.step("if",n);return[await Qo.compileSchema(a,t),await Qo.compileSchema(e,t)]}return[]},interpret:([e,t],n,a,r)=>void 0===e||!tc(e,n,a,r)||Qo.interpretSchema(t,n,a,r),collectEvaluatedProperties:([e,t],n,a,r)=>void 0!==e&&tc(e,n,a,r)?Qo.collectEvaluatedProperties(t,n,a,r):[],collectEvaluatedItems:([e,t],n,a,r)=>void 0!==e&&tc(e,n,a,r)?Qo.collectEvaluatedItems(t,n,a,r):new Set};const{Core:ac,Schema:rc}=Mt,ic=(e,t,n,a)=>{const r=n[e][2];return"boolean"==typeof r?r:r.every((([e,,r])=>ac.getKeyword(e).interpret(r,t,n,a)))};var sc={compile:async(e,t,n)=>{if(rc.has("if",n)){const a=await rc.step("if",n);return[await ac.compileSchema(a,t),await ac.compileSchema(e,t)]}return[]},interpret:([e,t],n,a,r)=>void 0===e||ic(e,n,a,r)||ac.interpretSchema(t,n,a,r),collectEvaluatedProperties:([e,t],n,a,r)=>void 0===e||ic(e,n,a,r)?[]:ac.collectEvaluatedProperties(t,n,a,r),collectEvaluatedItems:([e,t],n,a,r)=>void 0===e||ic(e,n,a,r)?new Set:ac.collectEvaluatedItems(t,n,a,r)};const{Core:oc,Schema:cc,Instance:lc}=Mt,mc=(e,t,n,a)=>!lc.typeOf(t,"array")||("string"==typeof e?lc.every((t=>oc.interpretSchema(e,t,n,a)),t):lc.every(((t,r)=>!(r in e)||oc.interpretSchema(e[r],t,n,a)),t));var pc={compile:(e,t)=>cc.typeOf(e,"array")?ze.pipeline([cc.map((e=>oc.compileSchema(e,t))),ze.all],e):oc.compileSchema(e,t),interpret:mc,collectEvaluatedItems:(e,t,n,a)=>mc(e,t,n,a)&&("string"==typeof e?new Set(lc.map(((e,t)=>t),t)):new Set(e.map(((e,t)=>t))))};const{Core:uc,Schema:fc,Instance:dc}=Mt,hc=([e,t],n,a,r)=>!dc.typeOf(n,"array")||dc.every(((n,i)=>i<e||uc.interpretSchema(t,n,a,r)),n);var yc={compile:async(e,t,n)=>{const a=await fc.step("prefixItems",n);return[fc.typeOf(a,"array")?fc.length(a):0,await uc.compileSchema(e,t)]},interpret:hc,collectEvaluatedItems:(e,t,n,a)=>hc(e,t,n,a)&&new Set(dc.map(((e,t)=>t),t))};const{Schema:vc,Instance:gc}=Mt;var $c={compile:e=>vc.value(e),interpret:(e,t)=>!gc.typeOf(t,"array")||gc.length(t)<=e};const{Schema:bc,Instance:Sc}=Mt;var wc={compile:e=>bc.value(e),interpret:(e,t)=>!Sc.typeOf(t,"string")||Sc.length(t)<=e};const{Schema:Oc,Instance:xc}=Mt;var jc={compile:e=>Oc.value(e),interpret:(e,t)=>!xc.typeOf(t,"string")||[...xc.value(t)].length<=e};const{Schema:Ic,Instance:Ec}=Mt;var Pc={compile:e=>Ic.value(e),interpret:(e,t)=>!Ec.typeOf(t,"object")||Ec.keys(t).length<=e};const{Schema:Ac,Instance:kc}=Mt;var Rc={compile:async(e,t,n)=>{const a=await Ac.step("exclusiveMaximum",n),r=Ac.value(a);return[Ac.value(e),r]},interpret:([e,t],n)=>{if(!kc.typeOf(n,"number"))return!0;const a=kc.value(n);return t?a<e:a<=e}};const{Schema:Cc,Instance:Nc}=Mt;var Tc={compile:async e=>Cc.value(e),interpret:(e,t)=>!Nc.typeOf(t,"number")||Nc.value(t)<=e};const{Schema:Dc,Instance:qc}=Mt;var Mc={compile:e=>Dc.value(e),interpret:(e,t)=>!qc.typeOf(t,"array")||qc.length(t)>=e};const{Schema:Vc,Instance:Lc}=Mt;var Jc={compile:e=>Vc.value(e),interpret:(e,t)=>!Lc.typeOf(t,"string")||Lc.value(t).length>=e};const{Schema:Uc,Instance:_c}=Mt;var Bc={compile:e=>Uc.value(e),interpret:(e,t)=>!_c.typeOf(t,"string")||[..._c.value(t)].length>=e};const{Schema:Fc,Instance:zc}=Mt;var Kc={compile:e=>Fc.value(e),interpret:(e,t)=>{const n=zc.value(t);return!zc.typeOf(t,"object")||Object.keys(n).length>=e}};const{Schema:Gc,Instance:Zc}=Mt;var Wc={compile:async(e,t,n)=>{const a=await Gc.step("exclusiveMinimum",n),r=Gc.value(a);return[Gc.value(e),r]},interpret:([e,t],n)=>{if(!Zc.typeOf(n,"number"))return!0;const a=Zc.value(n);return t?a>e:a>=e}};const{Schema:Hc,Instance:Xc}=Mt;var Yc={compile:async e=>Hc.value(e),interpret:(e,t)=>!Xc.typeOf(t,"number")||Xc.value(t)>=e};const{Schema:Qc,Instance:el}=Mt,tl=(e,t)=>Math.abs(e-t)<1.1920929e-7;var nl={compile:e=>Qc.value(e),interpret:(e,t)=>{if(!el.typeOf(t,"number"))return!0;const n=el.value(t)%e;return tl(0,n)||tl(e,n)}};const{Core:al}=Mt;var rl={compile:al.compileSchema,interpret:(e,t,n,a)=>!al.interpretSchema(e,t,n,a)};const{Core:il,Schema:sl}=Mt;var ol={compile:(e,t)=>ze.pipeline([sl.map((async e=>il.compileSchema(await e,t))),ze.all],e),interpret:(e,t,n,a)=>{let r=0;for(const i of e)if(il.interpretSchema(i,t,n,a)&&r++,r>1)break;return 1===r},collectEvaluatedProperties:(e,t,n,a)=>{let r=0;return e.reduce(((e,i)=>{if(r>1)return!1;const s=il.collectEvaluatedProperties(i,t,n,a);return s?0==r++&&s:e}),!1)},collectEvaluatedItems:(e,t,n,a)=>{let r=0;return e.reduce(((e,i)=>{if(r>1)return!1;const s=il.collectEvaluatedItems(i,t,n,a);return s?0==r++&&s:e}),!1)}};const{Schema:cl,Instance:ll}=Mt;var ml={compile:async(e,t,n)=>{const a=await cl.value(e),r=await cl.step("properties",n),i=cl.typeOf(r,"object")?cl.keys(r):[],s=new Set(i);return a.forEach((e=>i.remove(e))),[...s]},interpret:(e,t)=>!ll.typeOf(t,"object")||e.every((e=>ll.value(t).hasOwnProperty(e)))};const{Schema:pl,Instance:ul}=Mt;var fl={compile:e=>new RegExp(pl.value(e),"u"),interpret:(e,t)=>!ul.typeOf(t,"string")||e.test(ul.value(t))};const{Core:dl,Schema:hl,Instance:yl}=Mt,vl=(e,t,n,a)=>!yl.typeOf(t,"object")||e.every((([e,r])=>yl.entries(t).filter((([t])=>e.test(t))).every((([,e])=>dl.interpretSchema(r,e,n,a)))));var gl={compile:(e,t)=>ze.pipeline([hl.entries,ze.map((async([e,n])=>[new RegExp(e,"u"),await dl.compileSchema(n,t)])),ze.all],e),interpret:vl,collectEvaluatedProperties:(e,t,n,a)=>vl(e,t,n,a)&&e.map((([e])=>e))};const{Core:$l,Schema:bl,Instance:Sl}=Mt,{escapeRegExp:wl}=ko,Ol=(e,t,n,a)=>!Sl.typeOf(t,"object")||Sl.entries(t).filter((([t])=>t in e)).every((([t,r])=>$l.interpretSchema(e[t],r,n,a)));var xl={compile:(e,t)=>ze.pipeline([bl.entries,ze.reduce((async(e,[n,a])=>(e[n]=await $l.compileSchema(a,t),e)),Object.create(null))],e),interpret:Ol,collectEvaluatedProperties:(e,t,n,a)=>Ol(e,t,n,a)&&Object.keys(e).map((e=>new RegExp(`^${wl(e)}$`)))};const{Core:jl,Schema:Il,Instance:El}=Mt;var Pl={compile:async(e,t)=>ze.pipeline([Il.entries,ze.reduce((async(e,[n,a])=>(e[n]=await ze.pipeline([Il.entries,ze.reduce((async(e,[n,a])=>(e[n]=await jl.compileSchema(a,t),e)),{})],a),e)),{})],e),interpret:(e,t,n,a)=>!El.typeOf(t,"object")||Object.entries(e).every((([e,r])=>!El.has(e,t)||jl.interpretSchema(r[El.value(t)[e]],t,n,a)))};const{Core:Al,Instance:kl}=Mt;var Rl={compile:(e,t)=>Al.compileSchema(e,t),interpret:(e,t,n,a)=>!kl.typeOf(t,"object")||kl.keys(t).every((t=>Al.interpretSchema(e,kl.cons(t),n,a)))};const{Core:Cl,Schema:Nl}=Mt;var Tl={compile:async(e,t)=>{const n=await Nl.get(Nl.value(e),e);return Cl.compileSchema(n,t)},interpret:Cl.interpretSchema,collectEvaluatedProperties:Cl.collectEvaluatedProperties,collectEvaluatedItems:Cl.collectEvaluatedItems};const{Schema:Dl,Instance:ql}=Mt;var Ml={compile:e=>Dl.value(e),interpret:(e,t)=>!ql.typeOf(t,"object")||e.every((e=>ql.value(t).hasOwnProperty(e)))};const{Core:Vl,Schema:Ll,Instance:Jl}=Mt,Ul=(e,t,n,a)=>!Jl.typeOf(t,"array")||Jl.every(((t,r)=>!(r in e)||Vl.interpretSchema(e[r],t,n,a)),t);var _l={compile:(e,t)=>ze.pipeline([Ll.map((e=>Vl.compileSchema(e,t))),ze.all],e),interpret:Ul,collectEvaluatedItems:(e,t,n,a)=>Ul(e,t,n,a)&&new Set(e.map(((e,t)=>t)))};const{Schema:Bl,Instance:Fl}=Mt;var zl={compile:e=>Bl.value(e),interpret:(e,t)=>"string"==typeof e?Fl.typeOf(t,e):e.some(Fl.typeOf(t))};const{Core:Kl,Schema:Gl,Instance:Zl}=Mt,Wl=([e,t],n,a,r)=>{if(!Zl.typeOf(n,"array"))return!0;const i=Kl.collectEvaluatedItems(e,n,a,r,!0);return!1===i||Zl.every(((e,s)=>i.has(s)||Kl.interpretSchema(t,Zl.step(s,n),a,r)),n)};var Hl={compile:async(e,t,n)=>[Gl.uri(n),await Kl.compileSchema(e,t)],interpret:Wl,collectEvaluatedItems:(e,t,n,a)=>Wl(e,t,n,a)&&new Set(Zl.map(((e,t)=>t),t))};const{Core:Xl,Schema:Yl,Instance:Ql}=Mt,em=([e,t],n,a,r)=>{if(!Ql.typeOf(n,"object"))return!0;const i=Xl.collectEvaluatedProperties(e,n,a,r,!0);return!i||Ql.entries(n).filter((([e])=>!i.some((t=>e.match(t))))).every((([,e])=>Xl.interpretSchema(t,e,a,r)))};var tm={compile:async(e,t,n)=>[Yl.uri(n),await Xl.compileSchema(e,t)],interpret:em,collectEvaluatedProperties:(e,t,n,a)=>em(e,t,n,a)&&[new RegExp("")]};const{Schema:nm,Instance:am}=Mt;var rm={compile:e=>nm.value(e),interpret:(e,t)=>{if(!am.typeOf(t,"array")||!1===e)return!0;const n=am.map((e=>un(am.value(e))),t);return new Set(n).size===n.length}};const{Keywords:im}=Mt;var sm={additionalItems:Cs,additionalItems6:Ms,additionalProperties:Us,additionalProperties6:Ks,allOf:Ws,anyOf:Ys,const:to,contains:ro,containsMinContainsMaxContains:lo,containsMinContainsMaxContainsFUTURE:ho,definitions:go,dependencies:wo,dependentRequired:jo,dependentSchemas:Ao,dynamicRef:To,dynamicRefFUTURE:Mo,dynamicRefFUTURE2:Uo,enum:Fo,exclusiveMaximum:Go,exclusiveMinimum:Ho,if:Yo,then:nc,else:sc,items:pc,items202012:yc,maxItems:$c,maxLength:wc,maxLength6:jc,maxProperties:Pc,maximumExclusiveMaximum:Rc,maximum:Tc,metaData:im.metaData,minItems:Mc,minLength:Jc,minLength6:Bc,minProperties:Kc,minimumExclusiveMinimum:Wc,minimum:Yc,multipleOf:nl,not:rl,oneOf:ol,optional:ml,pattern:fl,patternProperties:gl,properties:xl,propertyDependencies:Pl,propertyNames:Rl,ref:Tl,required:Ml,tupleItems:_l,type:zl,unevaluatedItems:Hl,unevaluatedProperties:tm,uniqueItems:rm,validate:im.validate};const{Core:om,Schema:cm}=Mt,lm="https://json-schema.org/draft/future/schema";function mm(e){return{c:u,l:u,m:u,p:u,i:u,o:u,d:u}}function pm(e){let t,n;return t=new os({props:{results:e[5]}}),{c(){j(t.$$.fragment)},l(e){I(t.$$.fragment,e)},m(e,a){E(t,e,a),n=!0},p(e,n){const a={};32&n&&(a.results=e[5]),t.$set(a)},i(e){n||(A(t.$$.fragment,e),n=!0)},o(e){k(t.$$.fragment,e),n=!1},d(e){R(t,e)}}}function um(e){return{c:u,l:u,m:u,p:u,i:u,o:u,d:u}}function fm(e){let t,n,u,f,y,g,b,w,O,C,D,q,M,V,U,_,B,F,z,K,G,Z,W,H,X,Y,Q,ee,te,ne,ae,re,ie;function se(t){e[11](t)}let oe={ns:"schemas",tabs:e[1],newTab:e[7],active:0};function ce(t){e[12](t)}function le(t){e[13](t)}function me(t){e[14](t)}void 0!==e[0]&&(oe.format=e[0]),U=new Hi({props:oe}),S.push((()=>x(U,"format",se))),U.$on("input",e[9]);let pe={ns:"instances",tabs:e[2],newTab:e[8]};void 0!==e[3]&&(pe.selected=e[3]),void 0!==e[3]&&(pe.active=e[3]),void 0!==e[0]&&(pe.format=e[0]),z=new Hi({props:pe}),S.push((()=>x(z,"selected",ce))),S.push((()=>x(z,"active",le))),S.push((()=>x(z,"format",me))),z.$on("input",e[10]),X=new os({props:{results:e[4]}});let ue={ctx:e,current:null,token:null,hasCatch:!1,pending:um,then:pm,catch:mm,value:18,blocks:[,,,]};return N(ee=e[4],ue),ne=new Os({}),{c(){t=d(),n=a("div"),u=a("button"),f=r("JSON"),g=a("button"),b=r("YAML"),O=d(),C=a("main"),D=a("h1"),q=r("Hyperjump - JSON Schema Validator"),M=d(),V=a("div"),j(U.$$.fragment),B=d(),F=a("div"),j(z.$$.fragment),W=d(),H=a("div"),j(X.$$.fragment),Y=d(),Q=a("div"),ue.block.c(),te=d(),j(ne.$$.fragment),this.h()},l(e){L('[data-svelte="svelte-14138tz"]',document.head).forEach(c),t=h(e),n=i(e,"DIV",{class:!0});var a=s(n);u=i(a,"BUTTON",{class:!0});var r=s(u);f=o(r,"JSON"),r.forEach(c),g=i(a,"BUTTON",{class:!0});var l=s(g);b=o(l,"YAML"),l.forEach(c),a.forEach(c),O=h(e),C=i(e,"MAIN",{class:!0});var m=s(C);D=i(m,"H1",{class:!0});var p=s(D);q=o(p,"Hyperjump - JSON Schema Validator"),p.forEach(c),M=h(m),V=i(m,"DIV",{class:!0});var d=s(V);I(U.$$.fragment,d),d.forEach(c),B=h(m),F=i(m,"DIV",{class:!0});var y=s(F);I(z.$$.fragment,y),y.forEach(c),W=h(m),H=i(m,"DIV",{class:!0});var v=s(H);I(X.$$.fragment,v),v.forEach(c),Y=h(m),Q=i(m,"DIV",{class:!0});var $=s(Q);ue.block.l($),$.forEach(c),te=h(m),I(ne.$$.fragment,m),m.forEach(c),this.h()},h(){document.title="Hyperjump - JSON Schema Validator",l(u,"class",y=J("json"===e[0]?"selected":"")+" svelte-ub4xmj"),l(g,"class",w=J("yaml"===e[0]?"selected":"")+" svelte-ub4xmj"),l(n,"class","format svelte-ub4xmj"),l(D,"class","svelte-ub4xmj"),l(V,"class","editor-section svelte-ub4xmj"),l(F,"class","editor-section svelte-ub4xmj"),l(H,"class","results "+ym+" svelte-ub4xmj"),l(Q,"class","results "+ym+" svelte-ub4xmj"),l(C,"class","svelte-ub4xmj")},m(a,r){m(a,t,r),m(a,n,r),p(n,u),p(u,f),p(n,g),p(g,b),m(a,O,r),m(a,C,r),p(C,D),p(D,q),p(C,M),p(C,V),E(U,V,null),p(C,B),p(C,F),E(z,F,null),p(C,W),p(C,H),E(X,H,null),p(C,Y),p(C,Q),ue.block.m(Q,ue.anchor=null),ue.mount=()=>Q,ue.anchor=null,p(C,te),E(ne,C,null),ae=!0,re||(ie=[v(u,"click",e[6]("json")),v(g,"click",e[6]("yaml"))],re=!0)},p(t,[n]){e=t,(!ae||1&n&&y!==(y=J("json"===e[0]?"selected":"")+" svelte-ub4xmj"))&&l(u,"class",y),(!ae||1&n&&w!==(w=J("yaml"===e[0]?"selected":"")+" svelte-ub4xmj"))&&l(g,"class",w);const a={};2&n&&(a.tabs=e[1]),!_&&1&n&&(_=!0,a.format=e[0],P((()=>_=!1))),U.$set(a);const r={};4&n&&(r.tabs=e[2]),!K&&8&n&&(K=!0,r.selected=e[3],P((()=>K=!1))),!G&&8&n&&(G=!0,r.active=e[3],P((()=>G=!1))),!Z&&1&n&&(Z=!0,r.format=e[0],P((()=>Z=!1))),z.$set(r);const i={};16&n&&(i.results=e[4]),X.$set(i),ue.ctx=e,16&n&&ee!==(ee=e[4])&&N(ee,ue)||T(ue,e,n)},i(e){ae||(A(U.$$.fragment,e),A(z.$$.fragment,e),A(X.$$.fragment,e),A(ue.block),A(ne.$$.fragment,e),ae=!0)},o(e){k(U.$$.fragment,e),k(z.$$.fragment,e),k(X.$$.fragment,e);for(let e=0;e<3;e+=1){const t=ue.blocks[e];k(t)}k(ne.$$.fragment,e),ae=!1},d(e){e&&c(t),e&&c(n),e&&c(O),e&&c(C),R(U),R(z),R(X),ue.block.d(),ue.token=null,ue=null,R(ne),re=!1,$(ie)}}}cm.setConfig(lm,"baseToken","$id"),cm.setConfig(lm,"embeddedToken","$id"),cm.setConfig(lm,"anchorToken","$anchor"),cm.setConfig(lm,"dynamicAnchorToken","$dynamicAnchor"),cm.setConfig(lm,"vocabularyToken","$vocabulary"),cm.setConfig(lm,"mandatoryVocabularies",["https://json-schema.org/draft/future/vocab/core"]),cm.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$id": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/future/vocab/core": true,\n        "https://json-schema.org/draft/future/vocab/applicator": true,\n        "https://json-schema.org/draft/future/vocab/unevaluated": true,\n        "https://json-schema.org/draft/future/vocab/validation": true,\n        "https://json-schema.org/draft/future/vocab/meta-data": true,\n        "https://json-schema.org/draft/future/vocab/format-annotation": true,\n        "https://json-schema.org/draft/future/vocab/content": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format-annotation"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean", "string"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$dynamicRef": "#meta" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),cm.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/core",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/future/vocab/core": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean", "string"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z_][-A-Za-z0-9._]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$dynamicRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$dynamicAnchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z_][-A-Za-z0-9._]*$"\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        }\n    }\n}')),om.defineVocabulary("https://json-schema.org/draft/future/vocab/core",{validate:sm.validate,$defs:sm.definitions,$dynamicRef:sm.dynamicRefFUTURE2,$dref:sm.dynamicRefFUTURE,$ref:sm.ref}),cm.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/applicator",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/future/vocab/applicator": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Applicator vocabulary meta-schema",\n    "type": ["object", "boolean", "string"],\n    "properties": {\n        "prefixItems": { "$ref": "#/$defs/schemaArray" },\n        "items": { "$dynamicRef": "#meta" },\n        "contains": { "$dynamicRef": "#meta" },\n        "additionalProperties": { "$dynamicRef": "#meta" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$dynamicRef": "#meta"\n            }\n        },\n        "propertyDependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "type": "object",\n                "additionalProperties": { "$dynamicRef": "#meta" },\n                "default": {}\n            },\n            "default": {}\n        },\n        "propertyNames": { "$dynamicRef": "#meta" },\n        "if": { "$dynamicRef": "#meta" },\n        "then": { "$dynamicRef": "#meta" },\n        "else": { "$dynamicRef": "#meta" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$dynamicRef": "#meta" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$dynamicRef": "#meta" }\n        }\n    }\n}')),om.defineVocabulary("https://json-schema.org/draft/future/vocab/applicator",{additionalProperties:sm.additionalProperties6,allOf:sm.allOf,anyOf:sm.anyOf,contains:sm.containsMinContainsMaxContainsFUTURE,dependentSchemas:sm.dependentSchemas,if:sm.if,then:sm.then,else:sm.else,items:sm.items202012,not:sm.not,oneOf:sm.oneOf,patternProperties:sm.patternProperties,prefixItems:sm.tupleItems,properties:sm.properties,propertyDependencies:sm.propertyDependencies,propertyNames:sm.propertyNames}),cm.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/validation",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/future/vocab/validation": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean", "string"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "optional": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),om.defineVocabulary("https://json-schema.org/draft/future/vocab/validation",{const:sm.const,dependentRequired:sm.dependentRequired,enum:sm.enum,exclusiveMaximum:sm.exclusiveMaximum,exclusiveMinimum:sm.exclusiveMinimum,maxItems:sm.maxItems,maxLength:sm.maxLength6,maxProperties:sm.maxProperties,maximum:sm.maximum,minItems:sm.minItems,minLength:sm.minLength6,minProperties:sm.minProperties,minimum:sm.minimum,multipleOf:sm.multipleOf,optional:sm.optional,pattern:sm.pattern,required:sm.required,type:sm.type,uniqueItems:sm.uniqueItems}),cm.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/future/vocab/meta-data": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean", "string"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),om.defineVocabulary("https://json-schema.org/draft/future/vocab/meta-data",{default:sm.metaData,deprecated:sm.metaData,description:sm.metaData,examples:sm.metaData,readOnly:sm.metaData,title:sm.metaData,writeOnly:sm.metaData}),cm.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/format-annotation",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/future/vocab/format-annotation": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Format vocabulary meta-schema for annotation results",\n    "type": ["object", "boolean", "string"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),om.defineVocabulary("https://json-schema.org/draft/future/vocab/format-annotation",{format:sm.metaData}),cm.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/format-assertion",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/future/vocab/format-assertion": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Format vocabulary meta-schema for assertion results",\n    "type": ["object", "boolean", "string"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),cm.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/content",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/future/vocab/content": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean", "string"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$dynamicRef": "#meta" }\n    }\n}')),om.defineVocabulary("https://json-schema.org/draft/future/vocab/content",{contentEncoding:sm.metaData,contentMediaType:sm.metaData,contentSchema:sm.metaData}),cm.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/future/meta/unevaluated",\n    "$schema": "https://json-schema.org/draft/future/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/future/vocab/unevaluated": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Unevaluated applicator vocabulary meta-schema",\n    "type": ["object", "boolean", "string"],\n    "properties": {\n        "unevaluatedItems": { "$dynamicRef": "#meta" },\n        "unevaluatedProperties": { "$dynamicRef": "#meta" }\n    }\n}')),om.defineVocabulary("https://json-schema.org/draft/future/vocab/unevaluated",{unevaluatedItems:sm.unevaluatedItems,unevaluatedProperties:sm.unevaluatedProperties});const dm="https://json-schema.org/draft/2020-12/schema",hm="https://json-schema.hyperjump.io/schema",ym="solarized-dark";function vm(e,t,n){let a,r,i="json";const s=(e,t)=>"yaml"===t?U.parse(e):JSON.parse(e),o={json:e=>`{\n  "$id": "${e}",\n  "$schema": "${dm}"\n}`,yaml:e=>`$id: '${e}'\n$schema: '${dm}'`},c=function(){let e=1;return(t,n,a=!1)=>{const r=n||`${hm}${++e}`;return{label:t||`Schema ${e}`,text:o[i](r),persistent:a}}}(),l=function(){let e=1;return()=>({label:"Instance "+e++,text:""})}();let m=[c("Schema",hm,!0)],p=[l("Instance")],u=0;const f=function(e,t){let n;return({detail:a})=>{clearTimeout(n),n=setTimeout((()=>e(a)),t)}},d=f((e=>n(1,m=e)),750),h=f((e=>n(2,p=e)),750);return bi.setMetaOutputFormat(bi.BASIC),e.$$.update=()=>{3&e.$$.dirty&&n(4,a=async function(){m.forEach(((e,t)=>{const n=0===t?hm:"";bi.add(s(e.text||"true",i),n,dm)}));const e=await bi.get(hm);return bi.validate(e)}()),29&e.$$.dirty&&n(5,r=async function(){if(""!==p[u].text){let e;try{e=await a}catch(e){}if(e){const t=e(s(p[u].text,i),bi.BASIC);if(t.valid)return t;throw{output:t}}}}())},[i,m,p,u,a,r,e=>()=>{n(0,i=e),n(1,m=[c("Schema",hm,!0)]),n(2,p=[l("Instance")]),n(3,u=0)},c,l,d,h,function(e){i=e,n(0,i)},function(e){u=e,n(3,u)},function(e){u=e,n(3,u)},function(e){i=e,n(0,i)}]}export default class extends e{constructor(e){super(),t(this,e,vm,fm,n,{})}}
